<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cloud on 임창수</title>
    <link>https://markruler.github.io/tags/cloud/</link>
    <description>Recent content in Cloud on 임창수</description>
    <generator>Hugo</generator>
    <language>ko-kr</language>
    <managingEditor>imcxsu@gmail.com (Im Changsu)</managingEditor>
    <webMaster>imcxsu@gmail.com (Im Changsu)</webMaster>
    <copyright>Im Changsu 2020 - 2024</copyright>
    <lastBuildDate>Mon, 09 Sep 2024 18:35:00 +0900</lastBuildDate>
    <atom:link href="https://markruler.github.io/tags/cloud/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>쿠버네티스 레벨 트리거링 및 조정</title>
      <link>https://markruler.github.io/posts/kubernetes/level-triggering-and-reconciliation/</link>
      <pubDate>Wed, 13 Jan 2021 23:05:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/kubernetes/level-triggering-and-reconciliation/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;James Bowes(&lt;a href=&#34;https://twitter.com/jrbowes&#34;&gt;@jrbowes&lt;/a&gt;)의 &lt;a href=&#34;https://hackernoon.com/level-triggering-and-reconciliation-in-kubernetes-1f17fe30333d&#34;&gt;Level Triggering and Reconciliation in Kubernetes&lt;/a&gt;를 번역한 글입니다.&lt;/li&gt;&#xA;&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;    &lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;&#xA;      &lt;iframe allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&#34; allowfullscreen=&#34;allowfullscreen&#34; loading=&#34;eager&#34; referrerpolicy=&#34;strict-origin-when-cross-origin&#34; src=&#34;https://www.youtube.com/embed/tCht7FvIDdY?autoplay=0&amp;amp;controls=1&amp;amp;end=0&amp;amp;loop=0&amp;amp;mute=0&amp;amp;start=0&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; title=&#34;YouTube video&#34;&gt;&lt;/iframe&gt;&#xA;    &lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;시스템-프로그래밍-개념으로-보는-쿠버네티스가-클러스터를-관리하는-방법&#34;&gt;시스템 프로그래밍 개념으로 보는 쿠버네티스가 클러스터를 관리하는 방법&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/&#34;&gt;쿠버네티스&lt;/a&gt;는 현재&#xA;&lt;a href=&#34;https://techcrunch.com/2017/12/18/as-kubernetes-surged-in-popularity-in-2017-it-created-a-vibrant-ecosystem/&#34;&gt;가장 있기 있는&lt;/a&gt;&#xA;컨테이너 오케스트레이터입니다. 이런 성공의 밑받침은 신뢰성입니다. 모든&#xA;소프트웨어에는 버그가 있죠. 그러나 컨테이너를 실행하는 데 있어서 쿠버네티스는&#xA;다른 소프트웨어보다 버그가 적습니다.&lt;/p&gt;&#xA;&lt;p&gt;쿠버네티스는 원하는 수의 컨테이너를 제때에 실행합니다.&#xA;그리고 그 숫자를 계속해서 유지하죠.&#xA;&lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/&#34;&gt;공식 문서&lt;/a&gt;에&#xA;따르면 쿠버네티스가 &lt;strong&gt;자가 치유(self-healing)&lt;/strong&gt; 하는 것이라고 말합니다.&#xA;이런 동작 방식은 쿠버네티스 설계의 핵심 철학에서 비롯됩니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>NFV 도커 컨테이너 초심자 가이드</title>
      <link>https://markruler.github.io/posts/nfv/beginners-guide-docker-container-nfv/</link>
      <pubDate>Mon, 16 Nov 2020 22:40:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/nfv/beginners-guide-docker-container-nfv/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://telcocloudbridge.com/blog/beginners-guide-docker-container-nfv/&#34;&gt;Faisal Khan의 A Beginner&amp;rsquo;s Guide to Docker Container in NFV&lt;/a&gt;를 번역한 글입니다.&lt;/li&gt;&#xA;&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;&#xA;&lt;li&gt;2016년 3월 3일에 쓰여진 글로 현재와 다를 수 있습니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;새롭게 등장한 도커(Docker) 컨테이너는 NFV를 혁신할 수 있는 잠재력을 가지고 있습니다.&lt;/p&gt;&#xA;&lt;p&gt;무엇보다 도커 컨테이너는 가상 머신에 비해 가볍고, 적은 오버헤드와 리소스만을 요구하며, 동일한 운영 체제에서 실행되는 애플리케이션을 격리시킬 수 있습니다.&lt;/p&gt;&#xA;&lt;p&gt;즉, NFV의 VNF(가상 네트워크 기능)를 완전히 격리시켜 도커 컨테이너에서 실행할 수 있다면 가상 머신이 필요 없을 지도 모릅니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Observability 용어 정리</title>
      <link>https://markruler.github.io/posts/cloud/monitor-trace-log-metric/</link>
      <pubDate>Fri, 02 Oct 2020 16:24:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/cloud/monitor-trace-log-metric/</guid>
      <description>&lt;h1 id=&#34;observability&#34;&gt;Observability&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;관측성&lt;/li&gt;&#xA;&lt;li&gt;관찰성&lt;/li&gt;&#xA;&lt;li&gt;관측 가능성&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;제어 이론에서 &amp;lsquo;observability&amp;rsquo;라는 용어는&#xA;시스템의 내부 상태 변수와 그에 따른 행동을&#xA;시스템에 대한 입력과 출력만 보고 결정할 수 있다면&#xA;그 시스템이 관측 가능하다는 것을 나타낸다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;event-logging&#34;&gt;Event Logging&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/cloud/kibana5-fluentd.png&#34; alt=&#34;kibana5-fluentd&#34;&gt;&#xA;&lt;em&gt;Fluentd-Kibana&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;로그는 시스템 프로세스의 개별 이벤트를 기록하는 것이다.&#xA;하지만 각 로그 스트림은 단일 인스턴스에 대해서만 알려주기 때문에&#xA;마이크로서비스에서 전체적인 모니터링을 하기에는 어려움이 있다.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.fluentd.org/&#34;&gt;Fluentd&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.elastic.co/&#34;&gt;Elastic&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.datadoghq.com/logs/&#34;&gt;Datadog Log Management&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;software-tracing&#34;&gt;Software Tracing&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/cloud/jaeger-embed-trace-view.png&#34; alt=&#34;jaeger-embed-trace-view&#34;&gt;&#xA;&lt;em&gt;Jaeger&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;사용자의 트래픽이 지나가는 애플리케이션의 전체 스택을 추적한다.&#xA;주로 서비스를 최적화하는 데 사용된다.&#xA;예를 들어, 특정 서비스에 병목이 예상되는 경우&#xA;트레이싱해서 어떤 부분인지 확인하고 최적화를 시도해볼 수 있다.&#xA;결국 트레이싱은 구조화된 형태의 로그 이벤트일 뿐이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>NFV의 컴퓨팅 도메인에 대한 오해!</title>
      <link>https://markruler.github.io/posts/nfv/the-misunderstood-facts-about-compute-domain-in-nfv/</link>
      <pubDate>Thu, 01 Oct 2020 22:23:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/nfv/the-misunderstood-facts-about-compute-domain-in-nfv/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://telcocloudbridge.com/blog/the-misunderstood-facts-about-compute-domain-in-nfv/&#34;&gt;Faisal Khan의 The Misunderstood Facts about Compute Domain in NFV!&lt;/a&gt;를 번역한 글입니다.&lt;/li&gt;&#xA;&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;NFV에 대해 생각해 보세요! 그리고 x86 프로세서를 생각해 보세요&amp;hellip; 둘은 뗄 수 없는 사이입니다. 그렇죠?&lt;/p&gt;&#xA;&lt;p&gt;프로세서(컴퓨팅 파트)가 아무리 단순하게 들리더라도 NFV의 컴퓨팅 도메인(compute domain)이 노드의 컴퓨팅 프로세서(compute processor)가 같지 않다는 사실을 모르는 사람이 많을 것입니다. 사실&amp;hellip; 훨씬 더 많습니다.&lt;/p&gt;&#xA;&lt;p&gt;NFV의 &amp;ldquo;Compute Domain&amp;quot;과 &amp;ldquo;Compute Node&amp;quot;는 ETSI 정의에 따르면 동일한 것을 의미하지 않습니다. 이를 잘 알고 있으면 NFV 기본 아키텍처를 이해하는 데 많은 혼란을 피할 수 있으며, 벤더 및 고객과 이 주제에 대해 소통하는 과정에서 오해를 피할 수 있습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>NFV MANO 초심자 가이드</title>
      <link>https://markruler.github.io/posts/nfv/beginners-guide-to-nfv-mano/</link>
      <pubDate>Wed, 23 Sep 2020 00:58:08 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/nfv/beginners-guide-to-nfv-mano/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.telcocloudbridge.com/blog/a-beginners-guide-to-nfv-management-orchestration-mano/&#34;&gt;Faisal Khan의 A Beginner&amp;rsquo;s Guide to NFV Management &amp;amp; Orchestration (MANO)&lt;/a&gt;을 번역한 글입니다.&lt;/li&gt;&#xA;&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#nfv%EC%97%90%EC%84%9C-mano%EB%9E%80&#34;&gt;NFV에서 MANO란?&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#1-virtualized-infrastructure-manager-vim&#34;&gt;1. Virtualized Infrastructure Manager (VIM)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#2-virtual-network-function-manager-vnfm&#34;&gt;2. Virtual Network Function Manager (VNFM)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#3-nfv-orchestrator-nfvo&#34;&gt;3. NFV Orchestrator (NFVO)&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#resource-orchestration&#34;&gt;Resource Orchestration&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#service-orchestration&#34;&gt;Service Orchestration&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#4-repositories&#34;&gt;4. Repositories&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#vnf-catalog&#34;&gt;VNF Catalog&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#network-services-ns-catalog&#34;&gt;Network Services (NS) Catalog&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#nfv-instances&#34;&gt;NFV Instances&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#nfvi-resources&#34;&gt;NFVI Resources&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#5-element-management-em&#34;&gt;5. Element Management (EM)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#6-ossbss&#34;&gt;6. OSS/BSS&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#7-reference-points&#34;&gt;7. Reference Points&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;NFV가 처음이라면 NFV Management &amp;amp; Orchestration (NFV MANO)를 이해하려고 할 때 두 가지 어려운 점이 있습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>&#34;NFV 아키텍처&#34; 이해를 위한 치트 시트</title>
      <link>https://markruler.github.io/posts/nfv/cheat-sheet-understanding-nfv-architecture/</link>
      <pubDate>Tue, 22 Sep 2020 21:58:08 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/nfv/cheat-sheet-understanding-nfv-architecture/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.telcocloudbridge.com/blog/a-cheat-sheet-for-understanding-nfv-architecture/&#34;&gt;Faisal Khan의 A Cheat Sheet for Understanding &amp;ldquo;NFV Architecture&amp;rdquo;&lt;/a&gt;를 번역한 글입니다.&lt;/li&gt;&#xA;&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;시간이 없으신가요?&lt;/p&gt;&#xA;&lt;p&gt;쉽게 이해할 수 있는 NFV 용어/아키텍처에 대한 빠른 업데이트가 필요하신가요?&lt;/p&gt;&#xA;&lt;p&gt;그렇다면 NFV 아키텍처를 시작하는 데 필요한 모든 정보를 얻을 수 있는 아래 7가지 주요 블록을 보세요. 블록 번호 및 정의를 따라가세요.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/nfv/nfv-architecture.png&#34; alt=&#34;nfv-architecture&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-vnf-virtual-network-function&#34;&gt;1. VNF (Virtual Network Function)&lt;/h2&gt;&#xA;&lt;p&gt;VNF는 가상화된 네트워크 요소로 NFV 아키텍처의 기본 블록입니다.&#xA;예를 들어 라우터를 가상화하면 라우터 VNF라고 부르고, 다른 예는 기지국(base station) VNF도 있습니다.&#xA;네트워크 요소의 한 가지 하위 기능(sub-function)만 가상화해도 VNF라고 합니다.&#xA;예를 들어 라우터의 다양한 하위 기능은 가상 라우터로서 함께 작동하는 별도의 VNF가 될 수 있다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>쿠버네티스 API 접근 제어</title>
      <link>https://markruler.github.io/posts/kubernetes/controlling-access-api/</link>
      <pubDate>Thu, 17 Sep 2020 06:58:08 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/kubernetes/controlling-access-api/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/controlling-access/&#34;&gt;쿠버네티스 공식 문서&lt;/a&gt;를 번역했습니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!-- overview --&gt;&#xA;&lt;p&gt;이 페이지는 쿠버네티스 API에 대한 접근 제어의 개요를 제공한다.&lt;/p&gt;&#xA;&lt;!-- body --&gt;&#xA;&lt;p&gt;사용자는&lt;code&gt;kubectl&lt;/code&gt;, 클라이언트 라이브러리&#xA;또는 REST 요청을 통해&#xA;&lt;a href=&#34;https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/&#34;&gt;API에 접근한다&lt;/a&gt;.&#xA;사용자와 쿠버네티스 서비스 어카운트 모두 API에 접근할 수 있다.&#xA;요청이 API에 도달하면,&#xA;다음 다이어그램에 설명된 몇 가지 단계를 거친다.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/kubernetes/access-control-overview.svg&#34; alt=&#34;Diagram of request handling steps for Kubernetes API request&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;전송-보안&#34;&gt;전송 보안&lt;/h2&gt;&#xA;&lt;p&gt;일반적인 쿠버네티스 클러스터에서 API는 443번 포트에서 서비스한다.&#xA;API 서버는 인증서를 제시한다.&#xA;이 인증서는 종종 자체 서명되기 때문에 일반적으로 사용자 머신의 &lt;code&gt;$USER/.kube/config&lt;/code&gt;은&#xA;API 서버의 인증서에 대한 루트 인증서를 포함하며,&#xA;시스템 기본 루트 인증서 대신 사용된다.&#xA;&lt;code&gt;kube-up.sh&lt;/code&gt;을 사용하여 클러스터를 직접 생성할 때&#xA;이 인증서는 일반적으로 &lt;code&gt;$USER/.kube/config&lt;/code&gt;에 자동으로 기록된다.&#xA;클러스터에 여러 명의 사용자가 있는 경우, 작성자는 인증서를 다른 사용자와 공유해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>MEC 아키텍처 초심자 가이드</title>
      <link>https://markruler.github.io/posts/mec/beginners-guide-to-mec-architecture/</link>
      <pubDate>Sun, 13 Sep 2020 20:58:08 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/mec/beginners-guide-to-mec-architecture/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Faisal Khan의 &lt;a href=&#34;https://www.telcocloudbridge.com/blog/beginners-guide-to-mec-architecture-multi-access-edge-computing/&#34;&gt;Beginners Guide to MEC Architecture (Multi-access Edge Computing)&lt;/a&gt;을 번역한 글입니다.&#xA;저자의 허락을 받아 번역했습니다.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;MEC&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 아키텍처 가이드에 오신 것을 환영합니다!&lt;/p&gt;&#xA;&lt;p&gt;MEC는 5G의 저지연(low-latency) 서비스를 활용하려는 이동통신사들의 새로운 투자 물결을 가져올 것입니다.&#xA;이는 소비자와 더 가까운 곳, 즉 무선 기지국(radio site)과 가까운 곳에서 서비스를 운영하겠다는 것을 의미합니다.&lt;/p&gt;&#xA;&lt;p&gt;MEC는 서비스 사업자들에게 새로운 서비스 분야와 수익 창출의 수단입니다.&#xA;예를 들어 더 빠른 게임 경험, 증강/가상 현실, 커넥티드 카 등이 있습니다.&lt;/p&gt;&#xA;&lt;p&gt;이러한 잠재력 때문에 Azure, AWS, Google과 같은 웹 스케일러(web scaler)도&#xA;이 흐름에 뛰어들어 갑자기 자신들의 MEC 플랫폼을 구축하는 데 자금을 투입하기 시작한 것입니다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
