<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Network on 임창수</title>
    <link>https://markruler.github.io/tags/network/</link>
    <description>Recent content in Network on 임창수</description>
    <generator>Hugo</generator>
    <language>ko-kr</language>
    <managingEditor>imcxsu@gmail.com (Im Changsu)</managingEditor>
    <webMaster>imcxsu@gmail.com (Im Changsu)</webMaster>
    <copyright>Im Changsu | Since 2020</copyright>
    <lastBuildDate>Thu, 20 Mar 2025 23:03:00 +0900</lastBuildDate>
    <atom:link href="https://markruler.github.io/tags/network/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>네트워크 레이어</title>
      <link>https://markruler.github.io/posts/network/network-layer/</link>
      <pubDate>Thu, 20 Mar 2025 23:03:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/network/network-layer/</guid>
      <description>&lt;p&gt;&lt;strong&gt;OSI 모델&lt;/strong&gt;은 다양한 통신 시스템이 통신할 수 있도록 국제표준화기구(ISO)에서 만든 개념 모델입니다.&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&#xA;각 계층(Layer)은 특정한 역할을 담당합니다.&#xA;이 글에서는 각 계층의 주요 기능과 특징을 살펴보겠습니다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;용어&#34;&gt;용어&lt;/h1&gt;&#xA;&lt;p&gt;먼저 공통 용어를 정리하며 시작하겠습니다.&lt;/p&gt;&#xA;&lt;p&gt;1 계층은 영어로 Layer 1, 줄여서 L1이라고 부릅니다.&#xA;이 글에서도 글을 줄여 쓰기 위해서 물리 계층은 L1이라고 표기하겠습니다.&lt;/p&gt;&#xA;&lt;p&gt;계층에서 처리하는 한 덩어리의 데이터 단위를 &lt;strong&gt;PDU&lt;/strong&gt;(Protocol Data Unit)라고 부릅니다.&#xA;PDU는 제어 정보를 포함한 헤더(header), 데이터 자체인 페이로드(payload)로 구성되어 있습니다.&#xA;웹 서비스를 개발해보셨다면 HTTP 헤더와 바디를 생각하시면 됩니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>일상에서의 Wireshark</title>
      <link>https://markruler.github.io/posts/network/wireshark/</link>
      <pubDate>Mon, 30 Dec 2024 18:38:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/network/wireshark/</guid>
      <description>&lt;p&gt;Wireshark란 오픈 소스 네트워크 프로토콜 분석기입니다.&#xA;GUI와 CLI 환경 모두에서 사용할 수 있으며, 네트워크 문제를 분석할 때 많이 사용됩니다.&#xA;플랫폼 또한 Windows, macOS, Linux 등 다양한 운영체제에서 사용할 수 있습니다.&#xA;GUI가 꽤 편하기 때문에 Windows나 macOS에서는&#xA;&lt;a href=&#34;https://www.wireshark.org/docs/man-pages/wireshark.html&#34;&gt;Wireshark&lt;/a&gt;를 사용하는 경우가 많습니다.&#xA;여기서는 CLI 환경에서도 사용할 수 있는&#xA;&lt;a href=&#34;https://www.wireshark.org/docs/man-pages/tshark.html&#34;&gt;TShark&lt;/a&gt;를 소개합니다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;설치&#34;&gt;설치&lt;/h1&gt;&#xA;&lt;p&gt;Ubuntu 22.04에서 설치하는 방법을 소개합니다.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# CLI&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo apt install tshark&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# GUI&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo apt install wireshark&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;wireshark&lt;/code&gt; 그룹 추가 후 컴퓨터를 재부팅해야 합니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>웹 페이지 응답 방법과 프레임워크</title>
      <link>https://markruler.github.io/posts/web/respond-web-page/</link>
      <pubDate>Sun, 24 Nov 2024 23:32:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/web/respond-web-page/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#cgi-common-gateway-interface&#34;&gt;CGI (Common Gateway Interface)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#ssr-server-side-rendering&#34;&gt;SSR (Server-Side Rendering)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EC%84%9C%EB%B2%84-%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%97%94%EC%A7%84&#34;&gt;서버 템플릿 엔진&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#csr-client-side-rendering&#34;&gt;CSR (Client-side Rendering)&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#spa-single-page-application&#34;&gt;SPA (Single Page Application)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#web-api-web-component&#34;&gt;Web API: Web Component&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#pwa-progressive-web-apps&#34;&gt;PWA (Progressive Web Apps)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#ssg-static-site-generation&#34;&gt;SSG (Static Site Generation)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#cms-content-management-system&#34;&gt;CMS (Content Management System)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#micro-frontend-architecture-mfa&#34;&gt;Micro Frontend Architecture (MFA)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EC%95%84%EC%9D%BC%EB%9E%9C%EB%93%9C-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90-island-architecture&#34;&gt;아일랜드 아키텍쳐 Island Architecture&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EC%9B%B9%EB%B7%B0webview---%EB%AA%A8%EB%B0%94%EC%9D%BC-%EC%95%B1%EC%97%90%EC%84%9C&#34;&gt;웹뷰(WebView) - 모바일 앱에서&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EB%8D%94-%EC%9D%BD%EC%9D%84%EA%B1%B0%EB%A6%AC&#34;&gt;더 읽을거리&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;cgi-common-gateway-interface&#34;&gt;CGI (Common Gateway Interface)&lt;/h1&gt;&#xA;&lt;p&gt;웹 서버와 외부 프로그램(애플리케이션) 간에 데이터를 주고받기 위한 인터페이스입니다.&#xA;웹 서버가 클라이언트(브라우저)로부터 요청을 받으면, CGI 프로그램을 호출하여 동적으로 콘텐츠를 생성한 뒤, 그 결과를 클라이언트에 반환합니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Facebook은 경쟁사의 암호화된 모바일 앱 트래픽을 어떻게 가로챘을까?</title>
      <link>https://markruler.github.io/posts/network/onavo-facebook-ssl-mitm-technical-analysis/</link>
      <pubDate>Thu, 12 Sep 2024 00:17:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/network/onavo-facebook-ssl-mitm-technical-analysis/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://doubleagent.net/onavo-facebook-ssl-mitm-technical-analysis/&#34;&gt;How did Facebook intercept their competitor&amp;rsquo;s encrypted mobile app traffic?&lt;/a&gt;&#xA;| &lt;a href=&#34;https://x.com/haxrob&#34;&gt;HaxRob&lt;/a&gt;, 2024년 4월 14일&lt;/li&gt;&#xA;&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;&#xA;&lt;li&gt;각주는 역주입니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;이 글은 페이스북(Facebook) 집단 소송에서 밝혀진 정보를 바탕으로 한 기술 조사입니다.&#xA;페이스북은 경쟁사의 정보를 얻기 위해 Onavo Protect 앱이 실행 중인 사용자 기기에서 암호화된 트래픽을 도청했었다는 이유로 재판이 진행 중입니다.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/network/onavo-facebook-ssl-mitm-technical-analysis/fbdark-1.webp&#34; alt=&#34;How did Facebook intercept their competitor&amp;rsquo;s encrypted mobile app traffic?&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;2024년 7월 28일 - 👋Hello &lt;a href=&#34;https://news.ycombinator.com/item?id=41090304&#34;&gt;Hackernews&lt;/a&gt;!&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;현재 메타(Meta)를 상대로 한 집단 소송이 진행 중이며,&#xA;법원 문서에 따르면* 메타가 &lt;a href=&#34;https://en.wikipedia.org/wiki/Electronic_Communications_Privacy_Act&#34;&gt;도청법(Wiretap Act)&lt;/a&gt;을 위반했을 가능성이 있다고 언급되어 있습니다.&#xA;이 글에서의 분석은 &lt;a href=&#34;https://www.documentcloud.org/documents/24520332-merged-fb&#34;&gt;법원 문서&lt;/a&gt; 내용과&#xA;안드로이드(Android) 용 Onavo Protect 앱 패키지의 아카이브된 버전을 리버스 엔지니어링한 결과를 바탕으로 하고 있습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>IP로 지리적 위치(Geolocation) 찾기</title>
      <link>https://markruler.github.io/posts/network/ip-geolocation/</link>
      <pubDate>Thu, 29 Aug 2024 22:38:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/network/ip-geolocation/</guid>
      <description>&lt;h1 id=&#34;현상&#34;&gt;현상&lt;/h1&gt;&#xA;&lt;p&gt;약 10ms 응답속도가 예상되는 API에 500~700ms의 응답속도가 발생했습니다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;원인&#34;&gt;원인&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/network/ip-geolocation/ipapi-latency.png&#34; alt=&#34;ipapi Latency&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;해당 API에서는 국가별로 다른 정책을 적용하기 위해 IP로 국가 정보&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;를 조회하는 기능이 가장 먼저 수행됩니다.&#xA;국가 정보의 출처는 ipapi라는 유료 API 서비스와 IPInfoDB라는 무료 서비스입니다.&#xA;대략적인 코드는 다음과 같습니다.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;@Cacheable(value = CacheName.IPAPI_COUNTRY_CODE, key = &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;#ipAddress&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;public&lt;/span&gt; Geolocation &lt;span style=&#34;color:#ff0&#34;&gt;findIsoCountryCode&lt;/span&gt;(&lt;span style=&#34;color:#f00&#34;&gt;final&lt;/span&gt; String ipAddress) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; (isPrivate(ipAddress)) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; Geolocation.korea();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;var&lt;/span&gt; ipapi = ipapiFeignClient.findGeolocationByIpAddress(ipAddress, IPAPI_ACCESS_KEY);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; (ipapi != &lt;span style=&#34;color:#f00&#34;&gt;null&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; Geolocation.from(ipapi);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;var&lt;/span&gt; ipInfoDB = ipInfoDBFeignClient.findGeolocationByIpAddress(ipAddress, IPINFODB_ACCESS_KEY);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; (ipInfoDB != &lt;span style=&#34;color:#f00&#34;&gt;null&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; Geolocation.from(ipInfoDB);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; Geolocation.korea();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;문제는 API가 아무리 빨라도 해당 IP Geolocation 서비스에서 응답받는 데에 평균 약 500ms 정도 소요되었다는 것입니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Traceparent 헤더로 클라이언트부터 서버까지 추적하기</title>
      <link>https://markruler.github.io/posts/web/traceparent-datadog/</link>
      <pubDate>Thu, 22 Aug 2024 18:00:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/web/traceparent-datadog/</guid>
      <description>&lt;h1 id=&#34;개요&#34;&gt;개요&lt;/h1&gt;&#xA;&lt;p&gt;모니터링 도구를 확인해보니 며칠동안 특정 기능에 에러가 발생하고 있었습니다.&#xA;해당 에러는 알람 임계점(threshold)보다 낮아서 알람이 발생하지 않았고, 이용자는 버그 리포팅을 하지 않았습니다.&#xA;에러 로그를 확인해보니 서버에서는 유효성 검사를 하지 않았고, 클라이언트 앱에서는 유효하지 않은 파라미터를 전달했습니다.&#xA;서버에서 유효성 검사를 추가할 수 있겠지만, 클라이언트 앱에서의 잘못된 요청(bug)은 원인을 알 수 없었습니다.&#xA;클라이언트 이벤트는 연결되어 있지 않았기 때문입니다.&lt;/p&gt;&#xA;&lt;p&gt;또 다른 문제가 있었습니다.&#xA;서버에서는 정상적인 상태 코드와 함께 100ms 정도의 속도로 응답했지만&#xA;클라이언트에서는 4초 이상의 지연이 발생하거나 아래와 같은 Akamai 에러 페이지가 응답되었습니다.&#xA;그리고 모든 요청이 아닌 전체 요청의 5% 정도에서만 발생하고 있었습니다.&#xA;하지만 국가, Edge IP, User Agent, 요청 URL 등을 확인해봐도 특정 패턴을 보이는 것이 없어서 원인을 알 수 없었습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>APM만큼 중요한 네트워크 모니터링</title>
      <link>https://markruler.github.io/posts/web/apm-network-device-troubleshooting-mistakes/</link>
      <pubDate>Thu, 25 Jul 2024 01:22:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/web/apm-network-device-troubleshooting-mistakes/</guid>
      <description>&lt;p&gt;APM은 애플리케이션 성능 모니터링(Application Performance Monitoring)입니다.&#xA;저희 팀이 사용하는 모니터링 서비스 데이터독(Datadog)은 APM에서 많은 것을 확인할 수 있습니다.&#xA;(인프라, 로그, 호스트의 프로세스, JVM 런타임 메트릭, 각 리소스별 레이턴시 등등)&lt;/p&gt;&#xA;&lt;h1 id=&#34;문제&#34;&gt;문제&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/apm-network-device-troubleshooting-mistakes/first.png&#34; alt=&#34;First&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;어느날 체감이 될 정도로 서비스의 레이턴시가 높아지고, 정각마다 스파이크 발생했습니다.&#xA;또한 서비스 전체에 영향이 있었습니다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;분석-쉽게-간과했던-문제&#34;&gt;분석: 쉽게 간과했던 문제&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://markruler.github.io/posts/db/oracle-dbms-session-diagnosis/&#34;&gt;Oracle Session 히스토리&lt;/a&gt;를 남겨서 확인했을 때&#xA;DB에 부하를 일으키면서 반복적으로 보이는 느린 쿼리가 없었습니다.&#xA;DB 문제는 아니었습니다.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/apm-network-device-troubleshooting-mistakes/oracle-session.webp&#34; alt=&#34;Oracle Session 히스토리&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>네트워크 장비 모니터링을 위한 SNMP</title>
      <link>https://markruler.github.io/posts/network/snmp/</link>
      <pubDate>Tue, 23 Jul 2024 19:08:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/network/snmp/</guid>
      <description>&lt;h1 id=&#34;개요&#34;&gt;개요&lt;/h1&gt;&#xA;&lt;p&gt;주로 네트워크 장비의 Metric을 확인하는 모니터링 용도로 사용하지만, SNMP를 지원하는 컴퓨팅 머신이라면 모두 활용할 수 있습니다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;전제-조건&#34;&gt;전제 조건&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IP 네트워크 환경이 있다.&lt;/li&gt;&#xA;&lt;li&gt;관리용 서버(SNMP 서버)가 있다.&lt;/li&gt;&#xA;&lt;li&gt;SNMP 프로토콜을 지원하는 기기다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;구성-요소&#34;&gt;구성 요소&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;매니저 (SNMP 서버)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;네트워크 감시 장치(서버)에 설치해서 사용하는 소프트웨어&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;에이전트 (네트워크 기기/서버)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;네트워크 기기나 서버가 가진 기기의 상태 정보를 통보하는 기능&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SNMP 프로토콜 (TCP/IP)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;UDP 패킷에 실어서 주고받으며, 포트 번호는 161(SNMP), 162(TRAP)를 사용합니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;MIB (Management Information Base)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SNMP로 관리되는 네트워크 기기나 서버가 자신의 상태를 외부에 알리기 위해서 공개하는 관리 정보.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc1156&#34;&gt;RFC 1156&lt;/a&gt;으로 규정된 MIB1,&#xA;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc1213&#34;&gt;RFC 1213&lt;/a&gt;으로 규정된 MIB2&lt;/li&gt;&#xA;&lt;li&gt;MIB를 지원하는 기기에 일반적으로 포함된 표준 MIB와 기기 제조사마다 사양이 다른 사설(Private) MIB가 있습니다.&lt;/li&gt;&#xA;&lt;li&gt;MIB의 구조는 트리 구조이며, 트리 구조의 마디(노드)는 번호를 붙여서 나타냅니다. 이 번호열을 OID(Object ID)라고 합니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;매니저-에이전트-역할&#34;&gt;매니저-에이전트 역할&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;정보의 요청과 응답&#xA;&lt;ul&gt;&#xA;&lt;li&gt;매니저가 에이전트에게 대상 기기의 정보를 요청 → 에이전트는 정보를 매니저에게 응답&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;설정의 요청과 응답&#xA;&lt;ul&gt;&#xA;&lt;li&gt;매니저가 에이전트에게 대상 기기의 설정 변경을 요청 → 에이전트는 설정을 변경하며 그 결과를 매니저에게 응답&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;상태 변화의 통보&#xA;&lt;ul&gt;&#xA;&lt;li&gt;에이전트가 매니저에게 대상 기기의 상태 변화를 통보&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;매니저-에이전트-통신-방식&#34;&gt;매니저-에이전트 통신 방식&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;폴링 (Polling)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;매니저가 정기적으로 에이전트로부터 관리 정보를 추출합니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;트랩 (Trap)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;에이전트인 라우터나 스위치가 자신의 상태에 어떤 변화가 발생했을 때(장애 발생 등) 자발적으로 매니저인 SNMP 서버에게 정보를 통보합니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;커뮤니티-이름&#34;&gt;커뮤니티 이름&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;매니저와 에이전트는 커뮤니티 이름으로 그룹화합니다.&lt;/li&gt;&#xA;&lt;li&gt;매니저와 에이전트는 커뮤니티 이름이 같을 때만 통신합니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;버전별-차이&#34;&gt;버전별 차이&lt;/h1&gt;&#xA;&lt;h2 id=&#34;v1&#34;&gt;v1&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;커뮤니티 이름이 포함된 패킷을 평문으로 전달합니다.&lt;/li&gt;&#xA;&lt;li&gt;기본적인 관리 정보 베이스(MIB)와 트랩 메시지를 사용합니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;v2&#34;&gt;v2&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;커뮤니티 이름이 포함된 패킷을 암호화해서 전달합니다.&lt;/li&gt;&#xA;&lt;li&gt;추가된 PDU 타입(예: &lt;a href=&#34;http://www.ktword.co.kr/test/view/view.php?m_temp1=5270&#34;&gt;GetBulkRequest&lt;/a&gt;)을 통해 대량의 데이터를 한 번에 전송할 수 있습니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;v2c&#34;&gt;v2c&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;커뮤니티 값을 암호화하여 전달하는 것이 복잡해서 v1처럼 평문으로 전달할 수 있도록 원복되었습니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;v3&#34;&gt;v3&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;(username, password) 인증 기능이 추가되었습니다.&lt;/li&gt;&#xA;&lt;li&gt;이 외 다양한 보안 기능 추가되었습니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;관련-명령어-도구&#34;&gt;관련 명령어 도구&lt;/h1&gt;&#xA;&lt;h2 id=&#34;snmpget&#34;&gt;snmpget&lt;/h2&gt;&#xA;&lt;p&gt;정확한 OID를 입력해야 합니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>일상에서의 SSH</title>
      <link>https://markruler.github.io/posts/network/ssh/</link>
      <pubDate>Wed, 17 Jul 2024 22:40:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/network/ssh/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#ssh-key-%EC%83%9D%EC%84%B1&#34;&gt;SSH key 생성&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#ssh-server&#34;&gt;SSH Server&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#authoized_keys&#34;&gt;authoized_keys&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EC%A3%BC%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-server-%EC%84%A4%EC%A0%95&#34;&gt;주로 사용하는 Server 설정&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#ssh-client&#34;&gt;SSH Client&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-%EC%9A%B0%EC%84%A0-%EC%88%9C%EC%9C%84&#34;&gt;설정 파일 우선 순위&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#known_hosts&#34;&gt;known_hosts&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EC%A3%BC%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-host-%EC%84%A4%EC%A0%95&#34;&gt;주로 사용하는 Host 설정&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#git&#34;&gt;Git&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#local-forward&#34;&gt;Local Forward&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#password-%EC%9E%85%EB%A0%A5-%EC%97%86%EC%9D%B4-ssh-key%EB%A1%9C-client%EC%97%90%EC%84%9C-server%EB%A1%9C-%EC%A0%91%EC%86%8D%ED%95%98%EA%B8%B0&#34;&gt;Password 입력 없이 SSH Key로 Client에서 Server로 접속하기&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EC%B0%B8%EC%A1%B0&#34;&gt;참조&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;업무에서 자주 사용하는 SSH 설정을 정리합니다.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;ssh-key-생성&#34;&gt;SSH key 생성&lt;/h1&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# RSA&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ssh-keygen -t rsa -b &lt;span style=&#34;color:#f60&#34;&gt;4096&lt;/span&gt; -C &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# ED25519&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ssh-keygen -t ed25519 -f &lt;span style=&#34;color:#eedd82&#34;&gt;$HOME&lt;/span&gt;/.ssh/my-ed25519 -C &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;comment&amp;#34;&lt;/span&gt; -N &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;ssh-server&#34;&gt;SSH Server&lt;/h1&gt;&#xA;&lt;p&gt;SSH 데몬 설정 파일은 &lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;이다.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo apt install openssh-server&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;systemctl status ssh&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;authoized_keys&#34;&gt;authoized_keys&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;역할: SSH 서버가 접속을 허용할 클라이언트의 공개키를 저장하는 파일입니다. (사용자 인증 방식)&lt;/li&gt;&#xA;&lt;li&gt;위치: 보통 사용자의 홈 디렉토리 아래의 &lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt;에 위치합니다.&lt;/li&gt;&#xA;&lt;li&gt;내용: 클라이언트의 공개 키가 저장됩니다.&#xA;서버는 클라이언트의 접속 시도 시,&#xA;이 파일에 저장된 공개 키와 클라이언트가 제공한 키를 비교하여 인증을 수행합니다.&lt;/li&gt;&#xA;&lt;li&gt;보안: 비밀번호 대신 공개 키를 사용하여 인증하기 때문에,&#xA;공개 키 인증 방식이 비밀번호 인증보다 더 안전합니다.&#xA;특히, 비밀번호를 통한 무차별 대입 공격에 대한 저항력이 높습니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;SSH 데몬(sshd) 설치 혹은 실행 시 &lt;code&gt;/etc/ssh&lt;/code&gt; 디렉토리에 비대칭키 쌍이 생성 및 저장됩니다.&#xA;만약 설치 시 생성되지 않았다면, 맨 처음 실행할 때 생성됩니다.&#xA;&lt;code&gt;ssh-keygen&lt;/code&gt; 명령어를 사용해서 수동으로 생성 및 교체할 수도 있습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>서버 to 서버 요청 시 발생한 DNS 레이턴시</title>
      <link>https://markruler.github.io/posts/network/server-to-server-dns/</link>
      <pubDate>Thu, 13 Jun 2024 17:40:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/network/server-to-server-dns/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EB%B0%B0%EA%B2%BD&#34;&gt;배경&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EB%B6%84%EC%84%9D-dig-%EC%9C%BC%EB%A1%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8&#34;&gt;분석: dig 으로 테스트&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#nameserver-8888-%EB%A1%9C-%EC%A7%80%EC%A0%95&#34;&gt;nameserver 8.8.8.8 로 지정&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#nameserver%EB%8A%94-resolvconf-%EC%84%A4%EC%A0%95%EC%9D%84-%EB%94%B0%EB%A5%B8%EB%8B%A4&#34;&gt;nameserver는 &lt;code&gt;resolv.conf&lt;/code&gt; 설정을 따른다&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EB%B9%84%EA%B5%90&#34;&gt;비교&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%ED%95%B4%EA%B2%B0-%ED%98%B8%EC%8A%A4%ED%8A%B8-%ED%8C%8C%EC%9D%BC-%EC%88%98%EC%A0%95&#34;&gt;해결: 호스트 파일 수정&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;배경&#34;&gt;배경&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;약 200ms 응답 속도가 예상되는 API가 불규칙적으로 2s까지 스파이크가 발생했습니다.&#xA;&lt;ul&gt;&#xA;&lt;li&gt;해당 API에는 서버 to 서버로 요청하는 기능이 여러 개 포함되어 있습니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;환경: On-Premise(IDC) 환경에 애플리케이션 서버는 컨테이너가 아닌 스탠드얼론 호스트로 실행됩니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;분석-dig-으로-테스트&#34;&gt;분석: dig 으로 테스트&lt;/h1&gt;&#xA;&lt;h2 id=&#34;nameserver-8888-로-지정&#34;&gt;nameserver 8.8.8.8 로 지정&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dig @8.8.8.8 api.example.com&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;첫번째 요청 292 msec&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;;; Query time: &lt;span style=&#34;color:#f60&#34;&gt;292&lt;/span&gt; msec&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;;; SERVER: 8.8.8.8#53(8.8.8.8) (UDP)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;;; WHEN: Tue Jun &lt;span style=&#34;color:#f60&#34;&gt;11&lt;/span&gt; 11:00:54 KST &lt;span style=&#34;color:#f60&#34;&gt;2024&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;;; MSG SIZE  rcvd: &lt;span style=&#34;color:#f60&#34;&gt;154&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2번째 요청 36 msec&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
