<?xml-stylesheet href="/rss.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>임창수 블로그</title>
    <link>https://markruler.github.io/</link>
    <description>Recent content on 임창수 블로그</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <managingEditor>imcxsu@gmail.com (Im Changsu)</managingEditor>
    <webMaster>imcxsu@gmail.com (Im Changsu)</webMaster>
    <copyright>Im Changsu 2020 - 2024</copyright>
    <lastBuildDate>Wed, 31 Jul 2024 20:40:00 +0900</lastBuildDate>
    
        <atom:link href="https://markruler.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>&#34;NFV 아키텍처&#34; 이해를 위한 치트 시트</title>
        <link>https://markruler.github.io/posts/nfv/cheat-sheet-understanding-nfv-architecture/</link>
        <pubDate>Tue, 22 Sep 2020 21:58:08 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/nfv/cheat-sheet-understanding-nfv-architecture/</guid>
        <description>임창수 블로그 https://markruler.github.io/posts/nfv/cheat-sheet-understanding-nfv-architecture/ -&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.telcocloudbridge.com/blog/a-cheat-sheet-for-understanding-nfv-architecture/&#34;&gt;Faisal Khan의 A Cheat Sheet for Understanding &amp;ldquo;NFV Architecture&amp;rdquo;&lt;/a&gt;를 번역한 글입니다.&lt;/li&gt;
&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;시간이 없으신가요?&lt;/p&gt;
&lt;p&gt;쉽게 이해할 수 있는 NFV 용어/아키텍처에 대한 빠른 업데이트가 필요하신가요?&lt;/p&gt;
&lt;p&gt;그렇다면 NFV 아키텍처를 시작하는 데 필요한 모든 정보를 얻을 수 있는 아래 7가지 주요 블록을 보세요. 블록 번호 및 정의를 따라가세요.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/nfv/nfv-architecture.png&#34; alt=&#34;nfv-architecture&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-vnf-virtual-network-function&#34;&gt;1. VNF (Virtual Network Function)&lt;/h2&gt;
&lt;p&gt;VNF는 가상화된 네트워크 요소로 NFV 아키텍처의 기본 블록입니다.
예를 들어 라우터를 가상화하면 라우터 VNF라고 부르고, 다른 예는 기지국(base station) VNF도 있습니다.
네트워크 요소의 한 가지 하위 기능(sub-function)만 가상화해도 VNF라고 합니다.
예를 들어 라우터의 다양한 하위 기능은 가상 라우터로서 함께 작동하는 별도의 VNF가 될 수 있다.&lt;/p&gt;
&lt;p&gt;VNF의 다른 예로는 방화벽(firewall), IPS, GGSN, SGSN, RNC, EPC 등이 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;2-em-element-management&#34;&gt;2. EM (Element Management)&lt;/h2&gt;
&lt;p&gt;EM은 VNF의 요소 관리 시스템(EMS)입니다.
이것은 VNF(즉, FCAPS: Fault, Configuration, Accounting, Perfomance, Security) 기능을 관리합니다.
독점적 인터페이스를 통해 VNF를 관리할 수도 있습니다.
VNF당 1개의 EMS가 있을 수도 있고 하나의 EMS가 여러 개의 VNF를 관리할 수도 있습니다.
EMS 자체가 VNF일 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;3-vnf-manager&#34;&gt;3. VNF Manager&lt;/h2&gt;
&lt;p&gt;VNF 매니저는 하나 또는 여러 VNF 인스턴스의 라이프사이클을 관리합니다.
라이프사이클 관리란 VNF를 할당, 유지, 해제하는 것을 말합니다.&lt;/p&gt;
&lt;p&gt;또한 VNFM(VNF 매니저)은 VNF의 가상 부분에 대해 FCAPS를 수행한다.&lt;/p&gt;
&lt;p&gt;EM 및 VNFM의 차이에 유의해야 합니다.
EM은 기능 요소를 관리하는 반면, VNFM은 가상 요소를 관리합니다.
다음 예시로 명확하게 설명하겠습니다. 모바일 코어가 가상화된 경우,
EM은 기능 부분(예: 모바일 신호 전달)을 관리하고,
VNFM은 가상 부분(예: 자체 VNF 생성)을 관리합니다.&lt;/p&gt;
&lt;h2 id=&#34;4-nfvi-network-function-virtualization-infrastructure&#34;&gt;4. NFVI (Network Function Virtualization Infrastructure)&lt;/h2&gt;
&lt;p&gt;NFVI는 VNF가 실행되는 환경입니다.
여기에는 아래에 설명된 물리 자원, 가상 자원 및 가상화 계층이 포함된다.&lt;/p&gt;
&lt;h3 id=&#34;41-compute-memory-and-networking-resources&#34;&gt;4.1 Compute, Memory and Networking Resources&lt;/h3&gt;
&lt;p&gt;NFVI의 물리적인 부분입니다.
가상 자원은 이러한 물리 자원에 의해 인스턴스화 됩니다.
모든 물리 스위치 또는 물리 서버, 물리 스토리지 서버는 이 범주에 포함됩니다.&lt;/p&gt;
&lt;h3 id=&#34;42-virtual-compute-virtual-memory-and-virtual-networking-resources&#34;&gt;4.2 Virtual Compute, Virtual Memory and Virtual Networking Resources&lt;/h3&gt;
&lt;p&gt;NFVI의 가상 부분입니다.
물리 자원은 궁극적으로 VNF가 활용하는 가상 자원으로 추상화됩니다.&lt;/p&gt;
&lt;h3 id=&#34;43-virtualization-layer&#34;&gt;4.3 Virtualization Layer&lt;/h3&gt;
&lt;p&gt;가상화 계층은 물리 자원을 가상 자원으로 추상화하는 역할을 담당합니다. 일반적인 산업 용어로 &lt;code&gt;하이퍼바이저&lt;/code&gt;라고 합니다.
이 계층은 소프트웨어가 하드웨어로부터 독립적으로 실행될 수 있도록 합니다.&lt;/p&gt;
&lt;p&gt;가상화 계층이 없다고 가정할 때, VNF가 물리 자원에서 직접 실행될 수 있다고 생각할 수 있습니다.
그러나 정의상 VNF라고 부를 수 없으며 NFV 아키텍처라고도 할 수 없습니다.
적절하게 PNF(물리 네트워크 기능)라고 불릴 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;5-vim-virtualized-infrastructure-manager&#34;&gt;5. VIM (Virtualized Infrastructure Manager)&lt;/h2&gt;
&lt;p&gt;NFVI를 위한 관리 시스템입니다.
한 사업자의 인프라 도메인 내에서 NFVI 컴퓨팅, 네트워크 및 스토리지 리소스를 제어하고 관리합니다.
성능 측정 및 이벤트 수집도 담당합니다.&lt;/p&gt;
&lt;h2 id=&#34;6-nfv-orchestrator&#34;&gt;6. NFV Orchestrator&lt;/h2&gt;
&lt;p&gt;VNF의 네트워크 서비스를 직접 생성, 유지, 해제합니다.
VNF가 여러 개 있는 경우 여러 VNF 종단 간(end-to-end) 서비스를 생성할 수 있도록 합니다.&lt;/p&gt;
&lt;p&gt;NFVI 자원의 전역 자원(global resource)도 관리합니다.
예를 들어 네트워크에 있는 여러 VIM 간에 컴퓨팅, 스토리지 및 네트워킹 자원 등의 NFVI 자원을 관리합니다.&lt;/p&gt;
&lt;p&gt;오케스트레이터는 VNF와 직접 통신하지 않고 VNFM과 VIM을 통해 기능을 수행합니다.&lt;/p&gt;
&lt;p&gt;예시:
종단 간 서비스를 생성하기 위해 체인을 연결해야 하는 VNF가 여러 개 있다고 가정해 봅시다.
이러한 사례의 한 예는 가상 기지국과 가상 EPC입니다. 이것들은 동일하거나 다른 벤더일 수 있습니다.
양쪽의 VNF를 모두 사용하여 종단 간 서비스를 생성해야 할 것입니다.
이를 위해서는 서비스 오케스트레이터가 두 VNF와 통신하여 종단 간 서비스를 생성해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;7-ossbssoperation-support-systembusiness-support-system&#34;&gt;7. OSS/BSS(Operation Support System/Business Support System)&lt;/h2&gt;
&lt;p&gt;OSS/BSS는 사업자의 OSS/BSS를 말한다.
OSS는 네트워크, 장애, 구성, 서비스를 관리합니다.
BSS는 고객, 제품, 주문 등을 관리합니다.&lt;/p&gt;
&lt;p&gt;NFV 아키텍처에서 사업자의 현재 BSS/OSS는 표준 인터페이스를 통해 NFV MANO (Management and Orchestration)와 통합할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이게 전부입니다!&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.telcocloudbridge.com/blog/a-cheat-sheet-for-understanding-nfv-architecture/&#34;&gt;원문 링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;사용 사례 및 SDN과의 관계를 포함한 NFV에 대한 자세한 내용을 보려면
헤더 섹션의 링크에서 NFV 마인드맵을 다운로드하세요.
개념을 더 쉽게 따라가기 위해 레퍼런스로 사용할 수 있도록 NFV 마인드 맵을 만들었습니다.&lt;/p&gt;
&lt;p&gt;코멘트를 남겨서 NFV 아키텍처용 &lt;code&gt;치트 시트&lt;/code&gt;에 대해 어떻게 생각하는지 알려주세요.&lt;/p&gt;
- https://markruler.github.io/posts/nfv/cheat-sheet-understanding-nfv-architecture/ - Im Changsu 2020 - 2024</description>
        </item>
    
    
    
        <item>
        <title>쿠버네티스 API 접근 제어</title>
        <link>https://markruler.github.io/posts/kubernetes/controlling-access-api/</link>
        <pubDate>Thu, 17 Sep 2020 06:58:08 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/kubernetes/controlling-access-api/</guid>
        <description>임창수 블로그 https://markruler.github.io/posts/kubernetes/controlling-access-api/ -&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/controlling-access/&#34;&gt;쿠버네티스 공식 문서&lt;/a&gt;를 번역했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;이 페이지는 쿠버네티스 API에 대한 접근 제어의 개요를 제공한다.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;사용자는&lt;code&gt;kubectl&lt;/code&gt;, 클라이언트 라이브러리
또는 REST 요청을 통해
&lt;a href=&#34;https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/&#34;&gt;API에 접근한다&lt;/a&gt;.
사용자와 쿠버네티스 서비스 어카운트 모두 API에 접근할 수 있다.
요청이 API에 도달하면,
다음 다이어그램에 설명된 몇 가지 단계를 거친다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/kubernetes/access-control-overview.svg&#34; alt=&#34;Diagram of request handling steps for Kubernetes API request&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;전송-보안&#34;&gt;전송 보안&lt;/h2&gt;
&lt;p&gt;일반적인 쿠버네티스 클러스터에서 API는 443번 포트에서 서비스한다.
API 서버는 인증서를 제시한다.
이 인증서는 종종 자체 서명되기 때문에 일반적으로 사용자 머신의 &lt;code&gt;$USER/.kube/config&lt;/code&gt;은
API 서버의 인증서에 대한 루트 인증서를 포함하며,
시스템 기본 루트 인증서 대신 사용된다.
&lt;code&gt;kube-up.sh&lt;/code&gt;을 사용하여 클러스터를 직접 생성할 때
이 인증서는 일반적으로 &lt;code&gt;$USER/.kube/config&lt;/code&gt;에 자동으로 기록된다.
클러스터에 여러 명의 사용자가 있는 경우, 작성자는 인증서를 다른 사용자와 공유해야 한다.&lt;/p&gt;
&lt;h2 id=&#34;인증&#34;&gt;인증&lt;/h2&gt;
&lt;p&gt;TLS가 설정되면 HTTP 요청이 인증 단계로 넘어간다.
이는 다이어그램에 &lt;strong&gt;1&lt;/strong&gt;단계로 표시되어 있다.
클러스터 생성 스크립트 또는 클러스터 관리자는
API 서버가 하나 이상의 인증기 모듈을 실행하도록 구성하십시오.
인증기는 &lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/authentication/&#34;&gt;여기&lt;/a&gt;에서 더 자세히 서술한다.&lt;/p&gt;
&lt;p&gt;인증 단계로 들어가는 것은 온전한 HTTP 요청이지만
일반적으로 헤더 그리고/또는 클라이언트 인증서만 검사한다.&lt;/p&gt;
&lt;p&gt;인증 모듈은 클라이언트 인증서, 암호 및 일반 토큰, 부트스트랩 토큰,
JWT 토큰(서비스 어카운트에 사용됨)을 포함한다.&lt;/p&gt;
&lt;p&gt;여러 개의 인증 모듈을 지정할 수 있으며,
이 경우 하나의 인증 모듈이 성공할 때까지 각 모듈을 순차적으로 시도한다.&lt;/p&gt;
&lt;p&gt;GCE에서는 클라이언트 인증서, 암호, 일반 토큰 및 JWT 토큰이 모두 사용 가능하다.&lt;/p&gt;
&lt;p&gt;요청을 인증할 수 없는 경우 HTTP 상태 코드 401과 함께 거부된다.
이 외에는 사용자가 특정 &lt;code&gt;username&lt;/code&gt;으로 인증되며,
이 username은 다음 단계에서 사용자의 결정에 사용할 수 있다.
일부 인증기는 사용자 그룹 관리 기능을 제공하는 반면,
이외의 인증기는 그렇지 않다.&lt;/p&gt;
&lt;p&gt;쿠버네티스는 접근 제어 결정과 요청 기록 시 &lt;code&gt;usernames&lt;/code&gt;를 사용하지만,
&lt;code&gt;user&lt;/code&gt; 오브젝트를 가지고 있지 않고 usernames 나 기타 사용자 정보를
오브젝트 저장소에 저장하지도 않는다.&lt;/p&gt;
&lt;h2 id=&#34;인가&#34;&gt;인가&lt;/h2&gt;
&lt;p&gt;특정 사용자로부터 온 요청이 인증된 후에는 인가되어야 한다. 이는 다이어그램에 &lt;strong&gt;2&lt;/strong&gt;단계로 표시되어 있다.&lt;/p&gt;
&lt;p&gt;요청은 요청자의 username, 요청된 작업 및 해당 작업이 영향을 주는 오브젝트를 포함해야 한다. 기존 정책이 요청된 작업을 완료할 수 있는 권한이 해당 사용자에게 있다고 선언하는 경우 요청이 인가된다.&lt;/p&gt;
&lt;p&gt;예를 들어 Bob이 아래와 같은 정책을 가지고 있다면 &lt;code&gt;projectCaribou&lt;/code&gt; 네임스페이스에서만 파드를 읽을 수 있다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
    &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;abac.authorization.kubernetes.io/v1beta1&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;kind&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;Policy&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;spec&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;user&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;bob&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;namespace&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;projectCaribou&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;resource&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;pods&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;readonly&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ff79c6&#34;&gt;true&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Bob이 다음과 같은 요청을 하면 &amp;lsquo;projectCaribou&amp;rsquo; 네임스페이스의 오브젝트를 읽을 수 있기 때문에 요청이 인가된다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
  &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;authorization.k8s.io/v1beta1&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;kind&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;SubjectAccessReview&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;spec&amp;#34;&lt;/span&gt;: {
    &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;resourceAttributes&amp;#34;&lt;/span&gt;: {
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;namespace&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;projectCaribou&amp;#34;&lt;/span&gt;,
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;verb&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;get&amp;#34;&lt;/span&gt;,
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;group&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;unicorn.example.org&amp;#34;&lt;/span&gt;,
      &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;#34;resource&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;pods&amp;#34;&lt;/span&gt;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Bob이 &lt;code&gt;projectCaribou&lt;/code&gt; 네임스페이스에 있는 오브젝트에 쓰기(&lt;code&gt;create&lt;/code&gt; 또는 &lt;code&gt;update&lt;/code&gt;) 요청을 하면 그의 인가는 거부된다. 만약 Bob이 &lt;code&gt;projectFish&lt;/code&gt;처럼 다른 네임스페이스의 오브젝트 읽기(&lt;code&gt;get&lt;/code&gt;) 요청을 하면 그의 인가는 거부된다.&lt;/p&gt;
&lt;p&gt;쿠버네티스 인가는 공통 REST 속성을 사용하여 기존 조직 전체 또는 클라우드 제공자 전체의 접근 제어 시스템과 상호 작용할 것을 요구한다. 이러한 제어 시스템은 쿠버네티스 API 이외의 다른 API와 상호작용할 수 있으므로 REST 형식을 사용하는 것이 중요하다.&lt;/p&gt;
&lt;p&gt;쿠버네티스는 ABAC 모드, RBAC 모드, 웹훅 모드와 같은 여러 개의 인가 모듈을 지원한다. 관리자가 클러스터를 생성할 때 API 서버에서 사용해야 하는 인가 모듈을 구성했다. 인가 모듈이 2개 이상 구성되면 쿠버네티스가 각 모듈을 확인하고, 어느 모듈이 요청을 승인하면 요청을 진행할 수 있다. 모든 모듈이 요청을 거부하면 요청이 거부된다(HTTP 상태 코드 403).&lt;/p&gt;
&lt;p&gt;인가 모듈을 사용한 정책 생성을 포함해 쿠버네티스 인가에 대해 더 배우려면 &lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz//authorization/&#34;&gt;인가 개요&lt;/a&gt;를 참조하십시오.&lt;/p&gt;
&lt;h2 id=&#34;승인-제어&#34;&gt;승인 제어&lt;/h2&gt;
&lt;p&gt;승인 제어 모듈은 요청을 수정하거나 거부할 수 있는 소프트웨어 모듈이다.
인가 모듈에서 사용할 수 있는 속성 외에도
승인 제어 모듈은 생성되거나 수정된 오브젝트 내용에 접근할 수 있다.&lt;/p&gt;
&lt;p&gt;어드미션 컨트롤러는 오브젝트를 생성, 수정, 삭제 또는 (프록시에) 연결하는 요청에 따라 작동한다.
어드미션 컨트롤러는 단순히 객체를 읽는 요청에 작동하지 않는다.
여러 개의 어드미션 컨트롤러가 구성되면 순서대로 호출된다.&lt;/p&gt;
&lt;p&gt;이는 다이어그램에 &lt;strong&gt;3&lt;/strong&gt;단계로 표시되어 있다.&lt;/p&gt;
&lt;p&gt;인증 및 인가 모듈과 달리,
승인 제어 모듈이 거부되면 요청은 즉시 거부된다.&lt;/p&gt;
&lt;p&gt;승인 제어 모듈은 오브젝트를 거부하는 것 외에도
필드의 복잡한 기본값을 설정할 수 있다.&lt;/p&gt;
&lt;p&gt;사용 가능한 승인 제어 모듈은 &lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/&#34;&gt;여기&lt;/a&gt;에 서술되어 있다.&lt;/p&gt;
&lt;p&gt;요청이 모든 승인 제어 모듈을 통과하면 유효성 검사 루틴을 사용하여 해당 API 오브젝트를 검증한 후
오브젝트 저장소에 기록(&lt;strong&gt;4단계&lt;/strong&gt;)된다.&lt;/p&gt;
&lt;h2 id=&#34;api-서버-포트와-ip&#34;&gt;API 서버 포트와 IP&lt;/h2&gt;
&lt;p&gt;이전의 논의는 (일반적인 경우) API 서버의 보안 포트로 전송되는 요청에 적용된다.
API 서버는 실제로 다음과 같이 2개의 포트에서 서비스할 수 있다.&lt;/p&gt;
&lt;p&gt;기본적으로 쿠버네티스 API 서버는 2개의 포트에서 HTTP 서비스를 한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;로컬호스트 포트&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테스트 및 부트스트랩을 하기 위한 것이며 마스터 노드의 다른 구성요소
(스케줄러, 컨트롤러 매니저)가 API와 통신하기 위한 것이다.&lt;/li&gt;
&lt;li&gt;TLS가 없다.&lt;/li&gt;
&lt;li&gt;기본 포트는 8080이며, &lt;code&gt;--insecure-port&lt;/code&gt; 플래그를 사용하여 변경한다.&lt;/li&gt;
&lt;li&gt;기본 IP는 로컬호스트(localhost)이며, &lt;code&gt;--insecure-bind-address&lt;/code&gt; 플래그를 사용하여 변경한다.&lt;/li&gt;
&lt;li&gt;요청이 인증 및 인가 모듈을 &lt;strong&gt;우회한다&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;요청이 승인 제어 모듈(들)에 의해 처리된다.&lt;/li&gt;
&lt;li&gt;호스트 접근 요구로부터 보호를 받는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;보안 포트&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가능하면 언제나 사용하십시오.&lt;/li&gt;
&lt;li&gt;TLS를 사용하십시오. &lt;code&gt;--tls-cert-file&lt;/code&gt; 플래그로 인증서를 지정하고 &lt;code&gt;--tls-private-key-file&lt;/code&gt; 플래그로 키를 지정하십시오.&lt;/li&gt;
&lt;li&gt;기본 포트는 6443이며, &lt;code&gt;--secure-port&lt;/code&gt; 플래그를 사용하여 변경한다.&lt;/li&gt;
&lt;li&gt;기본 IP는 로컬호스트가 아닌 첫 번째 네트워크 인터페이스이며, &lt;code&gt;--bind-address&lt;/code&gt; 플래그를 사용하여 변경한다.&lt;/li&gt;
&lt;li&gt;요청이 인증 및 인가 모듈에 의해 처리된다.&lt;/li&gt;
&lt;li&gt;요청이 승인 제어 모듈(들)에 의해 처리된다.&lt;/li&gt;
&lt;li&gt;인증 및 인가 모듈을 실행한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GCE(구글 컴퓨트 엔진) 및 다른 클라우드 제공자에서 &lt;code&gt;kube-up.sh&lt;/code&gt;로 클러스터를 생성하면
API 서버는 포트 443에서 서비스한다.
GCE에서는 외부 HTTPS가 API에 접근할 수 있도록 프로젝트에서 방화벽 규칙이 구성된다.
이외에 클러스터 설정 방법은 다양하다.&lt;/p&gt;
- https://markruler.github.io/posts/kubernetes/controlling-access-api/ - Im Changsu 2020 - 2024</description>
        </item>
    
    
    
        <item>
        <title>MEC 아키텍처 초심자 가이드</title>
        <link>https://markruler.github.io/posts/mec/beginners-guide-to-mec-architecture/</link>
        <pubDate>Sun, 13 Sep 2020 20:58:08 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/mec/beginners-guide-to-mec-architecture/</guid>
        <description>임창수 블로그 https://markruler.github.io/posts/mec/beginners-guide-to-mec-architecture/ -&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Faisal Khan의 &lt;a href=&#34;https://www.telcocloudbridge.com/blog/beginners-guide-to-mec-architecture-multi-access-edge-computing/&#34;&gt;Beginners Guide to MEC Architecture (Multi-access Edge Computing)&lt;/a&gt;을 번역한 글입니다.&lt;/li&gt;
&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;
&lt;li&gt;처음에는 MEC가 &lt;a href=&#34;https://www.etsi.org/deliver/etsi_gs/MEC/001_099/003/01.01.01_60/gs_MEC003v010101p.pdf&#34;&gt;Mobile Edge Computing&lt;/a&gt; 의 줄임말이었지만 현재는 &lt;a href=&#34;https://www.etsi.org/deliver/etsi_gs/MEC/001_099/003/02.01.01_60/gs_MEC003v020101p.pdf&#34;&gt;Multi-access Edge Computing&lt;/a&gt; 입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;MEC 아키텍처 가이드에 오신 것을 환영합니다!&lt;/p&gt;
&lt;p&gt;MEC는 5G의 저지연(low-latency) 서비스를 활용하려는 모바일 사업자들에 의해 새로운 투자 물결을 가져올 것입니다.
이는 소비자와 더 가까운 곳(무선 기지국)에서 서비스를 운영하겠다는 것을 의미합니다.&lt;/p&gt;
&lt;p&gt;MEC는 서비스 사업자들에게 새로운 서비스 분야와 수익 창출의 수단입니다.
예를 들어 더 빠른 게임 경험, 증강/가상 현실, 커넥티드 카 등이 있습니다.&lt;/p&gt;
&lt;p&gt;Azure, AWS, Google과 같은 웹 스케일러(web scaler)도 대세에 뛰어들어
MEC 플랫폼을 구축하기 시작한 이유는 그만큼 잠재력을 가지고 있기 때문입니다.&lt;/p&gt;
&lt;p&gt;본 가이드는 MEC 표준 기관인 ETSI 모델에 기반을 둡니다.
MEC 아키텍처를 맨 처음부터 구축하며 사전 지식을 요구하지 않습니다.&lt;/p&gt;
&lt;p&gt;MEC 아키텍처를 이해하면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서비스 사업자는 표준 기반 MEC 플랫폼/아키텍처로 전환하는 방법을 알게 됩니다.&lt;/li&gt;
&lt;li&gt;벤더와 개발자는 솔루션이 ETSI MEC 모델에 얼마나 부합하는지 고객에게 설명할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;더 이상 고민하지 말고 바로 시작합시다!&lt;/p&gt;
&lt;p&gt;밑바닥부터 블록 단위(block by block)로 MEC 아키텍처를 구축하겠습니다 🙂&lt;/p&gt;
&lt;h1 id=&#34;1-mec-정의&#34;&gt;1. MEC 정의&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.etsi.org/technologies/multi-access-edge-computing&#34;&gt;ETSI&lt;/a&gt;에 따르면 MEC는 다음과 같이 정의됩니다.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;멀티 액세스 에지 컴퓨팅(MEC)은 애플리케이션 개발자와 콘텐츠 사업자에게 네트워크 에지(edge)에 있는
IT 서비스 환경과 클라우드 컴퓨팅 기능을 제공한다. 이 환경은 매우 짧은 대기 시간(초저지연)과 높은
대역폭은 물론 애플리케이션에서 활용될 수 있는 무선 네트워크 정보에 대한 실시간 접근이 특징이다.&amp;rdquo;&lt;/p&gt;
&lt;h1 id=&#34;2-etsi에-따른-mec-아키텍처&#34;&gt;2. ETSI에 따른 MEC 아키텍처&lt;/h1&gt;
&lt;p&gt;아래 그림과 같이 완전 MEC ETSI 아키텍처를 살펴보겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/mec-architecture-according-to-etsi.jpg&#34; alt=&#34;mec-architecture-according-to-etsi&#34;&gt;&lt;/p&gt;
&lt;p&gt;MEC 호스트, MEC 플랫폼 매니저, MEC 오케스트레이터라는 세 가지 블록(block)이 있습니다.&lt;/p&gt;
&lt;p&gt;이 세 블록을 보기 전에 가상화 인프라 매니저라는 가장 기본적인 블록부터 시작하겠습니다.&lt;/p&gt;
&lt;p&gt;모든 가상 네트워크에서는 가상 머신(VM)을 돌릴 수 있도록 서버가 있어야 하며 이러한 VM에는 관리 계층이 필요합니다.&lt;/p&gt;
&lt;h2 id=&#34;2-0-가상화-인프라-관리자-vim-virtualization-infrastructure-manager&#34;&gt;2-0. 가상화 인프라 관리자 (VIM, Virtualization Infrastructure Manager)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;../../nfv/cheat-sheet-understanding-nfv-architecture/&#34;&gt;NFV의 VIM&lt;/a&gt;과
유사한 기능을 가지고 있습니다. 물리적 인프라(컴퓨팅, 스토리지, 네트워킹)를 기반으로 VM 을 관리하는
것이 목적입니다. ‘가상화 인프라’의 가상 자원을 할당, 유지, 해제하는 역할을 담당합니다. 왼쪽에는 가상화된
인프라로 전환된 서버가 있고 오른쪽에는 이러한 서버의 가상 리소스를 관리하는 VIM이 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/virtualization-infrastructure-manager.jpg&#34; alt=&#34;virtualization-infrastructure-manager&#34;&gt;&lt;/p&gt;
&lt;p&gt;VIM 및 가상 리소스를 이해한 후 MEC 플랫폼 및 MEC 애플리케이션을 그 위에 구축하겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;2-1-mec-호스트&#34;&gt;2-1. MEC 호스트&lt;/h2&gt;
&lt;p&gt;가상화 인프라와 함께 MEC 애플리케이션 및 MEC 플랫폼을 묶어 MEC 호스트라고 합니다.&lt;/p&gt;
&lt;p&gt;MEC 애플리케이션부터 시작하겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;2-1-1-mec-애플리케이션&#34;&gt;2-1-1. MEC 애플리케이션&lt;/h3&gt;
&lt;p&gt;우리는 왜 MEC를 운영할까요? 애플리케이션을 실행하기 위해서죠?&lt;/p&gt;
&lt;p&gt;MEC 애플리케이션은 MEC에서 VM을 기반으로 실행되는 실제 애플리케이션입니다.
즉, MEC에서 실행되는 게임용 애플리케이션이나 가상 현실 또는 증강 현실 애플리케이션과 같은 실제 애플리케이션입니다.&lt;/p&gt;
&lt;p&gt;아래 다이어그램은 가상화 인프라의 가상 머신 위에 MEC 애플리케이션을 실행하고 있음을 보여 줍니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/mec-application.jpg&#34; alt=&#34;mec-application&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-1-2-mec-플랫폼&#34;&gt;2-1-2. MEC 플랫폼&lt;/h3&gt;
&lt;p&gt;더 나아가 MEC 플랫폼을 우리의 빌딩 블록에 추가하겠습니다. MEC 플랫폼에는 여러 구성 요소가 있습니다. 그 중 가장 중요한 것이 MEC 서비스입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/mec-platform.jpg&#34; alt=&#34;mec-platform&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;mec-서비스&#34;&gt;MEC 서비스&lt;/h4&gt;
&lt;p&gt;&amp;lsquo;MEC 서비스&amp;rsquo;는 MEC에서 중요한 블록입니다. 네트워크 관련 API들은 MEC 서비스에서 참조점(Reference Point) Mp1을
통해 MEC 애플리케이션에 노출됩니다. 또한 MEC 플랫폼은 이러한 서비스를 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;여전히 헷갈리시나요?&lt;/p&gt;
&lt;p&gt;MEC ETSI 아키텍처의 장점은 MEC 애플리케이션들이 네트워크 정보를 알고 있으며(MEC 애플리케이션들이 그에 기반한
조치를 취할 수 있도록), MEC 서비스가 API를 통해 네트워크 정보를 노출시켜 도움을 줄 수 있다는 점입니다.&lt;/p&gt;
&lt;p&gt;ETSI에 따르면 &amp;lsquo;MEC 서비스&amp;rsquo;에 의해 적어도 세 가지 유형의 서비스를 노출시켜야 하며, 이러한 서비스 유형은 (서비스 레지스트리의 일부분으로)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;무선 네트워크 상태&lt;/li&gt;
&lt;li&gt;위치 정보 (예: UE의 위치)&lt;/li&gt;
&lt;li&gt;대역폭 관리자 - 이 서비스를 사용하면 MEC 애플리케이션에(서) 라우팅 된 특정 트래픽에 대역폭을 할당하고 우선 순위를 지정할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(PS: UE는 사용자 장비(User Equipment)를 의미하며 여기서 휴대폰을 의미할 수 있습니다. 모바일 동글이 있는 노트북을 의미하기도 합니다.)&lt;/p&gt;
&lt;p&gt;MEC 서비스에 대해 논의한 후, 우리는 MEC 플랫폼의 다른 두 가지 구성요소를 알아야 합니다.&lt;/p&gt;
&lt;h4 id=&#34;트래픽-규칙-제어-traffic-rules-control&#34;&gt;트래픽 규칙 제어 (Traffic Rules Control)&lt;/h4&gt;
&lt;p&gt;이것은 MEC 플랫폼의 중요한 부분입니다. MEC 플랫폼은 여러 애플리케이션을 동시에 서비스하므로 &amp;ldquo;트래픽 규칙 제어&amp;rdquo; 를 통해 우선순위를 할당할 수 있어야 합니다.&lt;/p&gt;
&lt;h4 id=&#34;dns-핸들링&#34;&gt;DNS 핸들링&lt;/h4&gt;
&lt;p&gt;모바일 에지 플랫폼은 모든 UE에서 로컬 DNS 서버/프록시로 수신되는 모든 DNS 트래픽을 라우팅할 수 있는 기능을 제공해야 합니다.&lt;/p&gt;
&lt;p&gt;이것이 왜 중요할까요? MEC의 이점은 많은 정보를 인터넷으로 보내지 않고 MEC에서 로컬로 처리하는 것입니다.
따라서 트래픽이 인터넷으로 전송되는 대신 로컬에서 처리되도록 로컬 DNS 서버에 DNS 리다이렉션을 처리할 수 있는 방법이 있어야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;2-2-mec-플랫폼-관리자-mec-platform-manager&#34;&gt;2-2. MEC 플랫폼 관리자 (MEC Platform Manager)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/mec-platform-manager.jpg&#34; alt=&#34;mec-platform-manager&#34;&gt;&lt;/p&gt;
&lt;p&gt;NFV의 VNFM에 대해 알고 있으시죠?&lt;/p&gt;
&lt;p&gt;MEC 플랫폼 관리자는 VNFM보다 동일하거나 더 적은 기능을 수행합니다. 여기에는 다음 기능이 포함됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MEC 애플리케이션의 라이프사이클 관리: VM에서 MEC 애플리케이션을 실행(instantiating), 유지(maintaining), 해제(tearing down)&lt;/li&gt;
&lt;li&gt;요소 관리: MEC 플랫폼용 FCAPS 관리&lt;/li&gt;
&lt;li&gt;애플리케이션 규칙, 트래픽 규칙, DNS 구성을 관리합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(역주: &lt;a href=&#34;https://ko.wikipedia.org/wiki/FCAPS&#34;&gt;FCAPS&lt;/a&gt;: 장애 &lt;em&gt;Fault&lt;/em&gt;, 구성 &lt;em&gt;Configuration&lt;/em&gt;, 계정 &lt;em&gt;Accounting&lt;/em&gt;, 성능 &lt;em&gt;Performance&lt;/em&gt;, 보안 &lt;em&gt;Security&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;여기까지 만으로도 MEC 플랫폼을 관리할 수 있겠지만 아직 끝나지 않았습니다.
여러 MEC 호스트가 있을 수 있으므로 MEC 플랫폼 관리자도 여러 개 있을 수 있습니다.
따라서 서로 다른 MEC 플랫폼 관리자 간 조정을 할 수 있는 MEC 플랫폼 관리자 위의 계층이 있어야 합니다.
여기서 MEC 오케스트레이터가 등장하고 ETSI 아키텍처를 효과적으로 완성합니다.&lt;/p&gt;
&lt;h2 id=&#34;2-3-멀티-액세스-에지-오케스트레이터-multi-access-edge-orchestrator&#34;&gt;2-3. 멀티 액세스 에지 오케스트레이터 (Multi-access Edge Orchestrator)&lt;/h2&gt;
&lt;p&gt;MEC 오케스트레이터에 대한 비유를 NFVO 오케스트레이터에 적용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;다음과 같은 기능을 수행합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MEC 애플리케이션 라이프사이클 관리(유사한 기능을 수행할 수 있는 MEC 플랫폼 관리자와 비교해보세요).
오케스트레이터는 MEC 플랫폼 관리자를 통해 애플리케이션과 통신하여 이 기능을 수행합니다.&lt;/li&gt;
&lt;li&gt;패키지 무결성(integrity) 및 신뢰성(authenticity) 검증 기능을 포함하는 애플리케이션 패키지 설치(on-boarding).&lt;/li&gt;
&lt;li&gt;지연 시간, 사용 가능한 리소스, 사용 가능한 서비스와 같은 제약 조건을 기반으로 애플리케이션 생성(instantiation)에 적합한 MEC 호스트를 선택.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/multi-access-edge-orchestrator.jpg&#34; alt=&#34;multi-access-edge-orchestrator&#34;&gt;&lt;/p&gt;
&lt;p&gt;마지막으로 몇 가지 언급해야 할 것들이 있습니다:&lt;/p&gt;
&lt;h2 id=&#34;cfs-portal&#34;&gt;CFS Portal&lt;/h2&gt;
&lt;p&gt;모바일 사업자의 고객(the mobile operators’ customers)은 CFS(Customer Facing Service, 고객 대면 서비스)를 통해 새로운 MEC 애플리케이션을 주문하거나 서비스 SLA(Service Level Agreement, 서비스 수준 협약)를 모니터링할 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;사용자-애플리케이션-수명-주기-관리-프록시-user-app-lcm-proxy&#34;&gt;사용자 애플리케이션 수명 주기 관리 프록시 (User App LCM Proxy)&lt;/h2&gt;
&lt;p&gt;이것은 MEC 시스템 선택 기능입니다. 이를 위해 시스템은 &lt;code&gt;UserApps&lt;/code&gt;라는 기능을 지원해야 합니다.&lt;/p&gt;
&lt;p&gt;모바일 에지 시스템이 &lt;code&gt;UserApps&lt;/code&gt; 기능을 지원할 때, 시스템은 (디바이스 애플리케이션을 실행하는) UE와 모바일 에지 애플리케이션(ME App)의 특정 인스턴스 간 연결 설정을 허용해야 합니다.&lt;/p&gt;
&lt;p&gt;사용자 애플리케이션 LCM 프록시를 지원한다면 디바이스 애플리케이션이 설치(on-boarding), 생성(instantiation), 사용자 애플리케이션 종료(termination) 요청을 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;간단히 말해, 이 기능이 MEC 시스템에서 지원되면 사용자는 자신의 장치에서 MEC 시스템의 특정 애플리케이션을 작동시킬 수 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.telcocloudbridge.com/blog/beginners-guide-to-mec-architecture-multi-access-edge-computing/&#34;&gt;원문 링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;MEC 아키텍처 초심자 가이드가 끝났습니다. 이제 아키텍처에 대해 질문해주세요.&lt;/p&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.etsi.org/deliver/etsi_gs/MEC/001_099/003/01.01.01_60/gs_MEC003v010101p.pdf&#34;&gt;ETSI GS MEC 002 V1.1.1 (2016-03)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.etsi.org/deliver/etsi_gs/MEC/001_099/003/02.01.01_60/gs_MEC003v020101p.pdf&#34;&gt;ETSI GS MEC 003 V2.1.1 (2019-01)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
- https://markruler.github.io/posts/mec/beginners-guide-to-mec-architecture/ - Im Changsu 2020 - 2024</description>
        </item>
    
    
    
    
  </channel>
</rss> 