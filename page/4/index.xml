<?xml-stylesheet href="/rss.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>임창수</title>
    <link>https://markruler.github.io/</link>
    <description>Recent content on 임창수</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <managingEditor>imcxsu@gmail.com (Im Changsu)</managingEditor>
    <webMaster>imcxsu@gmail.com (Im Changsu)</webMaster>
    <copyright>Im Changsu | Since 2020</copyright>
    <lastBuildDate>Mon, 30 Dec 2024 18:38:00 +0900</lastBuildDate>
    
        <atom:link href="https://markruler.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>CS Visualized: 유용한 깃(Git) 명령어</title>
        <link>https://markruler.github.io/posts/shell/cs-visualized-useful-git-commands/</link>
        <pubDate>Sat, 09 Jan 2021 08:35:00 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/shell/cs-visualized-useful-git-commands/</guid>
        <description>임창수 https://markruler.github.io/posts/shell/cs-visualized-useful-git-commands/ -&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;리디아 할리(Lydia Hallie, &lt;a href=&#34;https://twitter.com/lydiahallie&#34;&gt;@lydiahallie&lt;/a&gt;)가 쓴 &lt;a href=&#34;https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1&#34;&gt;CS Visualized: Useful Git Commands&lt;/a&gt;를 번역한 글입니다.&lt;/li&gt;
&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Git이 정말 강력한 도구이긴 하지만, 대다수의 사람들은 끔찍한 악몽 😐
같다는 말도 공감할 거에요. 저는 항상 Git으로 작업할 때 어떤 일이 일어날지
머릿속으로 그려보는 것이 꽤 유용하다는 것을 알았습니다. 특정 명령을 실행할
때 브랜치는 어떻게 상호작용하고, 그것이 히스토리에 어떤 영향을 미칠까요?
&lt;code&gt;master&lt;/code&gt;에서 &lt;code&gt;reset --hard&lt;/code&gt; 하고 &lt;code&gt;origin&lt;/code&gt; 리포지터리로 &lt;code&gt;force push&lt;/code&gt;한 후,
&lt;code&gt;.git&lt;/code&gt; 폴더를 &lt;code&gt;rimraf&lt;/code&gt;하면 왜 저의 팀원은 소리를 지를까요?&lt;/p&gt;
&lt;p&gt;* &lt;code&gt;rimraf&lt;/code&gt; == &lt;code&gt;rm -rf&lt;/code&gt;: 묻지도 따지지도 않고 전부 지워버린다.&lt;/p&gt;
&lt;p&gt;저는 가장 많이 쓰이면서 유용한 명령어들을 시각화하는 것이 완벽한 유즈 케이스라고 생각했습니다! 🥳
명령어들은 동작(behavior)을 바꾸기 위해 사용할 수 있는 전달 인자들(arguments)이 있지만,
제가 다룰 예시에서는 (수많은) 설정 옵션 없이 명령어의 기본 동작에 대해서만 설명하겠습니다. 😄&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;병합-merge&#34;&gt;병합 (Merge)&lt;/h1&gt;
&lt;p&gt;브랜치가 여러 개 있으면 새로운 변경 사항들을 분리해서 관리하기 편합니다.
승인되지 않았거나 잘못된 변경 사항을 실수로 운영 환경에 푸시하지
않도록 하는 데에도 편합니다. 변경 사항이 승인됐다면 운영 환경
브랜치에 적용해야 하죠!&lt;/p&gt;
&lt;p&gt;한 브랜치에서 다른 브랜치로 변경 사항을 옮기는 한 가지 방법은
&lt;code&gt;git merge&lt;/code&gt;를 실행하는 것입니다! Git이 수행할 수 있는 병합에는
&lt;strong&gt;fast-forward&lt;/strong&gt;, &lt;strong&gt;no-fast-forward&lt;/strong&gt;라는 두 가지 유형이 있습니다. 🐢&lt;/p&gt;
&lt;p&gt;지금 당장은 무슨 말인지 이해되지 않으실테니 차이점을 살펴보도록 하겠습니다!&lt;/p&gt;
&lt;h2 id=&#34;fast-forward---ff&#34;&gt;Fast-forward (&lt;code&gt;--ff&lt;/code&gt;)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;fast-forward 병합&lt;/strong&gt;은 현재 브랜치에 병합하려는 브랜치에 비해 추가
커밋이 없을 때 발생할 수 있습니다. Git은&amp;hellip; &lt;em&gt;게을러서&lt;/em&gt; 가장 쉬운
옵션인 fast-forward부터 시도하려 할 것입니다! 이 방식은 새로운
커밋을 생성하지 않고 병합하려는 브랜치의 커밋을 그대로 병합합니다. 🥳&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/shell/lydia/merge-ff.gif&#34; alt=&#34;merge-ff&#34;&gt;&lt;/p&gt;
&lt;p&gt;Perfect! 우리는 이제 &lt;code&gt;dev&lt;/code&gt; 브랜치에서 만든 모든 변경 사항들을
&lt;code&gt;master&lt;/code&gt; 브랜치에서도 접근할 수 있게 되었습니다. 그럼
&lt;strong&gt;no-fast-forward&lt;/strong&gt;는 뭘까요?&lt;/p&gt;
&lt;h2 id=&#34;no-fast-foward---no-ff&#34;&gt;No-fast-foward (&lt;code&gt;--no-ff&lt;/code&gt;)&lt;/h2&gt;
&lt;p&gt;병합하려는 브랜치와 비교해 현재 브랜치에 추가 커밋이 없는 경우가 좋겠지만
안타깝게도 그런 경우는 거의 없습니다! 병합할 브랜치에 없는 변경 사항을 현재 브랜치에 커밋한 경우
Git은 &lt;em&gt;no-fast-forward&lt;/em&gt; 병합을 수행합니다.&lt;/p&gt;
&lt;p&gt;Git은 no-fast-forward을 사용해 현재 브랜치에 새로운 &lt;em&gt;병합 커밋&lt;/em&gt;을 생성합니다.
상위 커밋은 현재 브랜치와 병합하려는 브랜치 모두를 가리킵니다!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/shell/lydia/merge-no-ff.gif&#34; alt=&#34;merge-no-ff&#34;&gt;&lt;/p&gt;
&lt;p&gt;별 거 아니지만 완벽해요! 🎉
이제 &lt;code&gt;master&lt;/code&gt; 브랜치는 &lt;code&gt;dev&lt;/code&gt; 브랜치에서 변경한 내용을 모두 포함합니다.&lt;/p&gt;
&lt;h2 id=&#34;병합-충돌-merge-conflicts&#34;&gt;병합 충돌 (Merge conflicts)&lt;/h2&gt;
&lt;p&gt;어떻게 브랜치를 병합하고 파일에 변경 사항을 추가할지 Git이 잘 결정할테지만,
Git이 항상 혼자 결정할 수는 없습니다. 🙂 병합하려는 두 개의 브랜치가 똑같은
파일, 똑같은 줄에 변경 사항이 있거나 한 브랜치가 다른 브랜치에서 변경한 파일을
삭제하는 경우 등의 문제가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이런 경우 Git이 두 가지 중 어떤 내용을 유지하고 싶은지 물어볼 것입니다!
두 브랜치 모두에서 &lt;code&gt;README.md&lt;/code&gt;의 첫번째 줄을 편집했다고 가정해 보겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/shell/lydia/readme.png&#34; alt=&#34;readme&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dev&lt;/code&gt;를 &lt;code&gt;master&lt;/code&gt;로 병합하려는 경우 병합 충돌이 발생합니다.
그럼 제목을 &lt;code&gt;Hello!&lt;/code&gt; 또는 &lt;code&gt;Hey!&lt;/code&gt; 중 어떤 걸로 지정하실래요?&lt;/p&gt;
&lt;p&gt;브랜치를 병합하려고 하면 Git은 충돌이 발생한 위치를 보여줄 겁니다.
버리고 싶은 변경 사항을 수동으로 제거하고 저장한 후,
변경된 파일을 다시 추가하면 커밋할 수 있게 됩니다. 🥳&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/shell/lydia/merge-conflict.gif&#34; alt=&#34;merge-conflict&#34;&gt;&lt;/p&gt;
&lt;p&gt;Yay! 병합 충돌은 정말 번거롭지만 꼭 필요한 과정입니다.
Git은 단순히 우리가 유지하고자 하는 변경 사항을 &lt;em&gt;가정&lt;/em&gt;해서는 안 됩니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;리베이스-rebase&#34;&gt;리베이스 (Rebase)&lt;/h1&gt;
&lt;p&gt;방금 &lt;code&gt;git merge&lt;/code&gt;를 수행하여 한 브랜치에서 다른 브랜치로 변경 사항을 적용하는 방법을
보았습니다. 여기에 또 한 가지 방법이 있는데 바로 &lt;code&gt;git rebase&lt;/code&gt;입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git rebase&lt;/code&gt;는 현재 브랜치에서 커밋을 복사하고 복사된 커밋을 지정한 브랜치 맨 위에 놓습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/shell/lydia/rebase.gif&#34; alt=&#34;rebase&#34;&gt;&lt;/p&gt;
&lt;p&gt;Perfect! 이제 &lt;code&gt;master&lt;/code&gt; 브랜치의 모든 변경 사항을 &lt;code&gt;dev&lt;/code&gt; 브랜치에서도 사용할 수 있게 되었습니다! 🎊&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git merge&lt;/code&gt;와 비교할 때 큰 차이점은 Git이 유지할 파일과 유지하지 않을 파일을 물어보지
않았는다는 거에요. 리베이스 하는 브랜치에는 항상 최근 변경 사항이 적용됩니다!
이러한 방식으로 병합 충돌은 발생하지 않고 Git 히스토리를 선형으로 유지하죠.&lt;/p&gt;
&lt;p&gt;이 예에서는 &lt;code&gt;master&lt;/code&gt; 브랜치에 대한 리베이스를 보여 줍니다.
그러나 더 큰 프로젝트에서는 대개 이렇게 하고 싶지 않을 거에요.
&lt;code&gt;git rebase&lt;/code&gt;는 복사된 커밋의 해시가 새로 생성될 때
&lt;strong&gt;프로젝트 히스토리를 변형시킵니다&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;리베이스는 &lt;code&gt;feature&lt;/code&gt; 브랜치에서 작업할 때나 &lt;code&gt;master&lt;/code&gt; 브랜치가 업데이트될 때 유용합니다.
브랜치에서 모든 업데이트를 받을 수 있으므로 이후 병합 충돌을 방지할 수 있거든요! 😄&lt;/p&gt;
&lt;h2 id=&#34;대화형-리베이스--i-interactive-rebase&#34;&gt;대화형 리베이스 (&lt;code&gt;-i&lt;/code&gt; interactive rebase)&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;대화형 리베이스&lt;/em&gt;를 사용하면 커밋을 리베이스 하기 전에 변형시킬 수도 있어요! 😃
대화형 리베이스는 현재 작업 중인 브랜치에서 일부 커밋을 수정하고 싶은 경우 유용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;리베이스 작업중인 커밋에 대해 수행할 수 있는 명령어는 6가지가 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;reword&lt;/code&gt;: 커밋 메시지 수정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edit&lt;/code&gt;: 커밋 수정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;squash&lt;/code&gt;: 이전 커밋과 혼합&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fixup&lt;/code&gt;: 커밋 로그 메시지를 유지하지 않고 이전 커밋과 혼합&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exec&lt;/code&gt;: 리베이스하려는 커밋마다 명령어 실행&lt;/li&gt;
&lt;li&gt;&lt;code&gt;drop&lt;/code&gt;: 커밋 삭제&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Awesome! 이 명령어들을 사용해 커밋을 완전히 제어할 수 있습니다.
만약 커밋을 지우고 싶다면 그냥 &lt;code&gt;drop&lt;/code&gt;하세요.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/shell/lydia/rebase-drop.gif&#34; alt=&#34;rebase-drop&#34;&gt;&lt;/p&gt;
&lt;p&gt;만약 깨끗한 히스토리를 유지하고 싶다면 여러 커밋들을 &lt;code&gt;squash&lt;/code&gt;하시면 됩니다. 문제 없어요!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/shell/lydia/rebase-squash.gif&#34; alt=&#34;rebase-squash&#34;&gt;&lt;/p&gt;
&lt;p&gt;대화형 리베이스는 커밋을 제어하는 다양한 방법을 제공합니다.
현재 작업 중인 브랜치라도 말이죠!&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;리셋-reset&#34;&gt;리셋 (Reset)&lt;/h1&gt;
&lt;p&gt;나중에 원치 않는 변경 사항을 커밋할 수도 있습니다.
&lt;code&gt;WIP&lt;/code&gt;&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 커밋이거나 버그가 발견된 커밋일 수도 있죠! 🐛
그런 경우에 &lt;code&gt;git reset&lt;/code&gt; 명령어를 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git reset&lt;/code&gt;은 스테이징&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;된 파일을 제거하거나
&lt;code&gt;HEAD&lt;/code&gt;가 가리키는 곳을 제어할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;소프트-리셋---soft&#34;&gt;소프트 리셋 (&lt;code&gt;--soft&lt;/code&gt;)&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;소프트 리셋&lt;/em&gt;은 &lt;code&gt;HEAD&lt;/code&gt;를 지정된 커밋으로 옮기거나 해당 커밋의 인덱스를 &lt;code&gt;HEAD&lt;/code&gt;와 비교합니다.
나중에 커밋된 변경 사항들을 제거하지 않고서 말이죠!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;style.css&lt;/code&gt; 파일을 추가한 &lt;code&gt;9e78i&lt;/code&gt; 커밋과
&lt;code&gt;index.js&lt;/code&gt; 파일을 추가한 &lt;code&gt;035cc&lt;/code&gt; 커밋을 유지하고 싶지 않다고 가정해 보겠습니다.
하지만 새로 추가된 &lt;code&gt;style.css&lt;/code&gt;와 &lt;code&gt;index.js&lt;/code&gt; 파일은 유지하고 싶어요!
그럼 소프트 리셋을 위한 완벽한 유즈 케이스입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/shell/lydia/reset-soft.gif&#34; alt=&#34;reset-soft&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git status&lt;/code&gt;를 입력하면 아직 이전 커밋에서 변경한 모든 내용에 접근할 수 있다는 것을 알 수 있습니다.
이렇게 파일의 내용을 변경하고 또 다시 커밋할 수 있으니 좋은 방법입니다!&lt;/p&gt;
&lt;h2 id=&#34;하드-리셋---hard&#34;&gt;하드 리셋 (&lt;code&gt;--hard&lt;/code&gt;)&lt;/h2&gt;
&lt;p&gt;때로는 특정 커밋에 의해 반영된 변경 사항을 유지하고 싶지 않을 겁니다.
그럼 소프트 리셋과 달리 더 이상 변경 사항에 접근할 필요가 없겠죠.
Git은 지정된 커밋의 상태로 간단하게 리셋합니다.
여기에는 워킹 디렉토리와 스테이징된 파일의 변경 사항도 포함됩니다! 💣&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/shell/lydia/reset-hard.gif&#34; alt=&#34;reset-hard&#34;&gt;&lt;/p&gt;
&lt;p&gt;Git은 &lt;code&gt;9e78i&lt;/code&gt;와 &lt;code&gt;035cc&lt;/code&gt; 커밋에 반영된 변경 사항을 버리고
&lt;code&gt;ec5be&lt;/code&gt;커밋으로 다시 상태를 리셋했습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;리버트-revert&#34;&gt;리버트 (Revert)&lt;/h1&gt;
&lt;p&gt;변경 사항을 되돌리는 또 다른 방법은 &lt;code&gt;git revert&lt;/code&gt; 하는 것입니다.
특정 커밋을 리버트하면 &lt;em&gt;새로운 커밋&lt;/em&gt;이 생성되고 여기에는 리버트된 변경 사항이 포함됩니다!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ec5be&lt;/code&gt; 커밋으로 &lt;code&gt;index.js&lt;/code&gt; 파일이 추가됐다고 가정해 보겠습니다.
그리고 나중에서야 이 변경 사항이 더 이상 필요없다는 것을 느끼죠!
이제 &lt;code&gt;ec5be&lt;/code&gt; 커밋을 되돌려보겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/shell/lydia/revert.gif&#34; alt=&#34;revert&#34;&gt;&lt;/p&gt;
&lt;p&gt;Perfect! &lt;code&gt;9e78i&lt;/code&gt; 커밋은 &lt;code&gt;ec5be&lt;/code&gt; 커밋에 반영된 변경 사항을 제거했습니다.
&lt;code&gt;git revert&lt;/code&gt;를 실행하면 브랜치의 히스토리를 수정하지 않고 특정 커밋을 되돌릴 수 있습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;체리-피킹-cherry-pick&#34;&gt;체리 피킹 (Cherry-pick)&lt;/h1&gt;
&lt;p&gt;특정 브랜치에 우리에게 필요한 변경 사항을 가진 커밋이 있다면,
&lt;code&gt;cherry-pick&lt;/code&gt; 명령어를 사용할 수 있습니다! 커밋을 &lt;code&gt;cherry-pick&lt;/code&gt;하면
&lt;code&gt;cherry-pick&lt;/code&gt; 커밋에 담긴 변경 사항을 포함해 현재 브랜치에 새로운 커밋을 만듭니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dev&lt;/code&gt; 브랜치의 &lt;code&gt;76d12&lt;/code&gt; 커밋이 &lt;code&gt;master&lt;/code&gt; 브랜치에서 원하는 변경 사항을
&lt;code&gt;index.js&lt;/code&gt; 파일에 추가했다고 가정해 보세요. 그럼 &lt;em&gt;다른 커밋&lt;/em&gt;들은 필요없고
단 한 가지 커밋만 있으면 됩니다!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/shell/lydia/cherry-pick.gif&#34; alt=&#34;cherry-pick&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;페치-fetch&#34;&gt;페치 (Fetch)&lt;/h1&gt;
&lt;p&gt;현재 브랜치에 없는 커밋이 원격 브랜치에 생길 수 있습니다!
예를 들어 다른 브랜치가 병합된다거나 동료가 빠르게 변경 사항을 푸시하는 경우 등이 있죠.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git fetch&lt;/code&gt;를 실행해서 원격 브랜치의 변경 사항을 로컬로 가져올 수 있습니다!
&lt;code&gt;fetch&lt;/code&gt;는 단순히 새로운 데이터를 다운로드 하는 것일 뿐이지, 로컬 브랜치에 영향을 끼치지는
않습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/shell/lydia/git-fetch.gif&#34; alt=&#34;git-fetch&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;풀-pull&#34;&gt;풀 (Pull)&lt;/h1&gt;
&lt;p&gt;브랜치의 원격 데이터를 가져오기 위해서는 &lt;code&gt;git fetch&lt;/code&gt;도 유용하지만 &lt;code&gt;git pull&lt;/code&gt;도 좋습니다.
&lt;code&gt;git pull&lt;/code&gt;은 &lt;code&gt;git fetch&lt;/code&gt;와 &lt;code&gt;git merge&lt;/code&gt; 두 가지 명령을 합친 것입니다.
&lt;code&gt;origin&lt;/code&gt; 저장소에서 변경 사항을 풀(pull)할 때 먼저 &lt;code&gt;git fetch&lt;/code&gt; 명령처럼
모든 데이터를 가져온 후 최신 변경 사항을 자동으로 로컬 브랜치에 병합합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/shell/lydia/git-pull.gif&#34; alt=&#34;git-pull&#34;&gt;&lt;/p&gt;
&lt;p&gt;Awesome! 이제 원격 브랜치와 완전히 동기화되었고 최신 변경 사항이 모두 반영되었습니다! 🤩&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;레프-로그-reflog&#34;&gt;레프-로그 (Reflog)&lt;/h1&gt;
&lt;p&gt;모든 사람은 실수를 합니다. 지극히 정상이에요!
때로는 Git 저장소를 망쳐버려서 완전히 삭제하고 싶은 충동을 느낄 수도 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git reflog&lt;/code&gt;는 실행된 작업 로그를 모두 표시하는 데 정말 유용한 명령입니다!
여기에는 병합, 리셋, 리버트 등 기본적으로 브랜치에 대한 모든 변경 사항이 포함됩니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/shell/lydia/git-reflog.gif&#34; alt=&#34;git-reflog&#34;&gt;&lt;/p&gt;
&lt;p&gt;실수를 했다면 &lt;code&gt;reflog&lt;/code&gt;가 주는 정보를 바탕으로 &lt;code&gt;HEAD&lt;/code&gt;를 리셋해서 쉽게 되돌릴 수 있습니다!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;origin&lt;/code&gt; 저장소의 브랜치를 병합하지 않고 싶다고 가정해보세요.
&lt;code&gt;git reflog&lt;/code&gt; 명령어를 실행하면 병합 전의 저장소 상태가 &lt;code&gt;HEAD@{1}&lt;/code&gt;로 표시됩니다.
&lt;code&gt;git reset&lt;/code&gt;을 수행하여 헤드가 &lt;code&gt;head@{1}&lt;/code&gt;으로 돌아가도록 합니다!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/shell/lydia/reset-reflog.gif&#34; alt=&#34;reset-reflog&#34;&gt;&lt;/p&gt;
&lt;p&gt;리셋 명령으로 &lt;code&gt;reflog&lt;/code&gt;가 밀린 것을 볼 수 있습니다!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Git에는 유용한 포셀린(porcelain) 명령어와 플러밍(plumbing) 명령어&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;가 너무
많아서 모두 다룰 수 있었으면 좋겠어요! 😄 다른 명령어나 대안들이 많아서 미처
다룰 시간이 없었다는 것을 이해해주세요. 좋아하는 명령어나 가장 유용한 명령어가
무엇인지 알려주시면 제가 다른 글에서 다룰 수도 있습니다!&lt;/p&gt;
&lt;p&gt;그리고 언제나 그랬듯이 저(Lydia Hallie)와 소통해요! 😊&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;✨&lt;/th&gt;
          &lt;th&gt;👩🏽‍💻&lt;/th&gt;
          &lt;th&gt;💻&lt;/th&gt;
          &lt;th&gt;💡&lt;/th&gt;
          &lt;th&gt;📷&lt;/th&gt;
          &lt;th&gt;💌&lt;/th&gt;
          &lt;th&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://www.twitter.com/lydiahallie&#34;&gt;Twitter&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://www.instagram.com/theavocoder&#34;&gt;Instagram&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://www.github.com/lydiahallie&#34;&gt;GitHub&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://www.linkedin.com/in/lydia-hallie&#34;&gt;LinkedIn&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://www.youtube.com/channel/UC4EWKIKdKiDtAscQ9BIXwUw&#34;&gt;YouTube&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;mailto:lydiahallie.dev@gmail.com&#34;&gt;Email&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;WIP (Work in Progress): 진행 중인 작업&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;현재 작업 중인 &amp;ldquo;working directory&amp;quot;를 &lt;code&gt;git add&lt;/code&gt; 하면 &amp;ldquo;staging area&amp;quot;로 옮겨진다. 그 후 &lt;code&gt;git commit&lt;/code&gt;을 하면 &amp;ldquo;local repository&amp;quot;로 옮겨진다. 여기서 &lt;code&gt;git push&lt;/code&gt;를 명령할 경우 마침내 &amp;ldquo;remote repository&amp;quot;로 간다.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://git-scm.com/book/ko/v2/Git%EC%9D%98-%EB%82%B4%EB%B6%80-Plumbing-%EB%AA%85%EB%A0%B9%EA%B3%BC-Porcelain-%EB%AA%85%EB%A0%B9&#34;&gt;저수준의 명령어는 &amp;ldquo;Plumbing&amp;rdquo; 명령어라고 부르고 좀 더 사용자에게 친숙한 사용자용 명령어는 &amp;ldquo;Porcelain&amp;rdquo; 명령어라고 부른다.&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
- https://markruler.github.io/posts/shell/cs-visualized-useful-git-commands/ - Im Changsu | Since 2020</description>
        </item>
    
    
    
        <item>
        <title>CS Visualized: CORS</title>
        <link>https://markruler.github.io/posts/web/cs-visualized-cors/</link>
        <pubDate>Sat, 02 Jan 2021 08:50:00 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/web/cs-visualized-cors/</guid>
        <description>임창수 https://markruler.github.io/posts/web/cs-visualized-cors/ -&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;리디아 할리(Lydia Hallie, &lt;a href=&#34;https://twitter.com/lydiahallie&#34;&gt;@lydiahallie&lt;/a&gt;)가 쓴 &lt;a href=&#34;https://dev.to/lydiahallie/cs-visualized-cors-5b8h&#34;&gt;CS Visualized: CORS&lt;/a&gt;를 번역한 글입니다.&lt;/li&gt;
&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;어쩌다 콘솔에서 &amp;ldquo;fetch 접근이 CORS 정책에 의해 차단되었습니다&amp;quot;라는
커다란 빨간색 오류를 보면 모든 개발자가 짜증을 느낍니다! 😬
임시방편이 몇 가지 있긴 하지만 오늘은 그 어떤 것도 사용하지 않겠습니다!
대신 CORS가 실제로 무엇을 하고 있는지 왜 우리에게 도움이 되는지
알아보도록 하겠습니다. 👏🏼&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;❗️ 이 글에서는 HTTP 기본에 대해 설명하지 않겠습니다.
HTTP 요청과 응답에 대해 더 자세히 알고 싶으시다면 제가 얼마 전에
작성한 &lt;a href=&#34;https://www.lydiahallie.dev/blog/http11&#34;&gt;짧은 글&lt;/a&gt;이
있습니다. 🙂 제가 사용한 예시에서 HTTP/2 대신 HTTP/1.1을
사용하지만 CORS에 영향을 미치지는 않습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;우리는 종종 프런트엔드에서 다른 곳에 있는 데이터를 보여주고 싶습니다!
해당 데이터를 가져오기 위해 브라우저는 먼저 서버에 요청을 해야 하죠!
이 요청은 서버가 데이터를 클라이언트로 보내기 위해 필요한
모든 정보를 포함합니다. 🙂&lt;/p&gt;
&lt;p&gt;예를 들어 웹사이트 &lt;code&gt;www.mywebsite.com&lt;/code&gt;에서 &lt;code&gt;api.website.com&lt;/code&gt; 서버에
있는 사용자 정보를 가져오려고 합니다!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/lydia/request-same.gif&#34; alt=&#34;request-same&#34;&gt;&lt;/p&gt;
&lt;p&gt;Perfect! 😃 방금 서버로 HTTP 요청을 보냈습니다.
그런 다음 서버는 우리가 요청했던 JSON 데이터를 응답했습니다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;동일한&lt;/em&gt; 요청을 &lt;strong&gt;다른 도메인&lt;/strong&gt;에 시도해보겠습니다.
&lt;code&gt;www.mywebsite.com&lt;/code&gt; 대신
&lt;code&gt;www.anotherdomain.com&lt;/code&gt;에서 요청하겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/lydia/request-another.gif&#34; alt=&#34;request-another&#34;&gt;&lt;/p&gt;
&lt;p&gt;잠깐, 뭐죠? 우리는 똑같은 요청을 보냈는데 이번에는 브라우저가 이상한 오류가 보여주죠?&lt;/p&gt;
&lt;p&gt;우리는 방금 CORS가 동작하는 것을 보았습니다! 💪🏼
그럼 이 오류가 발생한 원인과 정확히 무엇을 뜻하는지 알아보겠습니다.&lt;/p&gt;
&lt;h1 id=&#34;-같은-출처-정책-same-origin-policy&#34;&gt;✋🏼 같은 출처 정책 (Same-Origin Policy)&lt;/h1&gt;
&lt;p&gt;웹은 &lt;strong&gt;같은 출처 정책&lt;/strong&gt;이라는 것을 시행합니다. 기본적으로 우리는
요청을 하는 곳과 &lt;strong&gt;같은 출처&lt;/strong&gt;에 있는 자원만 접근할 수 있습니다! 💪🏼
예를 들어 &lt;code&gt;https://mywebsite.com&lt;/code&gt;에서 &lt;code&gt;https://mywebsite.com/image1.png&lt;/code&gt;에
있는 이미지를 불러 오는 것은 괜찮습니다.&lt;/p&gt;
&lt;p&gt;만약 자원이 다른 (하위)도메인 또는 다른 프로토콜, 다른 포트에 있는 경우
다른 출처(cross-origin)에 있다고 말합니다!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/lydia/origin.png&#34; alt=&#34;origin&#34;&gt;&lt;/p&gt;
&lt;p&gt;좋아요, 그런데 왜 같은 출처 정책까지 있는 거죠?&lt;/p&gt;
&lt;p&gt;만약 같은 출처 정책이 없었고 이모가 페이스북에서 보낸
수많은 바이러스 링크 중 하나를 실수로 클릭했다고 가정해 보세요.
이 링크가 여러분을 &amp;ldquo;유해 사이트&amp;quot;로 리다이렉션 시킵니다.
은행 사이트를 불러 오는 iframe이 내장된 웹사이트로요.
그리고 설정되어 있던 쿠키를 통해 성공적으로 로그인합니다! 😬&lt;/p&gt;
&lt;p&gt;&amp;ldquo;유해 사이트&amp;rdquo; 개발자들은 본인 계좌로 돈을 보내기 위해
웹사이트가 이 iframe에 접근하고 은행 사이트 DOM 콘텐츠에
접근할 수 있게끔 만들었습니다!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;역주: 위 공격은 CSRF (Cross-Site Request Forgery) 공격에 해당되며
XSS (Cross-Site Scripting)도 같은 출처 정책과 관련된 공격입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/lydia/wo-same-origin-policy.gif&#34; alt=&#34;wo-same-origin-policy&#34;&gt;&lt;/p&gt;
&lt;p&gt;맞습니다&amp;hellip; 이건 엄청난 보안 위험이에요! 우리는 그 누구도 접근하지 못하길 바랍니다. 😧&lt;/p&gt;
&lt;p&gt;운 좋게도 여기서 같은 출처 정책이 우리를 도와줍니다!
이 정책은 &lt;strong&gt;같은 출처&lt;/strong&gt; 자원만 접근할 수 있도록 합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/lydia/with-policy.gif&#34; alt=&#34;with-policy&#34;&gt;&lt;/p&gt;
&lt;p&gt;이 경우 &lt;code&gt;www.evilwebsite.com&lt;/code&gt;은 다른 출처인 &lt;code&gt;www.bank.com&lt;/code&gt; 자원에
접근하려고 했습니다! 같은 출처 정책은 이러한 일이 발생하지 않도록 접근을
차단하고 유해 사이트 개발자가 우리의 은행 데이터에 접근할 수 없도록 만듭니다. 🥳&lt;/p&gt;
&lt;p&gt;좋아요, 그럼&amp;hellip; 이것이 CORS와 무슨 관계가 있나요?&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;-클라이언트-측-cors&#34;&gt;🔥 클라이언트 측 CORS&lt;/h1&gt;
&lt;p&gt;같은 출처 정책은 실제로 스크립트에만 적용되지만, 브라우저는 자바스크립트에서
요청하는 것까지 이 정책을 &amp;ldquo;확장&amp;quot;시킵니다. 기본적으로 우리는 &lt;strong&gt;같은 출처&lt;/strong&gt;에서
가져온 자원만 접근할 수 있습니다!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/lydia/client-side-cors.gif&#34; alt=&#34;client-side-cors&#34;&gt;&lt;/p&gt;
&lt;p&gt;흠, 하지만&amp;hellip; 때로는 다른 출처 자원에 접근해야만 합니다. 🤔
프런트엔드가 데이터를 불러 오기 위해 백엔드 API를 호출해야 할 수도 있습니다.
그래서 브라우저는 다른 출처 요청을 안전하게 만들기 위해 &lt;strong&gt;CORS&lt;/strong&gt;라는
메커니즘을 사용합니다! 🥳&lt;/p&gt;
&lt;p&gt;CORS는 &lt;strong&gt;다른 출처 자원 공유(Cross-Origin Resource Sharing)&lt;/strong&gt; 를 말합니다.
브라우저가 같은 출처가 아닌 자원에 접근할 수 없게 하지만, CORS를 사용하여
이러한 보안 제한을 약간 바꿔서 다른 출처 자원에 안전하게 접근할 수 있습니다. 🎉&lt;/p&gt;
&lt;p&gt;사용자 에이전트(예: 브라우저)는 차단될 &lt;strong&gt;다른 출처 요청을 허용&lt;/strong&gt;하기 위해
HTTP 응답의 특정 CORS 헤더 값에 따라 CORS 메커니즘을 사용할 수 있습니다! ✅&lt;/p&gt;
&lt;p&gt;다른 출처 요청을 하면 클라이언트는 자동으로 HTTP 요청에
&lt;code&gt;Origin&lt;/code&gt; 헤더를 추가합니다. &lt;code&gt;Origin&lt;/code&gt; 헤더 값은 요청을 보낸 출처입니다!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/lydia/origin-header.gif&#34; alt=&#34;origin-header&#34;&gt;&lt;/p&gt;
&lt;p&gt;브라우저가 다른 출처 자원에 접근할 수 있도록 클라이언트의 &lt;code&gt;Origin&lt;/code&gt; 헤더는
해당 서버에게 다른 출처 요청 허용 여부를 명시한 응답 헤더를 요구하는 것입니다!&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;-서버-측-cors&#34;&gt;💻 서버 측 CORS&lt;/h1&gt;
&lt;p&gt;서버 개발자는 HTTP 응답에 헤더를 추가하여 다른 출처 요청이 허용되는지
확인시켜줄 수 있습니다. 이 헤더는 모두 &lt;code&gt;Access-Control-*&lt;/code&gt;로 시작합니다. 🔥
이 CORS 응답 헤더의 값에 따라 브라우저는 일반적으로 같은 출처
정책에 의해 차단되는 특정 다른 출처 응답을 허용할 수 있습니다!&lt;/p&gt;
&lt;p&gt;사용할 수 있는 &lt;a href=&#34;https://fetch.spec.whatwg.org/#http-responses&#34;&gt;여러 CORS 헤더&lt;/a&gt;가
있지만 브라우저가 다른 출처 자원 접근을 허용하기 위해 필요한 헤더는 하나입니다.
바로 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;입니다! 🙂 이 헤더 값은 서버의
&lt;strong&gt;자원에 접근할 수 있는 출처&lt;/strong&gt;를 지정합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://mywebsite.com&lt;/code&gt;에서 접근할 서버를 개발 중인 경우
&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더에 해당 도메인을 추가할 수 있습니다!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/lydia/access-control-allow-origin.gif&#34; alt=&#34;access-control-allow-origin&#34;&gt;&lt;/p&gt;
&lt;p&gt;Awesome! 🎉 이제 서버가 클라이언트로 보내는 응답에 이 헤더가 추가됩니다.
그럼 &lt;code&gt;https://mywebsite.com&lt;/code&gt;에서 요청을 보내도 &lt;code&gt;https://api.mywebsite.com&lt;/code&gt;
&lt;strong&gt;자원을 가져가는 걸 같은 출처 정책이 더 이상 막지 않습니다&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/lydia/allowed-origins.gif&#34; alt=&#34;allowed-origins&#34;&gt;&lt;/p&gt;
&lt;p&gt;브라우저 내부 CORS 메커니즘은 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더 값이
요청할 때 보낸 &lt;code&gt;Origin&lt;/code&gt; 값과 동일한지 확인합니다. 🤚🏼&lt;/p&gt;
&lt;p&gt;이 경우 요청 출처는 &lt;code&gt;https://www.mywebsite.com&lt;/code&gt;으로
응답 헤더 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;에 실려 있습니다!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/lydia/response-header.gif&#34; alt=&#34;response-header&#34;&gt;&lt;/p&gt;
&lt;p&gt;Perfect! 🎉 다른 출처 자원을 성공적으로 받을 수 있습니다!
그러면 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더에 실려 있지 않은
출처에서 다른 출처 자원에 접근하려고 하면 어떻게 될까요? 🤔&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/lydia/cors-error.gif&#34; alt=&#34;cors-error&#34;&gt;&lt;/p&gt;
&lt;p&gt;맞아요. CORS는 때때로 악명 높은 에러를 던지죠!
하지만 우리는 이제 이것이 오히려 이치에 맞다는 것을 알게 되었습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;#39;Access-Control-Allow-Origin&amp;#39; 헤더 값이
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;제공된 출처(Origin)와 다른 &amp;#39;https://www.mywebsite.com&amp;#39;입니다.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이 경우에 제공된 출처는 &lt;code&gt;https://www.anotherwebsite.com&lt;/code&gt;입니다.
그러나 서버가 보낸 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더에는 해당 출처가
없습니다! CORS가 요청을 차단했고 우리의 코드는 가져온 데이터에 접근할
수 없습니다. 😃&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;또한 CORS를 사용하면 허용되는 Origin 값으로 와일드카드 &lt;code&gt;*&lt;/code&gt;를
추가할 수 있습니다. 이것은 모든 출처가 요청된 자원에
접근할 수 있다는 것이니 주의하세요!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;은 우리가 제공할 수 있는 수많은 CORS 헤더
중 하나입니다. 서버 개발자는 특정 요청을 허용하거나 차단하기 위해
CORS 정책을 수정할 수 있습니다! 💪🏼&lt;/p&gt;
&lt;p&gt;또 하나 자주 사용되는 헤더는 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;입니다!
CORS가 나열된 메서드들만 다른 출처 요청을 허용합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/lydia/access-control-allow-methods.gif&#34; alt=&#34;access-control-allow-methods&#34;&gt;&lt;/p&gt;
&lt;p&gt;이 경우 &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt; 메서드 요청만 허용됩니다!
&lt;code&gt;PATCH&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt;와 같은 다른 메서드들은 차단됩니다. ❌&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;다른 CORS 헤더는 무엇이 있으며 어떤 용도로 사용되는지 궁금하다면
&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#The_HTTP_response_headers&#34;&gt;이 목록을 확인해보세요&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CORS는 실제로 &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; 요청에 대해서는
다르게 처리합니다! 🙃 이렇게 &amp;ldquo;&lt;em&gt;단순하지 않은&lt;/em&gt;&amp;rdquo; 요청은
&lt;strong&gt;예비 요청&lt;/strong&gt; 이라는 것을 만듭니다!&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;-예비-요청-preflighted-requests&#34;&gt;🚀 예비 요청 (Preflighted Requests)&lt;/h1&gt;
&lt;p&gt;CORS에는 &lt;strong&gt;단순 요청&lt;/strong&gt;과 &lt;strong&gt;예비 요청&lt;/strong&gt;이라는 두 가지 요청이 있습니다.
요청이 단순 요청인지 예비 요청인지는 요청이 가진 일부 값에 따라
달라집니다(걱정하지 마세요. 이 내용을 외울 필요는 없습니다ㅋㅋㅋ).&lt;/p&gt;
&lt;p&gt;단순 요청은 &lt;code&gt;GET&lt;/code&gt; 또는 &lt;code&gt;POST&lt;/code&gt; 메서드이고 사용자 정의 헤더가 없는 경우입니다!
예비 요청은 &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 메서드와 같은 다른 모든 요청입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;단순 요청이 되기 위해 어떤 요구 사항을 충족해야 하는지 궁금하다면 MDN에
&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests&#34;&gt;유용한 목록&lt;/a&gt;이 있습니다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;알겠어요, 근데 &amp;ldquo;예비 요청&amp;quot;은 뭐고 왜 이런 일이 일어나는 건가요?&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;실제 요청을 전송하기 전에 클라이언트는 예비 요청을 생성합니다!
예비 요청에는 &lt;code&gt;Access-Control-Request-*&lt;/code&gt; 헤더에 실제로 보내려는
요청 정보가 포함되어 있습니다. 🔥&lt;/p&gt;
&lt;p&gt;이 헤더는 브라우저가 수행하려는 실제 요청 정보를 서버에 제공합니다.
여기에는 요청 &lt;strong&gt;메서드&lt;/strong&gt;, &lt;strong&gt;추가 헤더&lt;/strong&gt; 등이 포함됩니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/lydia/preflighted-request.gif&#34; alt=&#34;preflighted-request&#34;&gt;&lt;/p&gt;
&lt;p&gt;서버는 이 예비 요청을 수신하고 서버 CORS 헤더와 함께 텅 빈 HTTP 응답을 보냅니다!
브라우저는 CORS 헤더 외에 아무 데이터가 없는 예비 응답을 수신하고
해당 HTTP 요청이 허용되는지 여부를 확인합니다! ✅&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/lydia/preflighted-response.gif&#34; alt=&#34;preflighted-response&#34;&gt;&lt;/p&gt;
&lt;p&gt;이런 경우 브라우저가 실제 요청을 서버로 보내면
서버는 요청 받은 데이터를 응답합니다!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/lydia/actual-request.gif&#34; alt=&#34;actual-request&#34;&gt;&lt;/p&gt;
&lt;p&gt;하지만 허용되지 않을 경우에는 CORS가 예비 요청을 차단하고 실제 요청은
절대 보내지지 않습니다. ✋🏼 예비 요청은 아직 CORS 정책이 적용되지 않은 서버의
자원에 접근하거나 수정할 수 없도록 하는 좋은 방법입니다! 서버가 잠재적으로
원하지 않는 다른 출처 요청으로부터 보호됩니다.😃&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;💡 서버 통신 횟수를 줄이기 위해 CORS 요청에 &lt;code&gt;Access-Control-Max-Age&lt;/code&gt;
헤더를 추가하여 예비 요청에 대한 응답을 캐시할 수 있습니다!
그럼 브라우저는 새로운 예비 요청을 보내는 대신 캐시된 응답을
사용할 수 있습니다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;-자격-증명credentials&#34;&gt;🍪 자격 증명(Credentials)&lt;/h1&gt;
&lt;p&gt;쿠키, 인가 헤더, TLS 인증서는 기본적으로 같은 출처 요청에서만 설정됩니다!
그러나 이러한 자격 증명을 다른 출처 요청에 사용할 수도 있습니다.
서버가 사용자를 식별하기 위해 사용하는 쿠키를 요청에 포함시킬 수도 있습니다!&lt;/p&gt;
&lt;p&gt;기본적으로 CORS에 자격 증명이 포함되어 있지 않지만
CORS 헤더 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;를 추가할 수 있습니다! 🎉&lt;/p&gt;
&lt;p&gt;다른 출처 요청에 쿠키 및 기타 인가 헤더를 포함시키려면
요청에 &lt;code&gt;withCredentials&lt;/code&gt; 필드를 &lt;code&gt;true&lt;/code&gt;로 설정하고
응답에 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 헤더를 추가해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/lydia/access-control-allow-credentials.gif&#34; alt=&#34;access-control-allow-credentials&#34;&gt;&lt;/p&gt;
&lt;p&gt;준비 끝! 이제 우리는 다른 출처 요청에 자격 증명을 포함시킬 수 있습니다. 🥳&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;제가 생각하기엔 우리 모두 CORS 오류가 가끔 짜증나지만
브라우저에서 다른 출처 요청을 안전하게 해준다는 것은 놀라울 거에요.
(좀 더 많은 사랑을 받아야 합니다 ㅋㅋㅋ) ✨&lt;/p&gt;
&lt;p&gt;제가 이 블로그 포스트에서 다룰 수 있었던 것보다 더 많은 자료들이 있습니다!
더 궁금하다면 운 좋게도
&lt;a href=&#34;https://livebook.manning.com/book/cors-in-action/part-1/&#34;&gt;CORS in Action&lt;/a&gt;이나
&lt;a href=&#34;https://www.w3.org/wiki/CORS_Enabled&#34;&gt;W3 규격&lt;/a&gt;과 같은 좋은 자료들이 있습니다. 💪🏼&lt;/p&gt;
&lt;p&gt;그리고 언제나 그랬듯이 저(Lydia Hallie)와 소통해요! 😊&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;✨&lt;/th&gt;
          &lt;th&gt;👩🏽‍💻&lt;/th&gt;
          &lt;th&gt;💻&lt;/th&gt;
          &lt;th&gt;💡&lt;/th&gt;
          &lt;th&gt;📷&lt;/th&gt;
          &lt;th&gt;💌&lt;/th&gt;
          &lt;th&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://www.twitter.com/lydiahallie&#34;&gt;Twitter&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://www.instagram.com/theavocoder&#34;&gt;Instagram&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://www.github.com/lydiahallie&#34;&gt;GitHub&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://www.linkedin.com/in/lydia-hallie&#34;&gt;LinkedIn&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://www.youtube.com/channel/UC4EWKIKdKiDtAscQ9BIXwUw&#34;&gt;YouTube&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;mailto:lydiahallie.dev@gmail.com&#34;&gt;Email&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
- https://markruler.github.io/posts/web/cs-visualized-cors/ - Im Changsu | Since 2020</description>
        </item>
    
    
    
        <item>
        <title>Go로 밑바닥부터 만드는 BitTorrent 클라이언트</title>
        <link>https://markruler.github.io/posts/go/building-bittorrent-client/</link>
        <pubDate>Mon, 28 Dec 2020 14:46:00 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/go/building-bittorrent-client/</guid>
        <description>임창수 https://markruler.github.io/posts/go/building-bittorrent-client/ -&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.jse.li/posts/torrent/&#34;&gt;Jesse Li의 Building a BitTorrent client from the ground up in Go (2020-01-04)&lt;/a&gt;를 번역한 글입니다.&lt;/li&gt;
&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;거두절미(tl;dr):&lt;/strong&gt; The Pirate Bay를 방문하고 mp3 파일이 나타나기까지 무슨 일이 일어나는 것일까요?
이 글에서는 데비안(Debian)을 다운로드할 수 있을 정도의 비트토렌트 프로토콜을 구현할 것입니다.
바로 &lt;a href=&#34;https://github.com/veggiedefender/torrent-client/&#34;&gt;소스 코드&lt;/a&gt;를 보거나 &lt;a href=&#34;#%EB%AA%A8%EB%91%90-%ED%95%A9%EC%B9%98%EA%B8%B0&#34;&gt;마지막 부분&lt;/a&gt;으로 넘어갈 수 있습니다.&lt;/p&gt;
&lt;p&gt;비트토렌트(BitTorrent)는 인터넷을 통해 파일을 다운로드하고 배포하기 위한 프로토콜입니다.
다운로더가 중앙 서버와 연결하는 기존의 클라이언트/서버 관계 (예: 넷플릭스에서
영화를 보거나 지금 읽고 있는 웹 페이지를 불러 오는 것)와 달리,
&lt;strong&gt;피어(peer)&lt;/strong&gt; 라고 불리는 비트토렌트 네트워크 참여자들은 &lt;em&gt;서로에게서&lt;/em&gt; 파일 조각을 다운로드합니다.
이것이 &lt;strong&gt;P2P(peer-to-peer)&lt;/strong&gt; 프로토콜입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/go/bit-torrent/client-server-p2p.png&#34; alt=&#34;client-server-p2p&#34;&gt;&lt;/p&gt;
&lt;p&gt;이 프로토콜은 지난 20년 동안 진화했으며, 다양한 사람들과 조직들이 암호화(encryption),
비공개 토렌트(private torrent), 새로운 피어 탐색법과 같은 기능들을 추가했습니다.
우리는 주말에 구현할 수 있을 정도의 프로젝트 사이즈로 만들기 위해 &lt;a href=&#34;https://www.bittorrent.org/beps/bep_0003.html&#34;&gt;2001년 규격&lt;/a&gt;을 구현할 것입니다.&lt;/p&gt;
&lt;p&gt;저의 실험 재료로 적당한 350MB의 &lt;a href=&#34;https://cdimage.debian.org/debian-cd/current/amd64/bt-cd/#indexlist&#34;&gt;데비안 ISO&lt;/a&gt; 파일을 사용하겠습니다.
널리 사용되는 리눅스 배포판은 빠르고 협력적인 피어들이 많이 연결될 것입니다.
그리고 불법 복제 콘텐츠 다운로드와 관련된 법적, 윤리적 문제를 피할 수 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;피어-찾기&#34;&gt;피어 찾기&lt;/h1&gt;
&lt;p&gt;다음과 같은 문제가 있습니다. 우리는 비트토렌트로 파일을 다운로드하려고 하지만 P2P 프로토콜이고 파일을 다운로드할 피어를 찾을 수 없습니다.
이것은 마치 새로운 도시로 이사해서 친구를 사귀는 것과 같습니다. 어쩌면 우리가 동네 술집이나 밋업 그룹에 가는 것처럼요!
중앙 집중식 서버는 피어들이 서로를 알 수 있도록 알려주는 &lt;strong&gt;트래커(tracker)&lt;/strong&gt; 의 핵심입니다.
이들은 HTTP&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 웹 서버일 뿐이며, 데비안의 서버는 &lt;a href=&#34;http://bttracker.debian.org:6969/stat&#34;&gt;http://bttracker.debian.org:6969/stat&lt;/a&gt;에서 찾을 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/go/bit-torrent/trackers.png&#34; alt=&#34;trackers&#34;&gt;&lt;/p&gt;
&lt;p&gt;물론 이러한 중앙 서버는 피어들이 불법 컨텐츠를 교환할 수 있게 둔다면 정부의 단속을 받기 쉽습니다.
여러분은 불법 컨텐츠로 인해 폐쇄된 TorrentSpy, Popcorn Time, 그리고 KickassTorrents 와 같은 트래커에 대해 읽었을 수 있습니다.
오늘날에는 &lt;strong&gt;피어 탐색&lt;/strong&gt;도 분산 프로세스로 만들어 중간자를 생략했습니다 (역주: Trackerless Torrent).
우리가 이것까지 구현하지는 않지만 만약 관심이 있다면 &lt;strong&gt;DHT (Distributed Hash Table)&lt;/strong&gt;, &lt;strong&gt;PEX (Peer exchange)&lt;/strong&gt;, 그리고 &lt;strong&gt;자석 링크 (magnet link)&lt;/strong&gt; 같은 몇몇 용어들을 찾아보세요.&lt;/p&gt;
&lt;h2 id=&#34;torrent-파일-파싱-parsing-구문-분석&#34;&gt;.torrent 파일 파싱 (parsing: 구문 분석)&lt;/h2&gt;
&lt;p&gt;.torrent 파일에는 토렌트를 통해 다운로드할 수 있는(torrentable) 파일의 내용 및 트래커 연결에 대한 정보가 포함됩니다.
토렌트를 다운로드 하기 위해 필요한 것은 이것뿐입니다. 데비안의 .torrent 파일은 다음과 같습니다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;d8:announce41:http://bttracker.debian.org:6969/announce7:comment35:&amp;#34;Debian CD from cdimage.debian.org&amp;#34;13:creation datei1573903810e9:httpseedsl145:https://cdimage.debian.org/cdimage/release/10.2.0//srv/cdbuilder.debian.org/dst/deb-cd/weekly-builds/amd64/iso-cd/debian-10.2.0-amd64-netinst.iso145:https://cdimage.debian.org/cdimage/archive/10.2.0//srv/cdbuilder.debian.org/dst/deb-cd/weekly-builds/amd64/iso-cd/debian-10.2.0-amd64-netinst.isoe4:infod6:lengthi351272960e4:name31:debian-10.2.0-amd64-netinst.iso12:piece lengthi262144e6:pieces26800:�����PS�^�� (binary blob of the hashes of each piece)ee
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;B인코드(Bencode)&lt;/strong&gt; 형식으로 인코딩되어 있고, 우리는 이것을 디코딩해야 합니다.&lt;/p&gt;
&lt;p&gt;B인코드는 JSON과 거의 동일한 유형(문자열, 정수, 리스트 및 딕셔너리)의 구조로 인코딩할 수 있습니다.
B인코딩된 데이터는 JSON만큼 사람이 쉽게 읽고 쓸 수 있는 것은 아니지만 바이너리 데이터를 효율적으로
처리할 수 있으며 스트림에서 파싱하는 것이 매우 간단합니다.
문자열은 길이 접두사가 붙으며 &lt;code&gt;4:spam&lt;/code&gt;와 같이 나타냅니다.
정수는 마커로 시작하고 끝나기 때문에 &lt;code&gt;7&lt;/code&gt;의 경우 &lt;code&gt;i7e&lt;/code&gt;로 인코딩됩니다.
리스트와 딕셔너리는 비슷한 방식으로 인코딩됩니다. &lt;code&gt;l4:spami7ee&lt;/code&gt;는 &lt;code&gt;[&#39;spam&#39;, 7]&lt;/code&gt;을, &lt;code&gt;d4:spami7ee&lt;/code&gt;는 &lt;code&gt;{spam: 7}&lt;/code&gt;을 나타냅니다.&lt;/p&gt;
&lt;p&gt;.torrent 파일을 보기 쉽게 다듬으면 다음과 같습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;d
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f60&#34;&gt;8&lt;/span&gt;:announce
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f60&#34;&gt;41&lt;/span&gt;:http:&lt;span style=&#34;color:#0f0&#34;&gt;//bttracker.debian.org:6969/announce
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#f60&#34;&gt;7&lt;/span&gt;:comment
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f60&#34;&gt;35&lt;/span&gt;:&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;Debian CD from cdimage.debian.org&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f60&#34;&gt;13&lt;/span&gt;:creation date
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    i1573903810e
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f60&#34;&gt;4&lt;/span&gt;:info
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    d
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f60&#34;&gt;6&lt;/span&gt;:length
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        i351272960e
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f60&#34;&gt;4&lt;/span&gt;:name
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f60&#34;&gt;31&lt;/span&gt;:debian-&lt;span style=&#34;color:#f60&#34;&gt;10.2.0&lt;/span&gt;-amd64-netinst.iso
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f60&#34;&gt;12&lt;/span&gt;:piece length
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        i262144e
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f60&#34;&gt;6&lt;/span&gt;:pieces
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f60&#34;&gt;26800&lt;/span&gt;:�����PS�^�� (binary blob of the hashes of each piece)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    e
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;e
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이 파일에서는 트래커의 URL, 생성 날짜(유닉스 타임스탬프), 파일 이름 및 크기,
다운로드하려는 파일 &lt;strong&gt;조각&lt;/strong&gt; 의 SHA-1 해시가 들어 있는 큰 바이너리 블롭을 찾을 수 있습니다.
조각의 정확한 크기는 토렌트마다 다르지만 일반적으로 256KB에서 1MB 사이입니다.
이것은 큰 파일이 수천 개의 조각으로 구성될 수 있다는 것을 의미합니다.
피어들에게서 이 조각들을 다운로드해서 토렌트 파일에 있는 해시와 대조해 보고, 조립해 보고, 파일을 가지게 되는 겁니다!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/go/bit-torrent/pieces.png&#34; alt=&#34;pieces&#34;&gt;&lt;/p&gt;
&lt;p&gt;이 메커니즘을 통해 각 조각의 무결성을 검증할 수 있습니다.
비트토렌트는 이를 통해 우발적인 데이터 손상이나 의도적인 &lt;strong&gt;토렌트 포이즈닝&lt;/strong&gt;(&lt;a href=&#34;https://en.wikipedia.org/wiki/Torrent_poisoning&#34;&gt;torrent poisoning&lt;/a&gt;) 을 막을 수 있습니다.
공격자가 역상 공격(&lt;a href=&#34;https://en.wikipedia.org/wiki/Preimage_attack&#34;&gt;preimage attack&lt;/a&gt;)을 통해 SHA-1을 해독할 수 없다면, 우리는 요청한 컨텐츠를 정확하게 받을 수 있습니다.&lt;/p&gt;
&lt;p&gt;B인코드 파서를 만드는 것은 정말 재미있겠지만, 파싱은 이 글의 목적이 아닙니다.
이해하기 쉬운 Fredrik Lundh의 &lt;a href=&#34;https://effbot.org/zone/bencode.htm&#34;&gt;50줄짜리 파서&lt;/a&gt;를 찾았지만,
이 프로젝트에서는 &lt;a href=&#34;https://github.com/jackpal/bencode-go&#34;&gt;github.com/jackpal/bencode-go&lt;/a&gt; 을 사용했습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;github.com/jackpal/bencode-go&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;type&lt;/span&gt; bencodeInfo &lt;span style=&#34;color:#f00&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Pieces      &lt;span style=&#34;color:#ee82ee&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#87ceeb&#34;&gt;`bencode:&amp;#34;pieces&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PieceLength &lt;span style=&#34;color:#ee82ee&#34;&gt;int&lt;/span&gt;    &lt;span style=&#34;color:#87ceeb&#34;&gt;`bencode:&amp;#34;piece length&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Length      &lt;span style=&#34;color:#ee82ee&#34;&gt;int&lt;/span&gt;    &lt;span style=&#34;color:#87ceeb&#34;&gt;`bencode:&amp;#34;length&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Name        &lt;span style=&#34;color:#ee82ee&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#87ceeb&#34;&gt;`bencode:&amp;#34;name&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;type&lt;/span&gt; bencodeTorrent &lt;span style=&#34;color:#f00&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Announce &lt;span style=&#34;color:#ee82ee&#34;&gt;string&lt;/span&gt;      &lt;span style=&#34;color:#87ceeb&#34;&gt;`bencode:&amp;#34;announce&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Info     bencodeInfo &lt;span style=&#34;color:#87ceeb&#34;&gt;`bencode:&amp;#34;info&amp;#34;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// Open 토렌트 파일을 파싱합니다
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#ff0&#34;&gt;Open&lt;/span&gt;(r io.Reader) (*bencodeTorrent, &lt;span style=&#34;color:#ee82ee&#34;&gt;error&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  bto := bencodeTorrent{}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  err := bencode.&lt;span style=&#34;color:#ff0&#34;&gt;Unmarshal&lt;/span&gt;(r, &amp;amp;bto)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt;, err
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; &amp;amp;bto, &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/veggiedefender/torrent-client/blob/2bde944888e1195e81cc5d5b686f6ec3a9f08c25/torrentfile/torrentfile.go&#34;&gt;github.com/veggiedefender/torrent-client/torrentfile/torrentfile.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;저는 구조체를 상대적으로 평평하게 유지하는 것을 좋아하고
애플리케이션 구조체를 직렬화 구조체와 분리하는 것을 좋아하기 때문에
&lt;code&gt;TorrentFile&lt;/code&gt;이라는 다른 평탄한 구조체를 내보내고
두 구조체 사이에서 변환할 몇 가지 헬퍼 함수를 작성했습니다.&lt;/p&gt;
&lt;p&gt;특히 각각의 해시에 쉽게 접근할 수 있도록 &lt;code&gt;조각&lt;/code&gt;(이전의 문자열)을 해시 조각(각각 &lt;code&gt;[20]byte&lt;/code&gt;)으로 분할합니다.
또한 (이름, 크기, 조각 해시를 포함한) B인코딩된 &lt;code&gt;info&lt;/code&gt; 딕셔너리의 SHA-1 해시를 계산했습니다.
이것을 &lt;strong&gt;infohash&lt;/strong&gt;라고 하며 트래커 및 피어와 통신할 때 파일 식별자 역할을 합니다.
이에 대해서는 나중에 더 살펴보겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/go/bit-torrent/info-hash.png&#34; alt=&#34;info-hash&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;type&lt;/span&gt; TorrentFile &lt;span style=&#34;color:#f00&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Announce    &lt;span style=&#34;color:#ee82ee&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  InfoHash    [&lt;span style=&#34;color:#f60&#34;&gt;20&lt;/span&gt;]&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PieceHashes [][&lt;span style=&#34;color:#f60&#34;&gt;20&lt;/span&gt;]&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PieceLength &lt;span style=&#34;color:#ee82ee&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Length      &lt;span style=&#34;color:#ee82ee&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Name        &lt;span style=&#34;color:#ee82ee&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;func&lt;/span&gt; (bto bencodeTorrent) &lt;span style=&#34;color:#ff0&#34;&gt;toTorrentFile&lt;/span&gt;() (TorrentFile, &lt;span style=&#34;color:#ee82ee&#34;&gt;error&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0f0&#34;&gt;// …
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/veggiedefender/torrent-client/blob/2bde944888e1195e81cc5d5b686f6ec3a9f08c25/torrentfile/torrentfile.go#L120-L138&#34;&gt;github.com/veggiedefender/torrent-client/torrentfile/torrentfile.go#L120-L138&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;트래커로부터-피어-찾기&#34;&gt;트래커로부터 피어 찾기&lt;/h2&gt;
&lt;p&gt;이제 파일과 트래커에 대해 알았으니 트래커와 통신하여 피어로서의 존재를 &lt;strong&gt;알리고&lt;/strong&gt; 다른 피어들의 목록을 검색해 보겠습니다.
.torrent 파일에 제공된 &amp;lsquo;announce&amp;rsquo; URL에 몇 가지 쿼리 파라미터와 함께 GET 요청을 하면 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;func&lt;/span&gt; (t *TorrentFile) &lt;span style=&#34;color:#ff0&#34;&gt;buildTrackerURL&lt;/span&gt;(peerID [&lt;span style=&#34;color:#f60&#34;&gt;20&lt;/span&gt;]&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;, port &lt;span style=&#34;color:#ee82ee&#34;&gt;uint16&lt;/span&gt;) (&lt;span style=&#34;color:#ee82ee&#34;&gt;string&lt;/span&gt;, &lt;span style=&#34;color:#ee82ee&#34;&gt;error&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  base, err := url.&lt;span style=&#34;color:#ff0&#34;&gt;Parse&lt;/span&gt;(t.Announce)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, err
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  params := url.Values{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;info_hash&amp;#34;&lt;/span&gt;:  []&lt;span style=&#34;color:#ee82ee&#34;&gt;string&lt;/span&gt;{string(t.InfoHash[:])},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;peer_id&amp;#34;&lt;/span&gt;:    []&lt;span style=&#34;color:#ee82ee&#34;&gt;string&lt;/span&gt;{string(peerID[:])},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;port&amp;#34;&lt;/span&gt;:       []&lt;span style=&#34;color:#ee82ee&#34;&gt;string&lt;/span&gt;{strconv.&lt;span style=&#34;color:#ff0&#34;&gt;Itoa&lt;/span&gt;(int(Port))},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;uploaded&amp;#34;&lt;/span&gt;:   []&lt;span style=&#34;color:#ee82ee&#34;&gt;string&lt;/span&gt;{&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;downloaded&amp;#34;&lt;/span&gt;: []&lt;span style=&#34;color:#ee82ee&#34;&gt;string&lt;/span&gt;{&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;compact&amp;#34;&lt;/span&gt;:    []&lt;span style=&#34;color:#ee82ee&#34;&gt;string&lt;/span&gt;{&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;left&amp;#34;&lt;/span&gt;:       []&lt;span style=&#34;color:#ee82ee&#34;&gt;string&lt;/span&gt;{strconv.&lt;span style=&#34;color:#ff0&#34;&gt;Itoa&lt;/span&gt;(t.Length)},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  base.RawQuery = params.&lt;span style=&#34;color:#ff0&#34;&gt;Encode&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; base.&lt;span style=&#34;color:#ff0&#34;&gt;String&lt;/span&gt;(), &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/veggiedefender/torrent-client/blob/2bde944888e1195e81cc5d5b686f6ec3a9f08c25/torrentfile/tracker.go#L19-L35&#34;&gt;github.com/veggiedefender/torrent-client/torrentfile/tracker.go#L19-L35&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여기서 중요한 것은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;info_hash&lt;/strong&gt;: 다운로드하려는 파일을 식별합니다. 이것은 우리가 B인코딩된 &lt;code&gt;info&lt;/code&gt; 딕셔너리에서 계산한 infohash입니다. 트래커는 이를 사용하여 어떤 피어를 보여줄지 결정합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;peer_id&lt;/strong&gt;: 트래커와 피어들에게 &lt;code&gt;우리&lt;/code&gt;를 식별시키기 위한 20바이트 이름입니다. 이를 위해 20개의 랜덤 바이트를 생성합니다. 실제 비트토렌트 클라이언트는 클라이언트 소프트웨어와 버전을 식별하는 &lt;code&gt;-TR2940-k8hj0wgej6ch&lt;/code&gt;와 같은 ID를 가지고 있습니다. 여기서 TR2940은 전송 클라이언트 2.94를 의미합니다. &lt;a href=&#34;https://www.bittorrent.org/beps/bep_0020.html&#34;&gt;(Peer ID Conventions)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/go/bit-torrent/info-hash-peer-id.png&#34; alt=&#34;info-hash-peer-id&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;트래커-응답-분석&#34;&gt;트래커 응답 분석&lt;/h2&gt;
&lt;p&gt;다음과 같이 B인코딩된 응답을 받았습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;d
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f60&#34;&gt;8&lt;/span&gt;:interval
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    i900e
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f60&#34;&gt;5&lt;/span&gt;:peers
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f60&#34;&gt;252&lt;/span&gt;:(another &lt;span style=&#34;color:#ee82ee&#34;&gt;long&lt;/span&gt; binary blob)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;e
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Interval&lt;/code&gt;은 얼마나 자주 트래커에 다시 연결하여 피어 목록을 새로 고쳐야 하는지 알려줍니다.
900이라는 값은 15분(900초)마다 다시 연결해야 함을 의미합니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Peers&lt;/code&gt;는 각 피어의 IP 주소를 포함하는 또 다른 긴 바이너리 블롭입니다.
&lt;code&gt;6바이트의 그룹들&lt;/code&gt;로 이루어져 있습니다.
각 그룹의 처음 4바이트는 피어의 IP 주소를 나타냅니다. 각 1 바이트는 IP 숫자를 나타냅니다.
마지막 2바이트는 포트 번호를 빅-엔디안 &lt;code&gt;uint16&lt;/code&gt;으로 나타냅니다.
&lt;strong&gt;빅-엔디안&lt;/strong&gt; 또는 &lt;strong&gt;네트워크 바이트 순서&lt;/strong&gt;&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;는 바이트 그룹을 왼쪽부터 담아 정수로 해석하는 것을 말합니다.
예를 들어 &lt;code&gt;0x1A&lt;/code&gt;, &lt;code&gt;0xE1&lt;/code&gt; 바이트는 &lt;code&gt;0x1AE1&lt;/code&gt; 또는 십진수로 6881을 만듭니다.&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/go/bit-torrent/address.png&#34; alt=&#34;address&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// Peer 피어의 연결 정보를 인코딩합니다
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;type&lt;/span&gt; Peer &lt;span style=&#34;color:#f00&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  IP   net.IP
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Port &lt;span style=&#34;color:#ee82ee&#34;&gt;uint16&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// Unmarshal 버퍼에서 피어의 IP 주소와 포트 번호를 파싱합니다
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#ff0&#34;&gt;Unmarshal&lt;/span&gt;(peersBin []&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;) ([]Peer, &lt;span style=&#34;color:#ee82ee&#34;&gt;error&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;const&lt;/span&gt; peerSize = &lt;span style=&#34;color:#f60&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#0f0&#34;&gt;// 4 for IP, 2 for port
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;  numPeers := len(peersBin) / peerSize
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; len(peersBin)%peerSize != &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    err := fmt.&lt;span style=&#34;color:#ff0&#34;&gt;Errorf&lt;/span&gt;(&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;Received malformed peers&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt;, err
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  peers := make([]Peer, numPeers)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;for&lt;/span&gt; i := &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;; i &amp;lt; numPeers; i++ {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    offset := i * peerSize
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    peers[i].IP = net.&lt;span style=&#34;color:#ff0&#34;&gt;IP&lt;/span&gt;(peersBin[offset : offset+&lt;span style=&#34;color:#f60&#34;&gt;4&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    peers[i].Port = binary.BigEndian.&lt;span style=&#34;color:#ff0&#34;&gt;Uint16&lt;/span&gt;(peersBin[offset+&lt;span style=&#34;color:#f60&#34;&gt;4&lt;/span&gt; : offset+&lt;span style=&#34;color:#f60&#34;&gt;6&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; peers, &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/veggiedefender/torrent-client/blob/2bde944888e1195e81cc5d5b686f6ec3a9f08c25/peers/peers.go&#34;&gt;github.com/veggiedefender/torrent-client/peers/peers.go&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;피어로부터-다운로드하기&#34;&gt;피어로부터 다운로드하기&lt;/h1&gt;
&lt;p&gt;이제 피어 목록이 있습니다.
피어와 연결하여 조각을 다운로드할 시간입니다!
우리는 이 과정을 몇 단계로 나눌 수 있습니다.
각 피어에 대해 다음을 수행하고자 합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;피어와 TCP 연결을 시작합니다. 이것은 전화를 거는 것과 같습니다.&lt;/li&gt;
&lt;li&gt;양방향 비트토렌트 &lt;strong&gt;핸드셰이크&lt;/strong&gt;를 완료합니다.. &lt;em&gt;&amp;ldquo;안녕?&amp;rdquo; &amp;ldquo;안녕.&amp;rdquo;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;조각&lt;/strong&gt;을 다운로드 하기 위해 &lt;strong&gt;메시지&lt;/strong&gt;를 교환합니다. &lt;em&gt;&amp;ldquo;231번 조각 주세요.&amp;rdquo;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;tcp-연결&#34;&gt;TCP 연결&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;conn, err := net.&lt;span style=&#34;color:#ff0&#34;&gt;DialTimeout&lt;/span&gt;(&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;tcp&amp;#34;&lt;/span&gt;, peer.&lt;span style=&#34;color:#ff0&#34;&gt;String&lt;/span&gt;(), &lt;span style=&#34;color:#f60&#34;&gt;3&lt;/span&gt;*time.Second)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt;, err
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/veggiedefender/torrent-client/blob/2bde944888e1195e81cc5d5b686f6ec3a9f08c25/client/client.go#L65-L69&#34;&gt;github.com/veggiedefender/torrent-client/client/client.go#L65-L69&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;연결할 수 없는 피어에 너무 많은 시간을 낭비하지 않도록 시간 제한을 설정했습니다.
대부분의 경우 표준 TCP 연결입니다.&lt;/p&gt;
&lt;h2 id=&#34;핸드셰이크-완료&#34;&gt;핸드셰이크 완료&lt;/h2&gt;
&lt;p&gt;피어와의 연결을 설정했지만 다음과 같은 가정을 검증하기 위해 핸드셰이크를 수행하려고 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;피어는 비트토렌트 프로토콜을 사용하여 통신할 수 있습니다.&lt;/li&gt;
&lt;li&gt;피어는 우리의 메시지를 이해하고 응답할 수 있습니다.&lt;/li&gt;
&lt;li&gt;피어는 우리가 원하는 파일을 가지고 있거나 적어도 우리가 무엇을 말하고 있는지 알고 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/go/bit-torrent/handshake.png&#34; alt=&#34;handshake&#34;&gt;&lt;/p&gt;
&lt;p&gt;아버지는 제게 악수(handshake)를 잘 하는 비결은 손을 단단히 잡고 눈을 마주치는 것이라고 말씀하셨습니다.
좋은 비트토렌트 핸드셰이크의 비결은 다음과 같이 다섯 부분으로 구성됩니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;항상 19로 지정된 프로토콜 식별자의 길이. (16진수로는 0x13)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pstr&lt;/strong&gt;이라 불리는 프로토콜 식별자는 항상 &lt;code&gt;BitTorrent protocol&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;모두 0으로 지정된 &lt;strong&gt;8개의 예약된 바이트&lt;/strong&gt;. 그 중 일부를 1로 뒤집어서 특정 &lt;a href=&#34;http://www.bittorrent.org/beps/bep_0010.html&#34;&gt;확장 기능&lt;/a&gt;을 지원한다는 것을 나타냅니다. 하지만 지금은 그렇지 않으니 0으로 유지하겠습니다.&lt;/li&gt;
&lt;li&gt;우리가 원하는 파일을 식별할 앞서 계산한 &lt;strong&gt;infohash&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;우리 스스로를 식별하기 위해 만든 &lt;strong&gt;Peer ID&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;합치면 핸드셰이크 문자열은 다음과 같이 보일 수 있습니다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;\x13BitTorrent protocol\x00\x00\x00\x00\x00\x00\x00\x00\x86\xd4\xc8\x00\x24\xa4\x69\xbe\x4c\x50\xbc\x5a\x10\x2c\xf7\x17\x80\x31\x00\x74-TR2940-k8hj0wgej6ch
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;피어에게 핸드셰이크를 보낸 후 동일한 형식으로 핸드셰이크를 다시 받아야 합니다.
받은 infohash는 보낸 정보와 일치해야 동일한 파일에 대해 말하고 있다는 것을 알 수 있습니다.
모든 일이 계획대로 진행되면 다음 단계로 넘어갑니다.
그렇지 않다면 뭔가 잘못되었기 때문에 연결을 끊을 수 있습니다.
&lt;em&gt;&amp;ldquo;안녕?&amp;rdquo; &amp;ldquo;这是谁？ 你想要什么？&amp;rdquo; &amp;ldquo;알았어요, 와&amp;hellip;잘못 걸었어요..&amp;rdquo;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;코드에서 핸드셰이크를 나타내는 구조체를 만들고, 이것을 직렬화하고 읽는 몇 가지 메소드를 작성하겠습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// Handshake 피어가 자신을 식별하는 데 사용하는 특별한 메시지입니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;type&lt;/span&gt; Handshake &lt;span style=&#34;color:#f00&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Pstr     &lt;span style=&#34;color:#ee82ee&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  InfoHash [&lt;span style=&#34;color:#f60&#34;&gt;20&lt;/span&gt;]&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  PeerID   [&lt;span style=&#34;color:#f60&#34;&gt;20&lt;/span&gt;]&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// Serialize 핸드셰이크를 버퍼에 직렬화합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;func&lt;/span&gt; (h *Handshake) &lt;span style=&#34;color:#ff0&#34;&gt;Serialize&lt;/span&gt;() []&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  buf := make([]&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;, len(h.Pstr)+&lt;span style=&#34;color:#f60&#34;&gt;49&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  buf[&lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;] = byte(len(h.Pstr))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  curr := &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  curr += copy(buf[curr:], h.Pstr)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  curr += copy(buf[curr:], make([]&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;, &lt;span style=&#34;color:#f60&#34;&gt;8&lt;/span&gt;)) &lt;span style=&#34;color:#0f0&#34;&gt;// 8 reserved bytes
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;  curr += copy(buf[curr:], h.InfoHash[:])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  curr += copy(buf[curr:], h.PeerID[:])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; buf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// Read 스트림에서 핸드셰이크를 파싱합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#ff0&#34;&gt;Read&lt;/span&gt;(r io.Reader) (*Handshake, &lt;span style=&#34;color:#ee82ee&#34;&gt;error&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0f0&#34;&gt;// 역직렬화 수행
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#0f0&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/veggiedefender/torrent-client/blob/a83013d250dd9b4268cceace28e4cd82b07f2cbd/handshake/handshake.go&#34;&gt;github.com/veggiedefender/torrent-client/handshake/handshake.go&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;메시지-주고-받기&#34;&gt;메시지 주고 받기&lt;/h2&gt;
&lt;p&gt;첫 핸드셰이크를 마치면 &lt;code&gt;메시지&lt;/code&gt;를 주고받을 수 있습니다.
하지만 나머지 피어들이 메시지를 받아들일 준비가 안 되어 있다면,
모두가 준비가 되었다고 말하기 전에는 보낼 수 없습니다.
이 상태에서는 나머지 피어들에게 &lt;code&gt;chocked&lt;/code&gt;를 당합니다.
그들은 우리가 데이터를 요청해도 된다는 것을 알리기 위해 &lt;code&gt;unchoke&lt;/code&gt; 메시지를 보낼 것입니다.
기본적으로 우리는 입증될 때까지 막힌다고 가정합니다.&lt;/p&gt;
&lt;p&gt;unchoke 메시지를 받으면 우리는 조각에 대한 &lt;code&gt;요청&lt;/code&gt;을 보낼 수 있고,
피어들은 조각이 담긴 메시지를 우리에게 보낼 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/go/bit-torrent/choke.png&#34; alt=&#34;choke&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;메시지-해석&#34;&gt;메시지 해석&lt;/h3&gt;
&lt;p&gt;메시지는 길이, &lt;code&gt;ID&lt;/code&gt;, &lt;code&gt;페이로드(payload)&lt;/code&gt;를 가집니다. 이것은 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/go/bit-torrent/message.png&#34; alt=&#34;message&#34;&gt;&lt;/p&gt;
&lt;p&gt;메시지는 메시지의 바이트 길이를 알려주는 길이 표시로 시작합니다.
32비트 정수이므로 빅-엔디안 순서의 4바이트로 압축할 수 있습니다.
다음 바이트인 &lt;strong&gt;ID&lt;/strong&gt;는 어떤 유형의 메시지를 수신하는지 알려줍니다.
예를 들어 &lt;code&gt;2&lt;/code&gt;바이트는 &amp;ldquo;관심있음(interested)&amp;ldquo;을 의미합니다.
마지막으로 선택값인 &lt;strong&gt;페이로드(payload)&lt;/strong&gt; 는 메시지의 남은 길이를 채웁니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;type&lt;/span&gt; messageID &lt;span style=&#34;color:#ee82ee&#34;&gt;uint8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;const&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  MsgChoke         messageID = &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  MsgUnchoke       messageID = &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  MsgInterested    messageID = &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  MsgNotInterested messageID = &lt;span style=&#34;color:#f60&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  MsgHave          messageID = &lt;span style=&#34;color:#f60&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  MsgBitfield      messageID = &lt;span style=&#34;color:#f60&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  MsgRequest       messageID = &lt;span style=&#34;color:#f60&#34;&gt;6&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  MsgPiece         messageID = &lt;span style=&#34;color:#f60&#34;&gt;7&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  MsgCancel        messageID = &lt;span style=&#34;color:#f60&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// Message 메시지의 ID 및 페이로드를 저장합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;type&lt;/span&gt; Message &lt;span style=&#34;color:#f00&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ID      messageID
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Payload []&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// Serialize 메시지를 다음과 같은 형식으로 버퍼에 직렬화합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// &amp;lt;길이 접두사&amp;gt;&amp;lt;메시지 ID&amp;gt;&amp;lt;페이로드&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// `nil`은 keep-live 메시지로 해석합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;func&lt;/span&gt; (m *Message) &lt;span style=&#34;color:#ff0&#34;&gt;Serialize&lt;/span&gt;() []&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; m == &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; make([]&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;, &lt;span style=&#34;color:#f60&#34;&gt;4&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  length := uint32(len(m.Payload) + &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#0f0&#34;&gt;// +1 for id
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;  buf := make([]&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;, &lt;span style=&#34;color:#f60&#34;&gt;4&lt;/span&gt;+length)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  binary.BigEndian.&lt;span style=&#34;color:#ff0&#34;&gt;PutUint32&lt;/span&gt;(buf[&lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#f60&#34;&gt;4&lt;/span&gt;], length)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  buf[&lt;span style=&#34;color:#f60&#34;&gt;4&lt;/span&gt;] = byte(m.ID)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  copy(buf[&lt;span style=&#34;color:#f60&#34;&gt;5&lt;/span&gt;:], m.Payload)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; buf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/veggiedefender/torrent-client/blob/2bde944888e1195e81cc5d5b686f6ec3a9f08c25/message/message.go#L90-L103&#34;&gt;github.com/veggiedefender/torrent-client/message/message.go#L90-L103&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;스트림에서 메시지를 읽으려면 해당 메시지 형식을 따릅니다.
우리는 4바이트를 읽고 메시지의 &lt;strong&gt;길이&lt;/strong&gt;를 얻기 위해 &lt;code&gt;uint32&lt;/code&gt;로 해석합니다.
그런 다음 &lt;strong&gt;ID&lt;/strong&gt;(처음 1바이트) 및 &lt;strong&gt;payload&lt;/strong&gt;(나머지 바이트)를 얻습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// Read 스트림에서 메시지를 파싱합니다. keep-alive 메시지는 `nil`을 반환합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#ff0&#34;&gt;Read&lt;/span&gt;(r io.Reader) (*Message, &lt;span style=&#34;color:#ee82ee&#34;&gt;error&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lengthBuf := make([]&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;, &lt;span style=&#34;color:#f60&#34;&gt;4&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  _, err := io.&lt;span style=&#34;color:#ff0&#34;&gt;ReadFull&lt;/span&gt;(r, lengthBuf)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt;, err
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  length := binary.BigEndian.&lt;span style=&#34;color:#ff0&#34;&gt;Uint32&lt;/span&gt;(lengthBuf)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0f0&#34;&gt;// keep-alive 메시지
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; length == &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  messageBuf := make([]&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;, length)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  _, err = io.&lt;span style=&#34;color:#ff0&#34;&gt;ReadFull&lt;/span&gt;(r, messageBuf)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt;, err
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  m := Message{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ID:      &lt;span style=&#34;color:#ff0&#34;&gt;messageID&lt;/span&gt;(messageBuf[&lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;]),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Payload: messageBuf[&lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;:],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; &amp;amp;m, &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/veggiedefender/torrent-client/blob/2bde944888e1195e81cc5d5b686f6ec3a9f08c25/message/message.go#L105-L131&#34;&gt;github.com/veggiedefender/torrent-client/message/message.go#L105-L131&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;비트-필드-bitfields&#34;&gt;비트 필드 (Bitfields)&lt;/h3&gt;
&lt;p&gt;가장 흥미로운 유형의 메시지 중 하나는 &lt;strong&gt;비트 필드(bitfield)&lt;/strong&gt; 입니다.
이 자료 구조는 피어들이 우리에게 보낼 수 있는 조각을 효율적으로 인코딩하는 데 사용됩니다.
비트필드는 바이트 배열처럼 생겼고, 어떤 조각을 가지고 있는지 확인하기 위해서는 단지 1로 설정된 &lt;em&gt;비트&lt;/em&gt;의 위치를 보면 됩니다.
이것을 커피숍 쿠폰에 비유할 수 있습니다.
비트가 전부 &lt;code&gt;0&lt;/code&gt;인 카드부터 시작해서 하나씩 &lt;code&gt;1&lt;/code&gt;로 바꿔서 &amp;ldquo;도장&amp;rdquo; 찍듯이 표시합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/go/bit-torrent/bitfield.png&#34; alt=&#34;bitfield&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;바이트&lt;/em&gt; 대신 &lt;em&gt;비트&lt;/em&gt;로 작업해서 비트필드 자료 구조는 크기가 매우 작습니다.
한 바이트의 공간에 8개의 조각 정보(&lt;code&gt;bool&lt;/code&gt; 크기)를 채워 넣을 수 있습니다.
단점은 값에 접근하는 것이 좀 더 까다로워진다는 것입니다.
컴퓨터가 처리할 수 있는 가장 작은 메모리 단위는 바이트입니다.
따라서 비트에 접근하려면 몇 가지 비트 조작(bitwise manipulation)을 수행해야 합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// Bitfield 피어가 가지고 있는 조각들을 나타냅니다
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;type&lt;/span&gt; Bitfield []&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// HasPiece 특정 인덱스를 가진 비트 필드가 설정되어 있는지 알려줍니다
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;func&lt;/span&gt; (bf Bitfield) &lt;span style=&#34;color:#ff0&#34;&gt;HasPiece&lt;/span&gt;(index &lt;span style=&#34;color:#ee82ee&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#ee82ee&#34;&gt;bool&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  byteIndex := index / &lt;span style=&#34;color:#f60&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  offset := index % &lt;span style=&#34;color:#f60&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; bf[byteIndex]&amp;gt;&amp;gt;(&lt;span style=&#34;color:#f60&#34;&gt;7&lt;/span&gt;-offset)&amp;amp;&lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt; != &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// SetPiece 비트 필드에 비트를 설정합니다
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;func&lt;/span&gt; (bf Bitfield) &lt;span style=&#34;color:#ff0&#34;&gt;SetPiece&lt;/span&gt;(index &lt;span style=&#34;color:#ee82ee&#34;&gt;int&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  byteIndex := index / &lt;span style=&#34;color:#f60&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  offset := index % &lt;span style=&#34;color:#f60&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  bf[byteIndex] |= &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; (&lt;span style=&#34;color:#f60&#34;&gt;7&lt;/span&gt; - offset)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/veggiedefender/torrent-client/blob/2bde944888e1195e81cc5d5b686f6ec3a9f08c25/bitfield/bitfield.go&#34;&gt;github.com/veggiedefender/torrent-client/bitfield/bitfield.go&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;모두-합치기&#34;&gt;모두 합치기&lt;/h2&gt;
&lt;p&gt;이제 토렌트를 다운로드하는 데 필요한 모든 도구를 확보했습니다.
트래커에서 얻은 피어 목록이 있으며, TCP로 연결하고 핸드셰이크를 하며,
메시지를 주고받음으로써 피어들과 통신할 수 있습니다.
마지막 큰 문제는 여러 피어와 동시에 통신하는 &lt;strong&gt;동시성(concurrency)&lt;/strong&gt; 을 처리하고
상호 작용하는 피어들의 &lt;strong&gt;상태&lt;/strong&gt;를 관리하는 것입니다.
둘 다 고전적으로 어려운 문제입니다.&lt;/p&gt;
&lt;h3 id=&#34;동시성-관리-채널channel을-큐queue로&#34;&gt;동시성 관리: 채널(channel)을 큐(queue)로&lt;/h3&gt;
&lt;p&gt;Go에서는 &lt;a href=&#34;https://blog.golang.org/share-memory-by-communicating&#34;&gt;통신을 통해 메모리를 공유&lt;/a&gt;하며
Go 채널을 비용이 적은 스레드-세이프 큐라고 생각할 수 있습니다.&lt;/p&gt;
&lt;p&gt;두 채널을 설정하여 동시적인 작업자들(concurrent workers)을 동기화합니다.
하나는 피어 간에 작업(다운로드할 조각)을 분배하기 위한 채널이고,
다른 하나는 다운로드한 조각들을 모으기 위한 채널입니다.
다운로드된 조각들이 결과 채널을 통해 들어올 때,
우리는 그것들을 버퍼에 복사해서 완전한 파일로 조립할 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// 작업자가 작업을 찾고 결과를 보낼 수 있도록 큐를 초기화합니다
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;workQueue := make(&lt;span style=&#34;color:#f00&#34;&gt;chan&lt;/span&gt; *pieceWork, len(t.PieceHashes))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;results := make(&lt;span style=&#34;color:#f00&#34;&gt;chan&lt;/span&gt; *pieceResult)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;for&lt;/span&gt; index, hash := &lt;span style=&#34;color:#f00&#34;&gt;range&lt;/span&gt; t.PieceHashes {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  length := t.&lt;span style=&#34;color:#ff0&#34;&gt;calculatePieceSize&lt;/span&gt;(index)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  workQueue &amp;lt;- &amp;amp;pieceWork{index, hash, length}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// 작업을 시작합니다
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;for&lt;/span&gt; _, peer := &lt;span style=&#34;color:#f00&#34;&gt;range&lt;/span&gt; t.Peers {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;go&lt;/span&gt; t.&lt;span style=&#34;color:#ff0&#34;&gt;startDownloadWorker&lt;/span&gt;(peer, workQueue, results)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// 결과가 가득 찰 때까지 버퍼로 결과를 수집합니다
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;buf := make([]&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;, t.Length)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;donePieces := &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;for&lt;/span&gt; donePieces &amp;lt; len(t.PieceHashes) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  res := &amp;lt;-results
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  begin, end := t.&lt;span style=&#34;color:#ff0&#34;&gt;calculateBoundsForPiece&lt;/span&gt;(res.index)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  copy(buf[begin:end], res.buf)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  donePieces++
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;close(workQueue)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/veggiedefender/torrent-client/blob/2bde944888e1195e81cc5d5b686f6ec3a9f08c25/p2p/p2p.go#L188-L214&#34;&gt;github.com/veggiedefender/torrent-client/p2p/p2p.go#L188-L214&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;트래커에서 받은 피어마다 작업자 고루틴을 생성합니다.
피어와 연결하고 핸드셰이크한 다음 &lt;code&gt;workQueue&lt;/code&gt;에서 작업을 검색하여 다운로드를 시도하고,
&lt;code&gt;results&lt;/code&gt; 채널을 통해 다운로드한 조각들을 다시 보냅니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/go/bit-torrent/download.png&#34; alt=&#34;download&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;func&lt;/span&gt; (t *Torrent) &lt;span style=&#34;color:#ff0&#34;&gt;startDownloadWorker&lt;/span&gt;(peer peers.Peer, workQueue &lt;span style=&#34;color:#f00&#34;&gt;chan&lt;/span&gt; *pieceWork, results &lt;span style=&#34;color:#f00&#34;&gt;chan&lt;/span&gt; *pieceResult) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  c, err := client.&lt;span style=&#34;color:#ff0&#34;&gt;New&lt;/span&gt;(peer, t.PeerID, t.InfoHash)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    log.&lt;span style=&#34;color:#ff0&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;Could not handshake with %s. Disconnecting\n&amp;#34;&lt;/span&gt;, peer.IP)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;defer&lt;/span&gt; c.Conn.&lt;span style=&#34;color:#ff0&#34;&gt;Close&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  log.&lt;span style=&#34;color:#ff0&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;Completed handshake with %s\n&amp;#34;&lt;/span&gt;, peer.IP)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  c.&lt;span style=&#34;color:#ff0&#34;&gt;SendUnchoke&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  c.&lt;span style=&#34;color:#ff0&#34;&gt;SendInterested&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;for&lt;/span&gt; pw := &lt;span style=&#34;color:#f00&#34;&gt;range&lt;/span&gt; workQueue {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; !c.Bitfield.&lt;span style=&#34;color:#ff0&#34;&gt;HasPiece&lt;/span&gt;(pw.index) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      workQueue &amp;lt;- pw &lt;span style=&#34;color:#0f0&#34;&gt;// 큐에 조각을 다시 넣습니다
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#f00&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0f0&#34;&gt;// 조각 다운로드
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;    buf, err := &lt;span style=&#34;color:#ff0&#34;&gt;attemptDownloadPiece&lt;/span&gt;(c, pw)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      log.&lt;span style=&#34;color:#ff0&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;Exiting&amp;#34;&lt;/span&gt;, err)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      workQueue &amp;lt;- pw &lt;span style=&#34;color:#0f0&#34;&gt;// 큐에 조각을 다시 넣습니다
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    err = &lt;span style=&#34;color:#ff0&#34;&gt;checkIntegrity&lt;/span&gt;(pw, buf)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      log.&lt;span style=&#34;color:#ff0&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;Piece #%d failed integrity check\n&amp;#34;&lt;/span&gt;, pw.index)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      workQueue &amp;lt;- pw &lt;span style=&#34;color:#0f0&#34;&gt;// 큐에 조각을 다시 넣습니다
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#f00&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    c.&lt;span style=&#34;color:#ff0&#34;&gt;SendHave&lt;/span&gt;(pw.index)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    results &amp;lt;- &amp;amp;pieceResult{pw.index, buf}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/veggiedefender/torrent-client/blob/2bde944888e1195e81cc5d5b686f6ec3a9f08c25/p2p/p2p.go#L133-L169&#34;&gt;github.com/veggiedefender/torrent-client/p2p/p2p.go#L133-L169&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;상태-관리&#34;&gt;상태 관리&lt;/h3&gt;
&lt;p&gt;구조체에 있는 각 피어들을 추적하고 메시지를 읽을 때 해당 구조체의 필드값을 수정합니다.
피어에서 다운로드한 용량, 요청한 용량, 중단(choked) 여부 등의 데이터가 포함됩니다.
만약 더 확장하기를 원한다면 이것을 유한 상태 기계(FSM)로 형식화할 수 있습니다.
하지만 지금은 구조체와 스위치만으로 충분합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;type&lt;/span&gt; pieceProgress &lt;span style=&#34;color:#f00&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  index      &lt;span style=&#34;color:#ee82ee&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  client     *client.Client
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  buf        []&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  downloaded &lt;span style=&#34;color:#ee82ee&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  requested  &lt;span style=&#34;color:#ee82ee&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  backlog    &lt;span style=&#34;color:#ee82ee&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;func&lt;/span&gt; (state *pieceProgress) &lt;span style=&#34;color:#ff0&#34;&gt;readMessage&lt;/span&gt;() &lt;span style=&#34;color:#ee82ee&#34;&gt;error&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  msg, err := state.client.&lt;span style=&#34;color:#ff0&#34;&gt;Read&lt;/span&gt;() &lt;span style=&#34;color:#0f0&#34;&gt;// this call blocks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;switch&lt;/span&gt; msg.ID {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;case&lt;/span&gt; message.MsgUnchoke:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    state.client.Choked = &lt;span style=&#34;color:#f00&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;case&lt;/span&gt; message.MsgChoke:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    state.client.Choked = &lt;span style=&#34;color:#f00&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;case&lt;/span&gt; message.MsgHave:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    index, err := message.&lt;span style=&#34;color:#ff0&#34;&gt;ParseHave&lt;/span&gt;(msg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    state.client.Bitfield.&lt;span style=&#34;color:#ff0&#34;&gt;SetPiece&lt;/span&gt;(index)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;case&lt;/span&gt; message.MsgPiece:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    n, err := message.&lt;span style=&#34;color:#ff0&#34;&gt;ParsePiece&lt;/span&gt;(state.index, state.buf, msg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    state.downloaded += n
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    state.backlog--
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/veggiedefender/torrent-client/blob/2bde944888e1195e81cc5d5b686f6ec3a9f08c25/p2p/p2p.go#L53-L83&#34;&gt;github.com/veggiedefender/torrent-client/p2p/p2p.go#L53-L83&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;요청을-보낼-시간입니다&#34;&gt;요청을 보낼 시간입니다!&lt;/h3&gt;
&lt;p&gt;파일, 조각 및 조각 해시는 전부가 아닙니다. 조각을 &lt;strong&gt;블록&lt;/strong&gt;으로 세분하여 더 발전시킬 수 있습니다.
블록은 조각의 일부입니다. 해당 블록이 속한 조각의 &lt;strong&gt;인덱스&lt;/strong&gt;,
조각에서 블록의 바이트 &lt;strong&gt;오프셋&lt;/strong&gt; 및 블록의 &lt;strong&gt;길이&lt;/strong&gt;를 통해 블록을 정의할 수 있습니다.
피어에서 데이터를 요청하면 실제로 블록을 요청합니다.
블록의 크기는 일반적으로 16KB이므로 256KB 조각 하나에 실제로 16개의 요청이 필요할 수 있습니다.&lt;/p&gt;
&lt;p&gt;피어가 16KB보다 큰 블록에 대한 요청을 수신하는 경우 연결을 끊어야 합니다.
제 경험상 요청을 128KB까지 처리하는 경우가 많았습니다.
하지만 규격보다 큰 크기의 블록을 요청할 때 전체 속도가 크게 향상되지는 않았으므로
규격을 준수하는 것이 더 나을 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;파이프라이닝&#34;&gt;파이프라이닝&lt;/h3&gt;
&lt;p&gt;네트워크 왕복 비용은 많이 들고, 각 블록을 하나씩 요청하면 다운로드 성능이 상당히 저하됩니다.
따라서 처리되지 않은 일부 요청들을 지속적으로 모으기 위해 &lt;strong&gt;파이프라인(pipeline)으로&lt;/strong&gt; 연결하는 것이 중요합니다.
이렇게 하면 연결 처리량을 상당히 증가시킬 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/go/bit-torrent/pipelining.png&#34; alt=&#34;pipelining&#34;&gt;&lt;/p&gt;
&lt;p&gt;일반적으로 비트토렌트 클라이언트는 5개의 파이프라인 요청 큐를 유지했으며, 이것이 제가 사용할 값입니다.
파이프라인을 늘리면 다운로드 속도가 최대 두 배까지 빨라진다는 것을 알았습니다.&lt;/p&gt;
&lt;p&gt;최신 클라이언트는 &lt;a href=&#34;https://luminarys.com/posts/writing-a-bittorrent-client.html&#34;&gt;적응형(adaptive)&lt;/a&gt; 큐 크기를
사용하여 최신 네트워크 속도와 조건을 더 잘 수용합니다.
이는 분명히 조정할 만한 가치가 있는 매개 변수이며, 향후 성능 최적화를 위한 쉬운 방법(low-hanging fruit)입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// MaxBlockSize 요청할 수 있는 최대 바이트 수
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;const&lt;/span&gt; MaxBlockSize = &lt;span style=&#34;color:#f60&#34;&gt;16384&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;// MaxBacklog 클라이언트가 파이프라인에서 수행할 수 없는 요청 수입니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;const&lt;/span&gt; MaxBacklog = &lt;span style=&#34;color:#f60&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#ff0&#34;&gt;attemptDownloadPiece&lt;/span&gt;(c *client.Client, pw *pieceWork) ([]&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;, &lt;span style=&#34;color:#ee82ee&#34;&gt;error&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  state := pieceProgress{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    index:  pw.index,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    client: c,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    buf:    make([]&lt;span style=&#34;color:#ee82ee&#34;&gt;byte&lt;/span&gt;, pw.length),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0f0&#34;&gt;// 데드라인을 설정하면 응답하지 않는 피어를 떼어내는 데 도움이 됩니다
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#0f0&#34;&gt;// 262KB 조각을 다운로드하려면 30초가 충분합니다
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;  c.Conn.&lt;span style=&#34;color:#ff0&#34;&gt;SetDeadline&lt;/span&gt;(time.&lt;span style=&#34;color:#ff0&#34;&gt;Now&lt;/span&gt;().&lt;span style=&#34;color:#ff0&#34;&gt;Add&lt;/span&gt;(&lt;span style=&#34;color:#f60&#34;&gt;30&lt;/span&gt; * time.Second))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;defer&lt;/span&gt; c.Conn.&lt;span style=&#34;color:#ff0&#34;&gt;SetDeadline&lt;/span&gt;(time.Time{}) &lt;span style=&#34;color:#0f0&#34;&gt;// 데드라인 비활성화
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;for&lt;/span&gt; state.downloaded &amp;lt; pw.length {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0f0&#34;&gt;// unchocked일 경우 완료되지 않은 요청이 충분히 쌓일 때까지 요청을 보냅니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; !state.client.Choked {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f00&#34;&gt;for&lt;/span&gt; state.backlog &amp;lt; MaxBacklog &amp;amp;&amp;amp; state.requested &amp;lt; pw.length {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        blockSize := MaxBlockSize
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0f0&#34;&gt;// 마지막 블록은 일반 블록보다 짧을 수 있습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; pw.length-state.requested &amp;lt; blockSize {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          blockSize = pw.length - state.requested
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        err := c.&lt;span style=&#34;color:#ff0&#34;&gt;SendRequest&lt;/span&gt;(pw.index, state.requested, blockSize)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt;, err
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        state.backlog++
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        state.requested += blockSize
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    err := state.&lt;span style=&#34;color:#ff0&#34;&gt;readMessage&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt;, err
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; state.buf, &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/veggiedefender/torrent-client/blob/2bde944888e1195e81cc5d5b686f6ec3a9f08c25/p2p/p2p.go#L85-L123&#34;&gt;github.com/veggiedefender/torrent-client/p2p/p2p.go#L85-L123&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;maingo&#34;&gt;main.go&lt;/h3&gt;
&lt;p&gt;아주 간단합니다. 거의 다 왔어요.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;package&lt;/span&gt; main
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;log&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;os&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;github.com/veggiedefender/torrent-client/torrentfile&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#ff0&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  inPath := os.Args[&lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  outPath := os.Args[&lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  tf, err := torrentfile.&lt;span style=&#34;color:#ff0&#34;&gt;Open&lt;/span&gt;(inPath)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      log.&lt;span style=&#34;color:#ff0&#34;&gt;Fatal&lt;/span&gt;(err)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  err = tf.&lt;span style=&#34;color:#ff0&#34;&gt;DownloadToFile&lt;/span&gt;(outPath)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      log.&lt;span style=&#34;color:#ff0&#34;&gt;Fatal&lt;/span&gt;(err)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/veggiedefender/torrent-client/blob/2bde944888e1195e81cc5d5b686f6ec3a9f08c25/main.go&#34;&gt;github.com/veggiedefender/torrent-client/main.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://asciinema.org/a/xqRSB0Jec8RN91Zt89rbb9PcL&#34;&gt;데모 영상&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;이것이-전부가-아닙니다&#34;&gt;이것이 전부가 아닙니다&lt;/h1&gt;
&lt;p&gt;간결함을 위해 몇 가지 중요한 부분 코드만 포함시켰습니다.
특히 글루 코드, 파싱, 유닛 테스트, 글자를 만드는 지루한 부분은 생략했습니다.
관심 있으시다면 &lt;a href=&#34;https://github.com/veggiedefender/torrent-client&#34;&gt;전체 소스 코드&lt;/a&gt;를 확인하세요.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;역자: 간단히 테스트 해보려면 아래의 명령어를 실행하세요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# Go는 설치되어 있다고 가정합니다.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone https://github.com/veggiedefender/torrent-client.git
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cd torrent-client
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# linux, darwin&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;curl -L http://bttracker.debian.org:6969/file/debian-10.0.0-amd64-netinst.iso.torrent?info_hash=7f9161c88883c639bcde80d7f0a6045ab9cf16bb -o debian.torrent
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# windows&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;wget http://bttracker.debian.org:6969/file/debian-10.0.0-amd64-netinst.iso.torrent?info_hash=7f9161c88883c639bcde80d7f0a6045ab9cf16bb -o debian.torrent
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;go run main.go debian.torrent debian.iso
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;일부 트래커는 대역폭을 절약하기 위해 &lt;a href=&#34;http://bittorrent.org/beps/bep_0015.html&#34;&gt;[UDP]&lt;/a&gt; 바이너리 프로토콜을 사용합니다&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;역주: network byte order -&amp;gt; big-endian / host byte order -&amp;gt; little-endian&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;동일한 바이트를 &lt;strong&gt;little-endian&lt;/strong&gt; 순서로 해석하면 0xE11A = 57626이 됩니다.&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
- https://markruler.github.io/posts/go/building-bittorrent-client/ - Im Changsu | Since 2020</description>
        </item>
    
    
    
        <item>
        <title>VIM 에디터 명령어 정리</title>
        <link>https://markruler.github.io/posts/shell/vim-editor-shortcuts/</link>
        <pubDate>Mon, 07 Dec 2020 00:44:00 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/shell/vim-editor-shortcuts/</guid>
        <description>임창수 https://markruler.github.io/posts/shell/vim-editor-shortcuts/ -&lt;blockquote&gt;
&lt;p&gt;서버에서 파일을 편집하기 위해 VIM 에디터를 사용할 일이 많은데,
제가 사용하는 설정 파일과 자주 쓰는 명령어를 정리합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;설정-vimrc&#34;&gt;설정 (.vimrc)&lt;/h1&gt;
&lt;p&gt;제가 사용하는 설정 파일(&lt;code&gt;~/.vimrc&lt;/code&gt;)입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-vim&#34; data-lang=&#34;vim&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;이것은 주석&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;syntax&lt;/span&gt; on                                                                       
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; showcmd
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; statusline+=%F::%l,%c
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; showmatch
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; ignorecase
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; smartcase
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; incsearch
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; autowrite
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; ruler
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; autoindent
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; cindent
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; shiftwidth=&lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; tabstop=&lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; expandtab
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; laststatus=&lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; backspace=indent,eol,start
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; showmode
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; hls
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; colorcolumn=&lt;span style=&#34;color:#f60&#34;&gt;80&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; ff=unix
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; fileencodings=utf8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; viminfo=&amp;#39;&lt;span style=&#34;color:#f60&#34;&gt;50&lt;/span&gt;,&amp;lt;&lt;span style=&#34;color:#f60&#34;&gt;1000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;set history=1000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;au FileType make setlocal noexpandtab
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;highlight&lt;/span&gt; TailingWhitespace ctermbg=red guibg=red
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; cul
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; background=dark
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; nowrapscan
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; visualbell
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; tenc=utf&lt;span style=&#34;color:#f60&#34;&gt;-8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;syntax on&lt;/code&gt; 구문강조 사용&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set showcmd&lt;/code&gt; 명령어 입력시 상태표시줄에 보여줌&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set statusline+=%F::%l,%c&lt;/code&gt; 상태표시줄에 파일명, 줄, 컬럼 표시&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set showmatch&lt;/code&gt; 괄호 매칭 보여줌&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set ignorecase&lt;/code&gt; 검색시 대소문자 무시&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set smartcase&lt;/code&gt; 검색어에 대문자가 포함되어 있으면 대소문자 구분&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set incsearch&lt;/code&gt; 검색어 입력시 점진적 검색&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set autowrite&lt;/code&gt; 저장하지 않은 파일을 끝내기 전에 자동으로 저장&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set ruler&lt;/code&gt; 화면 우측 하단에 현재 커서의 위치(줄,칸) 표시&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set autoindent&lt;/code&gt; 자동 들여쓰기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set cindent&lt;/code&gt; C언어 자동 들여쓰기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set shiftwidth=2&lt;/code&gt; 들여쓰기 2칸&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set tabstop=2&lt;/code&gt; 탭을 2칸으로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set expandtab&lt;/code&gt; 탭을 스페이스로 대체&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set laststatus=2&lt;/code&gt; 상태표시줄 항상 표시&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set backspace=indent,eol,start&lt;/code&gt; 백스페이스로 들여쓰기, 줄 끝, 줄 시작 삭제&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set showmode&lt;/code&gt; 현재 모드 표시&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set hls&lt;/code&gt; 검색어 하이라이팅&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set colorcolumn=80&lt;/code&gt; 80칸에 세로줄 표시&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set ff=unix&lt;/code&gt; 파일 포맷을 유닉스로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set fileencodings=utf8&lt;/code&gt; 파일 인코딩&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set viminfo=&#39;50,&amp;lt;1000&lt;/code&gt; 최근 50개의 명령어 기억&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set history=1000&lt;/code&gt; vi 편집기록 기억갯수 &lt;code&gt;.viminfo&lt;/code&gt;에 기록&lt;/li&gt;
&lt;li&gt;&lt;code&gt;au FileType make setlocal noexpandtab&lt;/code&gt; makefile에서 탭을 스페이스로 대체하지 않음&lt;/li&gt;
&lt;li&gt;&lt;code&gt;highlight TailingWhitespace ctermbg=red guibg=red&lt;/code&gt; 끝에 공백이 있는 경우 빨간색으로 표시&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set cul&lt;/code&gt; 현재 커서가 있는 줄 강조&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set nowrapscan&lt;/code&gt; 검색시 문서 끝에서 처음으로 이동하지 않음&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set visualbell&lt;/code&gt; 경고음 대신 화면 깜빡임&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set tenc=utf-8&lt;/code&gt; 터미널 인코딩을 UTF-8로&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/shell/vim.png&#34; alt=&#34;vim&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;입력-모드-insert-mode&#34;&gt;입력 모드 (Insert Mode)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; 현재 커서에서 편집
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Shift + i&lt;/code&gt; 현재 줄의 처음으로 커서를 옮긴 후 편집&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 현재 커서 한 글자 삭제 후 바로 입력 모드
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Shift + s&lt;/code&gt; 현재 줄 삭제 후 바로 입력 모드&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; 다음 칸으로 커서를 옮긴 후 편집
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Shift + a&lt;/code&gt; 현재 줄의 끝으로 커서를 옮긴 후 편집&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt; 다음 줄로 커서를 옮긴 후 편집
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Shift + o&lt;/code&gt; 이전 줄로 커서를 옮긴 후 편집&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;마지막-행-모드-last-line-mode&#34;&gt;마지막 행 모드 (Last Line Mode)&lt;/h1&gt;
&lt;h2 id=&#34;last-line-command-&#34;&gt;Last Line Command (:)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:q&lt;/code&gt; 종료&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:q!&lt;/code&gt; 강제 종료&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:w&lt;/code&gt; 저장&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:%s/old/new/gi&lt;/code&gt; 문자열 교체 (old -&amp;gt; new)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt; 옵션을 빼면 해당 줄의 첫 번째 문자열만 교체&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:!&lt;/code&gt; 명령어 실행
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:!ls&lt;/code&gt; 현재 디렉토리 파일 목록 출력&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:!pwd&lt;/code&gt; 현재 디렉토리 경로 출력&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:!date&lt;/code&gt; 현재 시간 출력&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:tabnew [file]&lt;/code&gt; 새로운 탭 열기 (file이 없으면 빈 탭)
&lt;ul&gt;
&lt;li&gt;실제로는 에디터 밖에서도 사용할 수 있는 tmux나 terminal 자체 기능을 활용하는 편입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gt&lt;/code&gt; 다음 탭으로 이동하기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gT&lt;/code&gt; 이전 탭으로 이동하기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;search-mode--&#34;&gt;Search mode (/, ?)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/regex-pattern&lt;/code&gt; (&lt;code&gt;?regex-pattern&lt;/code&gt;) 검색
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt; 다음 단어 (?는 반대)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N&lt;/code&gt; 이전 단어 (?는 반대)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;명령-모드-command-mode&#34;&gt;명령 모드 (Command Mode)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt; - undo&lt;/li&gt;
&lt;li&gt;&lt;code&gt;control + r&lt;/code&gt; - redo&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; - 이전 명령 다시 실행&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;이동&#34;&gt;이동&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hjkl&lt;/code&gt; 좌하상우 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + b&lt;/code&gt; 이전 페이지로 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + f&lt;/code&gt; 다음 페이지로 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + u&lt;/code&gt; 이전 half page로 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + d&lt;/code&gt; 다음 half page로 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gg&lt;/code&gt; 문서 맨 앞으로 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G&lt;/code&gt; 문서 맨 뒤로 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; 현재 줄 앞으로 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; 현재 줄 끝으로 이동&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;간단한-편집&#34;&gt;간단한 편집&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt; 복사 (yank)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt; 붙여넣기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; 들여쓰기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; 내어쓰기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Shift + j&lt;/code&gt; 현재 줄의 끝과 다음 줄의 앞부분을 합칩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;삭제&#34;&gt;삭제&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; 현재 커서 한 글자 교체(replace)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; 현재 커서 한 글자 삭제 (delete)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Shift + x&lt;/code&gt; 현재 커서 앞에 한 글자 삭제 (backspace)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:1,.d&lt;/code&gt; 첫 번째 줄부터 현재 커서까지 삭제 (LLM)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:5,10d&lt;/code&gt; 5번 줄부터 10번 줄까지 삭제 (LLM)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dd&lt;/code&gt; 현재 줄 삭제 (이후 p를 통해 삭제한 줄을 붙여넣을 수 있습니다)
&lt;ul&gt;
&lt;li&gt;이동키와 조합해 삭제할 수도 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;5dd&lt;/code&gt; 현재 줄 포함 아래로 5줄 삭제&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dgg&lt;/code&gt; 현재 커서에서 첫 줄까지 삭제&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dG&lt;/code&gt; 현재 커서에서 마지막 줄까지 삭제&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d$&lt;/code&gt; 현재 커서에서 현재 줄 마지막 단어까지 삭제&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d^&lt;/code&gt; 현재 커서에서 현재 줄 첫 단어까지 삭제&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dw&lt;/code&gt; 현재 커서에서 현재 단어까지 삭제&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;비주얼-모드visual-mode&#34;&gt;비주얼 모드(visual mode)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;v&lt;/code&gt; 비주얼 모드&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shift + v&lt;/code&gt; 비주얼 라인&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl + v&lt;/code&gt; 비주얼 블록
&lt;ul&gt;
&lt;li&gt;비주얼 블록 모드에서 &lt;code&gt;Shift + i&lt;/code&gt;를 누르면 블록의 첫 줄에 커서가 위치하고, 입력 모드로 전환됩니다.&lt;/li&gt;
&lt;li&gt;입력을 마치고 &lt;code&gt;ESC&lt;/code&gt;를 누르면 블록의 모든 줄에 입력한 내용이 삽입됩니다. (여러 줄을 주석 처리할 때 유용)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;화면-분할&#34;&gt;화면 분할&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;탭 기능과 동일하게 터미널 자체 기능을 선호하는 편입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;s&lt;/code&gt; horizontal split
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt; horizontal split한 후 새로운 창 생성&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;v&lt;/code&gt; vertical split
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vs&lt;/code&gt; vertical split한 후 현재 창 복제&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;방향키&lt;/code&gt; 분할된 창 간 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;&amp;gt;&lt;/code&gt; 창 폭 늘리기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;&amp;lt;&lt;/code&gt; 창 폭 줄이기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;+&lt;/code&gt; 창 높이 늘리기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;-&lt;/code&gt; 창 높이 줄이기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;=&lt;/code&gt; 창 폭, 높이 원래 상태로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;o&lt;/code&gt; only one window&lt;/li&gt;
&lt;/ul&gt;
- https://markruler.github.io/posts/shell/vim-editor-shortcuts/ - Im Changsu | Since 2020</description>
        </item>
    
    
    
        <item>
        <title>NFV 도커 컨테이너 초심자 가이드</title>
        <link>https://markruler.github.io/posts/nfv/beginners-guide-docker-container-nfv/</link>
        <pubDate>Mon, 16 Nov 2020 22:40:00 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/nfv/beginners-guide-docker-container-nfv/</guid>
        <description>임창수 https://markruler.github.io/posts/nfv/beginners-guide-docker-container-nfv/ -&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://telcocloudbridge.com/blog/beginners-guide-docker-container-nfv/&#34;&gt;Faisal Khan의 A Beginner&amp;rsquo;s Guide to Docker Container in NFV&lt;/a&gt;를 번역한 글입니다.&lt;/li&gt;
&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;
&lt;li&gt;2016년 3월 3일에 쓰여진 글입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;떠오르는 도커(Docker) 컨테이너는 NFV를 혁신할 잠재력을 가지고 있습니다.
무엇보다 도커 컨테이너는 가상 머신에 비해 가볍고, 적은 오버헤드와 리소스만을 요구하며, 동일한 운영체제에서 실행되는 애플리케이션을 격리시킬 수 있습니다.
즉, NFV에서 VNF(가상 네트워크 기능)이 도커 컨테이너에서 완전히 격리된 상태로 실행될 수 있다면, 가상 머신이 필요 없을 지도 모릅니다.
하지만 그게 그렇게 쉬울까요?&lt;/p&gt;
&lt;p&gt;그렇다면 가상 머신의 미래는 어떻게 될까요?
사실 도커 컨테이너는 아직 성장하는 단계에 있기 때문에 가상 머신의 미래에 대해 뭐라고 말하기에는 너무 이릅니다(NFV도 마찬가지입니다 😊).
하지만 여러분이 이 글을 끝까지 읽는다면, 왜 모두가 도커 컨테이너에 대해 이야기하는지, 도커 컨테이너를 특별하게 만드는 것이 무엇인지 알 수 있을 것입니다.&lt;/p&gt;
&lt;p&gt;본 가이드의 주요 목적은 도커 컨테이너의 아키텍처를 이해하는 데 있어 단계별로 이해할 수 있도록 돕는 것입니다.
이 과정에서 하이퍼바이저와 가상 머신의 기초에 대해서도 이해하게 될 것입니다.
이 개념들은 하이퍼바이저와 가상 머신에 대한 사전 지식이 전혀 없다고 가정하고 설명됩니다.&lt;/p&gt;
&lt;h1 id=&#34;컨테이너란-무엇인가요&#34;&gt;컨테이너란 무엇인가요?&lt;/h1&gt;
&lt;p&gt;애초에 컨테이너는 애플리케이션을 더 유연하고 기민하게 실행하는 방법으로 등장했습니다.
리눅스 컨테이너는 리눅스 운영체제 내에서 경량 애플리케이션을 직접 실행할 수 있도록 해주었습니다.
하이퍼바이저와 가상 머신이 필요하지 않기 때문에 애플리케이션은 동일한 운영체제 내에서 격리된 상태로 실행될 수 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;도커-컨테이너란-무엇인가요&#34;&gt;도커 컨테이너란 무엇인가요?&lt;/h1&gt;
&lt;p&gt;구글(Google)은 2006년부터 자사 데이터 센터에서 리눅스(Linux) 컨테이너를 사용해왔습니다.
하지만 2013년 도커 컨테이너의 등장과 함께 컨테이너는 더 널리 알려지게 되었습니다.
도커는 이전 버전의 컨테이너에 비해 더 간단하고 표준화된 방식으로 컨테이너를 실행할 수 있게 해줍니다.&lt;/p&gt;
&lt;p&gt;도커 컨테이너 역시 리눅스에서 실행됩니다.
하지만 도커만이 컨테이너를 실행하는 유일한 방법은 아닙니다.
LXC도 컨테이너를 실행하는 또 다른 방식입니다.
LXC와 도커 모두 리눅스에 뿌리를 두고 있습니다.&lt;/p&gt;
&lt;p&gt;도커 컨테이너가 LXC와 같은 경쟁 컨테이너보다 더 인기를 끈 이유 중 하나는
호스트 운영체제에서 &amp;ldquo;이미지&amp;quot;로 간단하고 빠르게 불러올 수 있기 때문입니다.
도커는 클라우드에 이미지 형태로 저장되며, 사용자가 필요할 때 간단하게 호출하여 실행할 수 있습니다.&lt;/p&gt;
&lt;p&gt;앞으로는 &amp;ldquo;컨테이너&amp;quot;와 &amp;ldquo;도커 컨테이너&amp;quot;라는 단어를 동일한 의미처럼 사용하겠습니다.&lt;/p&gt;
&lt;h1 id=&#34;nfv에서-도커-컨테이너를-이해하기-위한-단계별-가이드&#34;&gt;NFV에서 도커 컨테이너를 이해하기 위한 단계별 가이드&lt;/h1&gt;
&lt;p&gt;가상 머신은 유용하지만 몇 가지 문제점이 있습니다.&lt;/p&gt;
&lt;p&gt;전용 운영체제가 필요합니다.
또한 가상화를 달성하기 위해 가상 머신을 분리할 하이퍼바이저가 필요합니다.&lt;/p&gt;
&lt;p&gt;애플리케이션이 많아질수록 소프트웨어 오버헤드가 증가하고 비용이 더 많이 들며, 지속적으로 업데이트를 유지해야 합니다.
그럼에도 불구하고 NFV 아키텍처에는 가상 머신이 필요합니다.&lt;/p&gt;
&lt;p&gt;이제 NFV 아키텍처를 살펴보겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;1단계-nfv-아키텍처에서-하이퍼바이저-살펴보기&#34;&gt;1단계: NFV 아키텍처에서 하이퍼바이저 살펴보기&lt;/h2&gt;
&lt;p&gt;아래 다이어그램은 여러분이 여러 번 봤을 법한 NFV 아키텍처를 보여줍니다.
(모르시는 분은 &lt;a href=&#34;../cheat-sheet-understanding-nfv-architecture/&#34;&gt;여기를 확인해주세요&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/nfv/hypervisor-in-nfv.png&#34; alt=&#34;hypervisor-in-nfv&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;그림 1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;이 논의를 위해 NFVI (NFV Infrastructure) 부분만 확대해서 살펴보겠습니다.
NFVI는 세 가지 주요 구성 요소로 나뉩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하이퍼바이저 도메인&lt;/li&gt;
&lt;li&gt;컴퓨팅 도메인&lt;/li&gt;
&lt;li&gt;네트워크 인프라스트럭처 도메인&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;가상화 계층(Virtualization Layer)은 실제로 하이퍼바이저를 의미하며, 이는 컴퓨트 도메인(물리적/x86 서버)의 하드웨어 리소스를 추상화하는 역할을 담당합니다.
예를 들어 단일 물리적 서버(물리적 메모리와 물리적 컴퓨트)가 있다고 가정해 봅시다.
하이퍼바이저는 이를 여러 개의 가상 메모리와 가상 컴퓨트로 분할할 수 있으며, 각 엔티티는 독립적으로 작동하게 됩니다.&lt;/p&gt;
&lt;p&gt;이 가상화 계층(하이퍼바이저)과 가상 리소스를 함께 묶어서 &amp;ldquo;하이퍼바이저 도메인&amp;quot;이라고 부릅니다.&lt;/p&gt;
&lt;h2 id=&#34;2단계-가상-머신-자세히-살펴보기&#34;&gt;2단계: 가상 머신 자세히 살펴보기&lt;/h2&gt;
&lt;p&gt;가상 머신을 이해하기 위해 이번에는 하이퍼바이저 도메인을 확장하여 이 도메인 내부를 보여드리겠습니다.&lt;/p&gt;
&lt;p&gt;아래 &lt;em&gt;그림 2&lt;/em&gt;를 확인해 주세요.&lt;/p&gt;
&lt;p&gt;왼쪽에는 앞서 그림 1에서 보았던 하이퍼바이저 도메인이 동일하게 표시되어 있습니다.
하지만 오른쪽 그림에서는 하이퍼바이저 도메인을 확장하여 가상 머신을 보여줍니다.
즉, 하이퍼바이저 도메인의 가상 리소스가 이제 가상 머신으로 표시된 것입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/nfv/hypervisor-domain-with-vm.png&#34; alt=&#34;hypervisor-domain-with-vm&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;그림 2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;간단히 설명하기 위해 왼쪽의 가상 네트워크/네트워크 블록은 제거했습니다.
이 논의에서는 중요하지 않기 때문입니다.
여기서 가상화 계층은 리소스/네트워크 관리자가 되었고,
가상 컴퓨트/메모리는 가상 머신(VM)이 되었습니다.&lt;/p&gt;
&lt;p&gt;그렇다면 가상 머신이란 무엇일까요?&lt;/p&gt;
&lt;p&gt;가상 머신은 VNF(가상 네트워크 기능)이 실행되는 환경을 제공합니다.
다이어그램을 보면 각 가상 머신이 하나의 VNF와 연결되어 있는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;명확하게 하기 위해 예를 들어 설명하겠습니다.
VNF1이 Virtual CPE라고 하고, VNF2가 Virtual Firewall이라고 가정해 봅시다.
위의 예시에서 각각은 자신의 가상 머신에서 실행됩니다.
그리고 이들은 하이퍼바이저 도메인 내부에서 서로 체이닝되어 연결될 수 있습니다.&lt;/p&gt;
&lt;p&gt;또한 가상 머신은 논리적으로 서로 분리되어 있다는 점을 주목하세요.
이를 통해 각 가상 머신에서 독립적인 운영체제를 실행할 수 있습니다.
예를 들어, 게스트 운영체제 OS1은 리눅스이고, 게스트 OS2는 솔라리스일 수 있습니다.&lt;/p&gt;
&lt;p&gt;게스트 운영체제 외에도 호스트 운영체제가 필요하다는 점에 주목하세요.
호스트 운영체제는 하이퍼바이저가 실행되는 환경입니다.
이 중요한 점을 기억해 두세요.
다음 단락에서 컨테이너에 대해 이야기할 때 다시 언급될 것입니다.&lt;/p&gt;
&lt;p&gt;이제 가상 머신을 제거하고 다음 단계로 나아가 봅시다.&lt;/p&gt;
&lt;h2 id=&#34;3단계-가상-머신을-제거하고-컨테이너를-도입하기&#34;&gt;3단계: 가상 머신을 제거하고 컨테이너를 도입하기!&lt;/h2&gt;
&lt;p&gt;이제 가상 머신 대신 완전히 새로운 구성 요소인 컨테이너를 도입하겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/nfv/vm-replaced-with-container.png&#34; alt=&#34;vm-replaced-with-container&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;그림 3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;이제 VNF1은 컨테이너 1에서 실행되고, VNF2는 컨테이너 2에서 실행되어 가상 머신과 동일한 기능을 제공합니다.
우리가 달성한 것은 가상 머신과 동일한 기능이지만, 동일한 운영체제 내에서 실행된다는 점입니다.
여기서 운영체제는 리눅스입니다.
눈치채셨나요? 이제 게스트 운영체제가 필요하지 않습니다!
더 간단한 아키텍처입니다.
그렇죠?&lt;/p&gt;
&lt;h1 id=&#34;컨테이너로-무엇을-달성했나요&#34;&gt;컨테이너로 무엇을 달성했나요?&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;컨테이너 환경에서는 게스트 운영체제(OS)가 필요하지 않습니다.
보시다시피 호스트 OS는 리눅스입니다.
따라서 가상 머신에 비해 더 경량이며 오버헤드가 적습니다.&lt;/li&gt;
&lt;li&gt;아키텍처가 간소화되었습니다.
하이퍼바이저를 제거하고 컨테이너가 동일한 호스트 OS 내에서 OS 수준의 충분한 격리를 유지할 수 있기 때문입니다.&lt;/li&gt;
&lt;li&gt;가상 머신은 하드웨어 수준의 가상화를 제공합니다.
즉, 전통적인 가상 머신은 하이퍼바이저 소프트웨어를 통해 호스트를 분할합니다.
이 말은 가상 머신이 호스트 머신의 OS와 격리된다는 것을 의미합니다.
예를 들어, 리눅스 운영체제 위에서 윈도우 호스트를 실행할 수 있습니다.
반면, 컨테이너는 OS 수준의 가상화를 제공합니다.
즉, 동일한 OS 내에서 애플리케이션이 서로 격리된 상태를 유지할 수 있습니다.
이것은 가상 머신에 비해 오버헤드가 훨씬 적은 방식입니다.
왜냐하면 전체 OS를 중복해서 실행할 필요가 없기 때문입니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;컨테이너에 대한 설명은 여기까지입니다.&lt;/p&gt;
&lt;h1 id=&#34;nfv를-위한-컨테이너의-미래&#34;&gt;NFV를 위한 컨테이너의 미래&lt;/h1&gt;
&lt;p&gt;솔직히 말해서, 현재 NFV 아키텍처와 표준은 가상 머신을 기반으로 하고 있습니다.&lt;/p&gt;
&lt;p&gt;컨테이너는 아직 NFV에서 새로운 개념입니다.
특히 보안 관점에서 여전히 많은 개발이 진행되고 있습니다.
보시다시피 호스트 OS는 모든 컨테이너에 노출되어 있기 때문에 멀티 테넌시 환경에서 잠재적인 보안 문제가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;그럼에도 불구하고 컨테이너는 이러한 환경에서 VNF를 실행하는 데 있어 간단하고 효율적인 방식을 제공하기 때문에 유망한 미래를 약속합니다.
또한, 가상 머신 위에서 전체 VNF를 실행하는 대신, 마이크로서비스를 실행할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예를 들어 가상 CPE(vCPE, Virtual Customer Premises Equipment)의 경우 많은 구성요소를 작은 컨테이너로 분해하고 서로 연결(체이닝)할 수 있습니다.
기능을 분해하면 소프트웨어 벤더들이 VNF의 작은 기능을 더 쉽게 개발할 수 있고 오버헤드도 줄일 수 있는 기회를 제공합니다.&lt;/p&gt;
- https://markruler.github.io/posts/nfv/beginners-guide-docker-container-nfv/ - Im Changsu | Since 2020</description>
        </item>
    
    
    
        <item>
        <title>쿠버네티스 컴포넌트를 로컬에서 직접 빌드 및 디버깅하기</title>
        <link>https://markruler.github.io/posts/kubernetes/local-build-kube/</link>
        <pubDate>Sun, 11 Oct 2020 14:48:00 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/kubernetes/local-build-kube/</guid>
        <description>임창수 https://markruler.github.io/posts/kubernetes/local-build-kube/ -&lt;blockquote&gt;
&lt;p&gt;직접 빌드해서 사용한다면 쿠버네티스 기능을 확장해서 사용할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.19/build/README.md&#34;&gt;kubernetes/build/README.md&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;사용할-명령어&#34;&gt;사용할 명령어&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# master 브랜치&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone --depth &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt; https://github.com/kubernetes/kubernetes.git
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# 특정 브랜치&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone --depth &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt; --single-branch --branch release-1.19 https://github.com/kubernetes/kubernetes.git
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# cmd 디렉터리에 있는 다른 컴포넌트도 같은 방식으로 빌드할 수 있다.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# cmd/kubeadm, kubectl, kubelet, kube-apiserver, kube-proxy, kube-controller-manager, kube-scheduler, ...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make all &lt;span style=&#34;color:#eedd82&#34;&gt;WHAT&lt;/span&gt;=cmd/kubectl &lt;span style=&#34;color:#eedd82&#34;&gt;GOFLAGS&lt;/span&gt;=-v
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# 그냥 간단히 go build 명령도 가능하다.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;go build -o k cmd/kubectl
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;빌드-실행-따라가기&#34;&gt;빌드 실행 따라가기&lt;/h2&gt;
&lt;h3 id=&#34;makefile&#34;&gt;Makefile&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;make 명령을 내릴 루트 디렉터리 Makefile을 보면 아래와 같이 다른 Makefile을 가리킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;build/root/Makefile
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;실제로-빌드되는-makefile&#34;&gt;실제로 빌드되는 Makefile&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.19/build/root/Makefile&#34;&gt;build/root/Makefile&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;all 타겟은 WHAT 전달인자와 함께 build.sh 쉘 스크립트 파일을 실행시킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# Build code.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# Args:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   WHAT: Directory names to build.  If any of these directories has a &amp;#39;main&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#     package, the build will produce executable files under $(OUT_DIR)/bin.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#     If not specified, &amp;#34;everything&amp;#34; will be built.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   GOFLAGS: Extra flags to pass to &amp;#39;go&amp;#39; when building.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   GOLDFLAGS: Extra linking flags passed to &amp;#39;go&amp;#39; when building.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   GOGCFLAGS: Additional go compile flags passed to &amp;#39;go&amp;#39; when building.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# Example:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   make
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   make all
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   make all WHAT=cmd/kubelet GOFLAGS=-v
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   make all GOLDFLAGS=&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#     Note: Specify GOLDFLAGS as an empty string for building unstripped binaries, which allows
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#           you to use code debugging tools like delve. When GOLDFLAGS is unspecified, it defaults
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#           to &amp;#34;-s -w&amp;#34; which strips debug information. Other flags that can be used for GOLDFLAGS 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#           are documented at https://golang.org/cmd/link/
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;endef
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff0&#34;&gt;.PHONY&lt;/span&gt;: all
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ifeq (&lt;span style=&#34;color:#f00&#34;&gt;$(&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;PRINT_HELP&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;)&lt;/span&gt;,y)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff0&#34;&gt;all&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	@echo &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;$$&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;ALL_HELP_INFO&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;else
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff0&#34;&gt;all&lt;/span&gt;: generated_files
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	hack/make-rules/build.sh &lt;span style=&#34;color:#f00&#34;&gt;$(&lt;/span&gt;WHAT&lt;span style=&#34;color:#f00&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;endif
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;all-generated_files&#34;&gt;all: generated_files&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.19/hack/make-rules/build.sh&#34;&gt;hack/make-rules/build.sh&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e5e5e5&#34;&gt;#!/usr/bin/env bash
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e5e5e5&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# This script sets up a go workspace locally and builds all go components.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set -o errexit
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set -o nounset
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set -o pipefail
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;KUBE_ROOT&lt;/span&gt;=&lt;span style=&#34;color:#f00&#34;&gt;$(&lt;/span&gt;dirname &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;BASH_SOURCE&lt;/span&gt;[0]&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;)&lt;/span&gt;/../..
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;KUBE_VERBOSE&lt;/span&gt;=&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;KUBE_VERBOSE&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:-&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;source &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;KUBE_ROOT&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;/hack/lib/init.sh&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# 👉 hack/lib/golang.sh&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kube::golang::build_binaries &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;$@&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kube::golang::place_bins
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;kubegolang&#34;&gt;kube::golang::&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.19/hack/lib/golang.sh&#34;&gt;hack/lib/golang.sh&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;참고로 쉘 스크립트의 function 키워드는 생략할 수 있으며, double colon(::)은 쿠버네티스의 Naming Convection으로 보인다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# Build binaries targets specified&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# Input:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   $@ - targets and go flags.  If no targets are set then all binaries targets&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#     are built.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   KUBE_BUILD_PLATFORMS - Incoming variable of targets to build for.  If unset&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#     then just the host architecture is built.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kube::golang::build_binaries() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# This will take binaries from $GOPATH/bin and copy them to the appropriate&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# place in ${KUBE_OUTPUT_BINDIR}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# Ideally this wouldn&amp;#39;t be necessary and we could just set GOBIN to&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# KUBE_OUTPUT_BINDIR but that won&amp;#39;t work in the face of cross compilation.  &amp;#39;go&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# install&amp;#39; will place binaries that match the host platform directly in $GOBIN&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# while placing cross compiled binaries into `platform_arch` subdirs.  This&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# complicates pretty much everything else we do around packaging and such.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kube::golang::place_bins() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0f0&#34;&gt;# V=2 kube::log::status ${KUBE_OUTPUT_BINPATH}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0f0&#34;&gt;# 위 로그 함수를 추가해서 빌드하면 어디에 빌드되었는지 확인할 수 있다.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0f0&#34;&gt;# &amp;gt; [%m%d %H:%M:%S] /home/kubernetes/kubernetes/_output/local/bin&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;로그-레벨&#34;&gt;로그 레벨&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/hack/lib/logging.sh&#34;&gt;hack/lib/logging.sh&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# This controls the verbosity of the build. Higher numbers mean more output.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;KUBE_VERBOSE&lt;/span&gt; ?= &lt;span style=&#34;color:#f60&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# 찾아보면 V=4까지 있는 것 같아서 4로 지정했다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# 👉 hack/lib/logging.sh
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff0&#34;&gt;kube&lt;/span&gt;::log::status() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  local &lt;span style=&#34;color:#eedd82&#34;&gt;V&lt;/span&gt;=&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;V&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:-&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; [[ &lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;KUBE_VERBOSE&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;V&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt; ]]; &lt;span style=&#34;color:#f00&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;fi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eedd82&#34;&gt;timestamp&lt;/span&gt;=&lt;span style=&#34;color:#f00&#34;&gt;$(&lt;/span&gt;date +&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;[%m%d %H:%M:%S]&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  echo &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;+++ &lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;timestamp&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  shift
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;for&lt;/span&gt; message; &lt;span style=&#34;color:#f00&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    echo &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;    &lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;message&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;cmdkubectl&#34;&gt;cmd/kubectl&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.19/cmd/kubectl/kubectl.go&#34;&gt;kubectl.go&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;package&lt;/span&gt; main
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	goflag &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;flag&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;math/rand&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;os&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;time&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;github.com/spf13/pflag&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	cliflag &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;k8s.io/component-base/cli/flag&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;k8s.io/kubectl/pkg/util/logs&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;k8s.io/kubernetes/pkg/kubectl/cmd&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0f0&#34;&gt;// Import to initialize client auth plugins.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;	_ &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;k8s.io/client-go/plugin/pkg/client/auth&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#ff0&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	rand.&lt;span style=&#34;color:#ff0&#34;&gt;Seed&lt;/span&gt;(time.&lt;span style=&#34;color:#ff0&#34;&gt;Now&lt;/span&gt;().&lt;span style=&#34;color:#ff0&#34;&gt;UnixNano&lt;/span&gt;())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	command := cmd.&lt;span style=&#34;color:#ff0&#34;&gt;NewDefaultKubectlCommand&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0f0&#34;&gt;// TODO: once we switch everything over to Cobra commands, we can go back to calling
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#0f0&#34;&gt;// cliflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#0f0&#34;&gt;// normalize func and add the go flag set by hand.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;	pflag.CommandLine.&lt;span style=&#34;color:#ff0&#34;&gt;SetNormalizeFunc&lt;/span&gt;(cliflag.WordSepNormalizeFunc)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	pflag.CommandLine.&lt;span style=&#34;color:#ff0&#34;&gt;AddGoFlagSet&lt;/span&gt;(goflag.CommandLine)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0f0&#34;&gt;// cliflag.InitFlags()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;	logs.&lt;span style=&#34;color:#ff0&#34;&gt;InitLogs&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f00&#34;&gt;defer&lt;/span&gt; logs.&lt;span style=&#34;color:#ff0&#34;&gt;FlushLogs&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; err := command.&lt;span style=&#34;color:#ff0&#34;&gt;Execute&lt;/span&gt;(); err != &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		os.&lt;span style=&#34;color:#ff0&#34;&gt;Exit&lt;/span&gt;(&lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;pkgkubectlcmdhttpsgithubcomkuberneteskubernetesblobrelease-119pkgkubectlcmdcmdgo&#34;&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.19/pkg/kubectl/cmd/cmd.go&#34;&gt;pkg/kubectl/cmd&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&#34;디버깅&#34;&gt;디버깅&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;환경은 VS Code에 github.com/go-delve/delve/cmd/dlv 를 설치한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://code.visualstudio.com/docs/editor/debugging&#34;&gt;launch.json&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;#34;version&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;0.2.0&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;#34;configurations&amp;#34;: [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;type&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;go&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;request&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;launch&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;name&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;kubectl&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;program&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;${workspaceFolder}/cmd/kubectl/kubectl.go&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;args&amp;#34;: [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;config&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;view&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/kubernetes/vscode-debugging-golang.png&#34; alt=&#34;vscode-debugging-golang&#34;&gt;&lt;/p&gt;
- https://markruler.github.io/posts/kubernetes/local-build-kube/ - Im Changsu | Since 2020</description>
        </item>
    
    
    
        <item>
        <title>Observability 용어 정리</title>
        <link>https://markruler.github.io/posts/cloud/monitor-trace-log-metric/</link>
        <pubDate>Fri, 02 Oct 2020 16:24:00 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/cloud/monitor-trace-log-metric/</guid>
        <description>임창수 https://markruler.github.io/posts/cloud/monitor-trace-log-metric/ -&lt;h1 id=&#34;observability&#34;&gt;Observability&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;관측성&lt;/li&gt;
&lt;li&gt;관찰성&lt;/li&gt;
&lt;li&gt;관측 가능성&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;제어 이론에서 &amp;lsquo;observability&amp;rsquo;라는 용어는
시스템의 내부 상태 변수와 그에 따른 행동을
시스템에 대한 입력과 출력만 보고 결정할 수 있다면
그 시스템이 관측 가능하다는 것을 나타낸다.&lt;/p&gt;
&lt;h1 id=&#34;event-logging&#34;&gt;Event Logging&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/cloud/kibana5-fluentd.png&#34; alt=&#34;kibana5-fluentd&#34;&gt;
&lt;em&gt;Fluentd-Kibana&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;로그는 시스템 프로세스의 개별 이벤트를 기록하는 것이다.
하지만 각 로그 스트림은 단일 인스턴스에 대해서만 알려주기 때문에
마이크로서비스에서 전체적인 모니터링을 하기에는 어려움이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.fluentd.org/&#34;&gt;Fluentd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.elastic.co/&#34;&gt;Elastic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.datadoghq.com/logs/&#34;&gt;Datadog Log Management&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;software-tracing&#34;&gt;Software Tracing&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/cloud/jaeger-embed-trace-view.png&#34; alt=&#34;jaeger-embed-trace-view&#34;&gt;
&lt;em&gt;Jaeger&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;사용자의 트래픽이 지나가는 애플리케이션의 전체 스택을 추적한다.
주로 서비스를 최적화하는 데 사용된다.
예를 들어, 특정 서비스에 병목이 예상되는 경우
트레이싱해서 어떤 부분인지 확인하고 최적화를 시도해볼 수 있다.
결국 트레이싱은 구조화된 형태의 로그 이벤트일 뿐이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jaegertracing.io/&#34;&gt;Jaeger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://opentracing.io/&#34;&gt;OpenTracing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linux.die.net/man/1/strace&#34;&gt;strace&lt;/a&gt; - Linux man page&lt;/li&gt;
&lt;li&gt;구글 크롬의 &lt;a href=&#34;https://developers.google.com/web/tools/chrome-devtools/network/&#34;&gt;Network log&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;logging--tracing&#34;&gt;Logging : Tracing&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;Event logging&lt;/th&gt;
          &lt;th&gt;Software tracing&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Consumed primarily by system administrators&lt;/td&gt;
          &lt;td&gt;Consumed primarily by developers&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Logs &amp;ldquo;high level&amp;rdquo; information (e.g. failed installation of a program)&lt;/td&gt;
          &lt;td&gt;Logs &amp;ldquo;low level&amp;rdquo; information (e.g. a thrown exception)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Must not be too &amp;ldquo;noisy&amp;rdquo; (containing many duplicate events or information that is not helpful for its intended audience)&lt;/td&gt;
          &lt;td&gt;Can be noisy&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;A standards-based output format is often desirable, sometimes even required&lt;/td&gt;
          &lt;td&gt;Few limitations on output format&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Event log messages are often localized&lt;/td&gt;
          &lt;td&gt;Localization is rarely a concern&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Addition of new types of events, as well as new event messages, need not be agile&lt;/td&gt;
          &lt;td&gt;Addition of new tracing messages must be agile&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;trace--track&#34;&gt;Trace : Track&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;track은 시작 지점에서 시작해서 현재 지점으로 새로운 경로를 계속 따라가는 것이다.
&lt;ul&gt;
&lt;li&gt;To track: follow the emerging path forwards from your starting point to wherever the thing currently is.&lt;/li&gt;
&lt;li&gt;When you &amp;ldquo;track&amp;rdquo; a cellphone, you monitor its current location,
right now, and follow it wherever it goes in the future.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;trace는 현재 지점에서 시작된 지점까지 이미 완료된 경로를 따라가는 것이다.
&lt;ul&gt;
&lt;li&gt;To trace: follow the completed path backwards from its current point to where it began.&lt;/li&gt;
&lt;li&gt;When you &amp;ldquo;trace&amp;rdquo; a cellphone call, you try to determine its origin.
This is the same whether done right now, or for a call made a month ago.
You go backward to the starting point.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;distributed-tracing&#34;&gt;Distributed tracing&lt;/h2&gt;
&lt;p&gt;분산 추적은 종단 간 또는 워크플로 중심 추적이라고도 하며,
분산 시스템의 구성 요소에 의해 수행되는 인과관계가 있는 활동의 상세한 실행 정보를 수집하는 것을 목적으로 하는 일련의 기법이다.
기존의 코드 프로파일러나 dtrace 같은 호스트 레벨 추적 도구와는 달리
종단 간 추적은 주로 여러 다른 프로세스에 의해 협력적으로 수행되는 개별 실행 정보를 프로파일링하는 데 초점을 맞추고 있으며,
이와 같은 환경은 현대적이고 클라우드 네이티브한 마이크로서비스 기반 애플리케이션이 대표적이다.&lt;/p&gt;
&lt;h1 id=&#34;monitoring&#34;&gt;Monitoring&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/cloud/grafana-visualize.jpg&#34; alt=&#34;grafana-visualize&#34;&gt;
&lt;em&gt;Grafana&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;애플리케이션 계측(measure), 메트릭 수집(collect), 집계(aggregate), 분석(analyze) 등을 포함하는 시스템이다.
진단 목적으로 가장 많이 사용되고, 문제가 발생했을 경우 관리자에게 알람을 보낸다.
예를 들어 설정한 임계점(threshold)을 넘을 경우 이메일을 보내거나 슬랙 채널에 메시지를 보낼 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://prometheus.io/&#34;&gt;Prometheus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://grafana.com/&#34;&gt;Grafana&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://thanos.io/&#34;&gt;Thanos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.datadoghq.com/getting_started/&#34;&gt;Datadog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;profiling&#34;&gt;Profiling&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/cloud/android-profiler-callouts.png&#34; alt=&#34;android-profiler-callouts&#34;&gt;&lt;/p&gt;
&lt;p&gt;프로그램의 공간(메모리) 또는 시간 복잡성, 특정 명령의 사용 또는 빈도를 측정하는
&lt;a href=&#34;https://en.wikipedia.org/wiki/Dynamic_program_analysis&#34;&gt;동적 프로그램 분석(Dynamic program analysis)&lt;/a&gt;의 한 형태다.
모니터링과 달리 벤치마킹에 주 목적이 있다.
분산 환경보다 단일 애플리케이션을 배포하기 전 성능 테스트 및 통계에 쓰인다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/java-profilers&#34;&gt;A Guide to Java Profilers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.datadoghq.com/tracing/profiler/&#34;&gt;Datadog Continuous Profiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.android.com/studio/profile&#34;&gt;Android Profiler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;참조&#34;&gt;참조&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Observability
&lt;ul&gt;
&lt;li&gt;유리 슈쿠로 &amp;lt;마스터링 분산 추적&amp;gt; 6쪽&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Observability&#34;&gt;Observability&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://landscape.cncf.io/&#34;&gt;CNCF Landscape&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Logging
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Logging_(software)&#34;&gt;Logging&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Log_management&#34;&gt;Log management&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Log_analysis&#34;&gt;Log analysis&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Tracing
&lt;ul&gt;
&lt;li&gt;유리 슈쿠로 &amp;lt;마스터링 분산 추적&amp;gt; 58쪽&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Tracing_(software)&#34;&gt;Tracing&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Audit_trail&#34;&gt;Audit trail&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ell.stackexchange.com/questions/34391/difference-between-track-and-trace&#34;&gt;Difference between Tracking and Tracing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://opentracing.io/docs/overview/what-is-tracing/&#34;&gt;What is Distributed Tracing? - OpenTracing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bmc.com/blogs/monitoring-logging-tracing&#34;&gt;Tracing vs Logging vs Monitoring: What’s the Difference?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://winderresearch.com/logging-vs-tracing-vs-monitoring/&#34;&gt;Logging vs Tracing vs Monitoring&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Monitoring
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Application_performance_management&#34;&gt;Application performance management&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Event_monitoring&#34;&gt;Event monitoring&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Log_monitor&#34;&gt;Log monitor&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://techbeacon.com/enterprise-it/monitoring-demystified-guide-logging-tracing-metrics&#34;&gt;Monitoring demystified: A guide for logging, tracing, metrics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Profiling
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Profiling_(computer_programming)&#34;&gt;Profiling&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://markruler.github.io/posts/cloud/monitor-trace-log-metric/ - Im Changsu | Since 2020</description>
        </item>
    
    
    
        <item>
        <title>NFV의 컴퓨팅 도메인에 대한 오해!</title>
        <link>https://markruler.github.io/posts/nfv/the-misunderstood-facts-about-compute-domain-in-nfv/</link>
        <pubDate>Thu, 01 Oct 2020 22:23:00 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/nfv/the-misunderstood-facts-about-compute-domain-in-nfv/</guid>
        <description>임창수 https://markruler.github.io/posts/nfv/the-misunderstood-facts-about-compute-domain-in-nfv/ -&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://telcocloudbridge.com/blog/the-misunderstood-facts-about-compute-domain-in-nfv/&#34;&gt;Faisal Khan의 The Misunderstood Facts about Compute Domain in NFV!&lt;/a&gt;를 번역한 글입니다.&lt;/li&gt;
&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;NFV에 대해 생각해 보세요! 그리고 x86 프로세서를 생각해 보세요&amp;hellip; 둘은 뗄 수 없는 사이입니다. 그렇죠?&lt;/p&gt;
&lt;p&gt;프로세서(컴퓨팅 파트)가 아무리 단순하게 들리더라도 NFV의 컴퓨팅 도메인(compute domain)이 노드의 컴퓨팅 프로세서(compute processor)가 같지 않다는 사실을 모르는 사람이 많을 것입니다. 사실&amp;hellip; 훨씬 더 많습니다.&lt;/p&gt;
&lt;p&gt;NFV의 &amp;ldquo;Compute Domain&amp;quot;과 &amp;ldquo;Compute Node&amp;quot;는 ETSI 정의에 따르면 동일한 것을 의미하지 않습니다. 이를 잘 알고 있으면 NFV 기본 아키텍처를 이해하는 데 많은 혼란을 피할 수 있으며, 벤더 및 고객과 이 주제에 대해 소통하는 과정에서 오해를 피할 수 있습니다.&lt;/p&gt;
&lt;p&gt;물론 NFV의 뼈대를 제대로 세우고 싶을 겁니다. 그렇죠?&lt;/p&gt;
&lt;p&gt;뿐만 아니라 끝까지 읽으신다면 COTs, NIC, 하드웨어 가속기와 같이 매일 듣는 서버의 필수 용어가 명확해질 것입니다.&lt;/p&gt;
&lt;h1 id=&#34;우선-etsi의-용어로-compute-domain과-compute-node는-무엇일까요&#34;&gt;우선 ETSI의 용어로 &amp;ldquo;Compute Domain&amp;quot;과 &amp;ldquo;Compute Node&amp;quot;는 무엇일까요?&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/nfv/computer-domain-in-nfv.png&#34; alt=&#34;computer-domain-in-nfv&#34;&gt;&lt;/p&gt;
&lt;p&gt;(NFV 아키텍처에 대한 자세한 내용을 보려면 &lt;a href=&#34;../beginners-guide-to-nfv-mano/&#34;&gt;NFV 아키텍처&lt;/a&gt; 또는 &lt;a href=&#34;../cheat-sheet-understanding-nfv-architecture&#34;&gt;NFV MANO 치트 시트&lt;/a&gt;에 대한 글을 읽는 것이 좋습니다.)&lt;/p&gt;
&lt;p&gt;위의 NFV Infrastructure (NFVI) 블록에 명확히 나와 있듯이 컴퓨팅 도메인에는 컴퓨팅 하드웨어와 스토리지 하드웨어가 포함됩니다. 컴퓨팅 도메인은 상위 집합이며, 그 중 컴퓨팅 하드에어와 노드는 한 부분에 불과합니다.&lt;/p&gt;
&lt;p&gt;놀랍죠? 스토리지를 컴퓨팅 도메인의 일부로 생각하는 사람이 얼마나 되겠습니까?&lt;/p&gt;
&lt;p&gt;이제 컴퓨팅 도메인에 무엇이 포함되는지 자세히 살펴보겠습니다.&lt;/p&gt;
&lt;h1 id=&#34;컴퓨팅-도메인의-세-가지-부분&#34;&gt;컴퓨팅 도메인의 세 가지 부분&lt;/h1&gt;
&lt;h2 id=&#34;1-컴퓨팅-노드-compute-node&#34;&gt;1. 컴퓨팅 노드 (Compute Node)&lt;/h2&gt;
&lt;p&gt;상용 제품(COTS, Commercial Off-the-Shelf) 아키텍처에서 컴퓨팅 노드에는 멀티 코어 프로세서와 칩셋이 포함되어 있으며, 여기에는 다음과 같은 물리적 리소스가 포함될 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 및 칩셋 (예: x86, ARM etc.)&lt;/li&gt;
&lt;li&gt;메모리 하위 집합.&lt;/li&gt;
&lt;li&gt;임의의 하드웨어 가속기 (예: co-processor)&lt;/li&gt;
&lt;li&gt;NICs (임의의 가속기를 포함한 네트워크 인터페이스 카드)&lt;/li&gt;
&lt;li&gt;블레이드 내부 스토리지 (비휘발성 메모리, 로컬 디스크 스토리지)&lt;/li&gt;
&lt;li&gt;BIOS/부트 로더 (실행 환경의 일부)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;COTS 서버 블레이드는 컴퓨팅 노드의 한 가지 예입니다.&lt;/p&gt;
&lt;h2 id=&#34;2-네트워크-인터페이스-카드-nic-및-io-가속기&#34;&gt;2. 네트워크 인터페이스 카드 (NIC) 및 I/O 가속기&lt;/h2&gt;
&lt;p&gt;이전 섹션에서 컴퓨팅 노드의 일부로 NIC를 언급했습니다. 이건 사실입니다.
위의 경우 NIC 기능이 서버에 있기 때문입니다.
그러나 최근 세분화된 모델(예: &lt;a href=&#34;http://www.opencompute.org/about/&#34;&gt;Open Compute Project, OCP&lt;/a&gt;) 트렌드가 있습니다.
이 폼-팩터(form-factor)에서 CPU 블레이드/섀시는 NIC/가속기 섀시 및 스토리지 섀시와 분리됩니다.
이 블레이드/섀시들 간의 상호 연결은 광섬유를 통해 이루어질 수 있습니다.
이러한 이유로 NIC가 중요하기 때문에 별도로 설명합니다.&lt;/p&gt;
&lt;p&gt;NIC의 주요 기능은 CPU에 네트워크 I/O 기능을 제공하는 것입니다.&lt;/p&gt;
&lt;p&gt;NFV의 비전은 standard generic x86 서버에서 네트워크 기능을 실행하는 것입니다. 그러나 실제로 머신의 I/O 처리량을 향상시키기 위해 가속 기술을 요구하는 많은 I/O 집약적 애플리케이션(예: 가상 라우터)이 있습니다.&lt;/p&gt;
&lt;p&gt;일부 하드웨어 가속 기술에는 다음이 포함됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;디지털 신호 처리(DSP, Digital Signal Processing), 패킷 헤더 처리, 패킷 버퍼링 및 스케줄링과 같은 하드웨어 가속.&lt;/li&gt;
&lt;li&gt;캐시 관리 기능.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이외에 새로운 소프트웨어 가속 기능을 구현하는 명령어 집합 아키텍처(ISA, Instruction Set Architecture)(예: x86, ARMv8 등)가 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;3-스토리지-빌딩-블록&#34;&gt;3. 스토리지 빌딩 블록&lt;/h2&gt;
&lt;p&gt;스토리지 인프라는 주요 드라이브 유형들을 포함합니다. 반드시 이해하고 넘어가야 하는 하드 디스크 드라이브(HDD), 솔리드 스테이트 디스크(SDD), 캐시 스토리지 등이 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;31-hard-disk-drives-hdd&#34;&gt;3.1 Hard Disk Drives (HDD)&lt;/h3&gt;
&lt;p&gt;하드 디스크는 마그네틱 스토리지를 사용하여 마그네틱 재질로 코팅된 하나 이상의
견고한 고속 회전 디스크(플래터)를 사용하여 디지털 정보를 저장하고 검색하는 데이터 저장 장치입니다.
플래터는 표면에 데이터를 읽고 쓰는 자기 헤드(magnetic heads)와 쌍을 이룹니다.
데이터는 랜덤 액세스 방식으로 접근하므로 어느 순서로도 데이터를 검색할 수 있다는 장점이 있습니다.
HDD는 비휘발성 스토리지입니다. 즉, 전원이 꺼진 상태에서도 저장된 데이터를 유지할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;32-solid-state-disks-ssd&#34;&gt;3.2 Solid State Disks (SSD)&lt;/h3&gt;
&lt;p&gt;SSD는 HDD와 달리 움직이는 부품이 없습니다.
따라서 HDD에 비해 SSD는 일반적으로 물리적 충격에 더 강하고,
조용히 실행되며, 액세스 시간과 대기 시간이 짧습니다.
따라서 SSD는 상당한 랜덤 액세스가 필요한 애플리케이션에서 사용하기 적합한 기술입니다.
하지만 HDD에 비해 상대적으로 비쌉니다.&lt;/p&gt;
&lt;h3 id=&#34;33-hybrid-disk-drive&#34;&gt;3.3 Hybrid Disk Drive&lt;/h3&gt;
&lt;p&gt;점점 인기를 얻고 있는 하이브리드 하드 드라이브는 기존의 회전 플래터와
소량의 고속 플래시 메모리를 단일 드라이브에 배치하여 SSD 속도의 HDD 기능을 제공합니다.
그래서 SSD를 고속 캐시(또는 tier로 사용 가능)로 사용하고
HDD를 영구 스토리지에 사용한다는 것이 장점입니다.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Compute Node&amp;rdquo;, &amp;ldquo;NIC&amp;rdquo; 및 &amp;ldquo;Storage&amp;rdquo; 세 부분을 이해하면 컴퓨팅 도메인의 그림이 완성되고
완전한 NFV 아키텍처 서버를 만들기 때문에 정말 중요합니다.&lt;/p&gt;
- https://markruler.github.io/posts/nfv/the-misunderstood-facts-about-compute-domain-in-nfv/ - Im Changsu | Since 2020</description>
        </item>
    
    
    
        <item>
        <title>NFV MANO 초심자 가이드</title>
        <link>https://markruler.github.io/posts/nfv/beginners-guide-to-nfv-mano/</link>
        <pubDate>Wed, 23 Sep 2020 00:58:08 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/nfv/beginners-guide-to-nfv-mano/</guid>
        <description>임창수 https://markruler.github.io/posts/nfv/beginners-guide-to-nfv-mano/ -&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.telcocloudbridge.com/blog/a-beginners-guide-to-nfv-management-orchestration-mano/&#34;&gt;Faisal Khan의 A Beginner&amp;rsquo;s Guide to NFV Management &amp;amp; Orchestration (MANO)&lt;/a&gt;을 번역한 글입니다.&lt;/li&gt;
&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#nfv%EC%97%90%EC%84%9C-mano%EB%9E%80&#34;&gt;NFV에서 MANO란?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1-virtualized-infrastructure-manager-vim&#34;&gt;1. Virtualized Infrastructure Manager (VIM)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-virtual-network-function-manager-vnfm&#34;&gt;2. Virtual Network Function Manager (VNFM)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-nfv-orchestrator-nfvo&#34;&gt;3. NFV Orchestrator (NFVO)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#resource-orchestration&#34;&gt;Resource Orchestration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#service-orchestration&#34;&gt;Service Orchestration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-repositories&#34;&gt;4. Repositories&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#vnf-catalog&#34;&gt;VNF Catalog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#network-services-ns-catalog&#34;&gt;Network Services (NS) Catalog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nfv-instances&#34;&gt;NFV Instances&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nfvi-resources&#34;&gt;NFVI Resources&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-element-management-em&#34;&gt;5. Element Management (EM)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-ossbss&#34;&gt;6. OSS/BSS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-reference-points&#34;&gt;7. Reference Points&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NFV가 처음이라면 NFV Management &amp;amp; Orchestration (NFV MANO)를 이해하려고 할 때 두 가지 어려운 점이 있습니다.&lt;/p&gt;
&lt;p&gt;첫번째로 기존의 네트워크는 EMS, NMS 또는 OSS가 지원하는 것처럼 하나의 관리 시스템만 필요하지만
NFV 네트워크는 VIM 관리자, VNF 관리자, 오케스트레이터와 같이 여러 관리자가 필요합니다.
이것도 괜찮다면 기존 EMS와 OSS/BSS가 있습니다.
즉, 5개의 다른 관리 시스템이 필요합니다.
이 정도만 해도 NFV 초심자에게는 충분히 어렵습니다.&lt;/p&gt;
&lt;p&gt;두번째로 NFV MANO 모델을 단순하게 설명하는 정보가 부족합니다.
예를 들어 Google의 많은 기술들은 주로 벤더의 MANO 구현 방식을 설명합니다.&lt;/p&gt;
&lt;p&gt;ETSI 표준과 같이 MANO 아키텍처를 정의하는 표준 레퍼런스 문서가 있다고 해도
초심자가 그 문서들을 따라가기는 쉽지 않습니다.&lt;/p&gt;
&lt;p&gt;하지만 ETSI의 MANO 모델을 이해하는 것은 굉장히 중요합니다.
우선 ETSI는 NFV 아키텍처와 프레임워크 정의에 상당한 작업을 한 최초이자 유일한 표준 기관입니다.
따라서 ETSI 모델을 이해하여 MANO를 이해할 만한 가치가 있습니다.&lt;/p&gt;
&lt;p&gt;이 글은 가능한 한 간단하게 ETSI MANO 모델을 보여주려는 조그만 시도입니다.&lt;/p&gt;
&lt;p&gt;그 전에 하나만 묻겠습니다!&lt;/p&gt;
&lt;p&gt;먼저 NFV MANO에 대해 아는 것이 왜 중요할까요?&lt;/p&gt;
&lt;p&gt;그 이유는 MANO가 NFV 아키텍처의 심장과 두뇌 역할을 하며
MANO를 이해하는 것은 전체 NFV 아키텍처를 명확하게 해줄 것이기 때문입니다.&lt;/p&gt;
&lt;p&gt;두번째로 ETSI 모델을 참조하여 모든 벤더의 NFV 솔루션을 이해하고 벤치마킹하는 데 도움이 될 것입니다.&lt;/p&gt;
&lt;p&gt;아니면 당신은 곧 RFP 작성을 끝내야하며 MANO 부분에 무엇을 포함해야 하는지 알고 싶을 수도 있습니다.&lt;/p&gt;
&lt;p&gt;목표가 무엇이든 이 가이드로부터 무언가 얻고 가시기를 바랍니다.&lt;/p&gt;
&lt;p&gt;(NFV 용어를 다시 상기해야 할 경우 &lt;a href=&#34;../cheat-sheet-understanding-nfv-architecture/&#34;&gt;NFV 아키텍처의 치트 시트&lt;/a&gt;를 참조하세요)&lt;/p&gt;
&lt;h1 id=&#34;nfv에서-mano란&#34;&gt;NFV에서 MANO란?&lt;/h1&gt;
&lt;p&gt;MANO는 관리 및 오케스트레이션(Management and Orchestration)을 의미합니다.&lt;/p&gt;
&lt;p&gt;MANO는 아래 다이어그램에서 세 가지 관리자를 포함하는 회색 블록입니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Virtualized Infrastructure Manager (VIM).&lt;/li&gt;
&lt;li&gt;VNF Manager (VNFM).&lt;/li&gt;
&lt;li&gt;NFV Orchestrator (VNFO).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그리고 리포지토리 그룹까지(블록 4, 그 밑에 더 있음)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/nfv/mano-in-nfv.png&#34; alt=&#34;mano-in-nfv&#34;&gt;&lt;/p&gt;
&lt;p&gt;MANO 내부에 있는 4개의 블록 외에도, 외부에 기존의 요소 관리(EM)와 OSS/BSS라는 두 개의 블록이 있습니다.
두 블록은 MANO에 직접 속하지 않지만 MANO와 정보를 교환하기 때문에, 초심자는 MANO 블록과 적절한 위치에 두어야 합니다.&lt;/p&gt;
&lt;p&gt;가상화 인프라 매니저(VIM)부터 6개 블록에 대해 설명드리겠습니다.&lt;/p&gt;
&lt;h1 id=&#34;1-virtualized-infrastructure-manager-vim&#34;&gt;1. Virtualized Infrastructure Manager (VIM)&lt;/h1&gt;
&lt;p&gt;VIM은 &lt;code&gt;하나의 도메인&lt;/code&gt;에서 NFVI 리소스를 관리합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NFVI는 NFV 환경의 물리 자원(서버, 스토리지 등), 가상 자원(가상 머신), 소프트웨어 자원(하이퍼바이저)을 포함하는 NFV 인프라(Network Functions Virtualization Infrastructure)입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여기에서 &lt;code&gt;하나의 도메인&lt;/code&gt;이라는 단어를 기억하세요.
NFV 아키텍처에는 각각의 NFVI 도메인을 관리하는 &lt;code&gt;multiple VIM&lt;/code&gt;이 있을 수 있습니다.
오케스트레이터 섹션에서 다시 볼 것이므로 &lt;code&gt;multiple VIM&lt;/code&gt;이라는 개념을 염두에 두세요.&lt;/p&gt;
&lt;p&gt;그렇다면 VIM이 일반적으로 처리하는 작업은 무엇일까요?&lt;/p&gt;
&lt;p&gt;다음과 같은 작업을 처리합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NFVI 도메인에 있는 가상 자원의 라이프사이클 관리. 즉, NFVI 도메인의 물리 자원으로부터 VM(가상 머신)을 생성, 유지, 해제하는 것&lt;/li&gt;
&lt;li&gt;물리 자원과 연결된 가상 머신(VM) 목록 유지&lt;/li&gt;
&lt;li&gt;하드웨어, 소프트웨어, 가상 자원의 성능 및 장애 관리&lt;/li&gt;
&lt;li&gt;Northbound API를 유지하여 물리/가상 자원을 다른 관리 시스템에 노출&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-virtual-network-function-manager-vnfm&#34;&gt;2. Virtual Network Function Manager (VNFM)&lt;/h1&gt;
&lt;p&gt;VIM이 NFVI을 위한 것이라면 VNFM은 VNF을 위한 것입니다.&lt;/p&gt;
&lt;p&gt;즉, VNFM은 VNF를 관리합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;VNF는 라우터 VNF, 스위치 VNF 등과 같은 가상화된 네트워크 요소입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;구체적으로 VNFM은 다음을 수행합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VNFM은 VNF의 라이프사이클을 관리. 즉, VNF 인스턴스를 생성, 유지, 종료(VIM이 생성하고 관리하는 VM에 설치됨)&lt;/li&gt;
&lt;li&gt;VNF의 FCAPS(즉, VNF의 장애, 구성, 계정, 성능, 보안) 관리&lt;/li&gt;
&lt;li&gt;VNF를 스케일 업/다운하여 CPU 사용량을 스케일 업/다운&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;별도의 VNF를 관리하는 VNFM이 여러 개 있을 수도 있고,
여러 VNF를 관리하는 하나의 VNFM이 있을 수도 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;3-nfv-orchestrator-nfvo&#34;&gt;3. NFV Orchestrator (NFVO)&lt;/h1&gt;
&lt;p&gt;위의 섹션 1과 2를 살펴보셨다면 NFVO가 왜 필요한지 알 수 있을 것입니다.&lt;/p&gt;
&lt;p&gt;위의 섹션 1에서 보았듯이, 각각의 NFVI 도메인을 관리하는 VIM이 여러 개 있을 수 있습니다. 이것은 &lt;code&gt;과제 1&lt;/code&gt;을 만듭니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;과제 1&lt;/p&gt;
&lt;p&gt;동일한 또는 서로 다른 PoP(Point of Presence)에 여러 VIM이 있는 경우, 누가 다른 VIM의 자원을 관리/조정할까요?
섹션 2에서 언급한 바와 같이, 각각의 VNF를 관리하는 VNFM이 여러 개 있을 수 있습니다. 이것은 &lt;code&gt;과제 2&lt;/code&gt;를 만듭니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;과제 2&lt;/p&gt;
&lt;p&gt;서로 다른 VNFM 도메인의 VNF를 포함하는 종단 간(end-to-end) 서비스 생성을
누가 관리/조정할까요?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이러한 과제는 NFVO의 다음 두 가지 기능이 해결해 줍니다.&lt;/p&gt;
&lt;h2 id=&#34;resource-orchestration&#34;&gt;Resource Orchestration&lt;/h2&gt;
&lt;p&gt;NFVO는 서로 다른 PoP 간에 또는 하나의 PoP 내에서 NFVI 자원을 조정, 승인, 해제, 결합합니다.
이는 NFVI 자원을 직접 사용하는 대신 Northbound API를 통해 VIM과 직접 연결함으로써 수행합니다.&lt;/p&gt;
&lt;p&gt;이 기능은 서로 다른 VIM의 자원 할당하는 &lt;code&gt;과제 1&lt;/code&gt;을 직접 해결합니다.&lt;/p&gt;
&lt;h2 id=&#34;service-orchestration&#34;&gt;Service Orchestration&lt;/h2&gt;
&lt;p&gt;서비스 오케스트레이션은 서로 다른 VNF(다른 VNFM이 관리할 수 있는) 간에 종단 간 서비스를 생성하는 &lt;code&gt;과제 2&lt;/code&gt;를 해결합니다.&lt;/p&gt;
&lt;p&gt;다음과 같은 방법으로 해결합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서비스 오케스트레이션은 VNF와 직접 통신할 필요가 없도록 각 VNFM과 조정하여 서로 다른 VNF 간에 종단 간 서비스를 생성합니다.
예를 들면 한 벤더의 기지국 VNF와 다른 벤더의 중심 노드 VNF 사이에 서비스를 생성하는 것입니다.&lt;/li&gt;
&lt;li&gt;서비스 오케스트레이션은 해당되는 VNFM을 인스턴스화할 수 있습니다.&lt;/li&gt;
&lt;li&gt;네트워크 서비스 인스턴스의 토폴로지(&lt;a href=&#34;https://docs.openstack.org/tacker/queens/user/vnffg_usage_guide.html&#34;&gt;VNF Forwarding Graph&lt;/a&gt;, &lt;code&gt;VNFFG&lt;/code&gt;라고도 함)도 관리합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NFVO가 서로 다른 기능을 결합하고 서로 다른 방법으로 분산된 NFV 환경에서 종단 간 서비스를 생성하며 자원을 조정하는,
NFV의 접착제와 같다는 점을 알 수 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;4-repositories&#34;&gt;4. Repositories&lt;/h1&gt;
&lt;p&gt;NFV MANO에서 서로 다른 정보를 저장하는 리포지토리(파일/목록)를 이해하는 것은 매우 중요합니다.
리포지토리에는 네 가지 유형이 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;vnf-catalog&#34;&gt;VNF Catalog&lt;/h2&gt;
&lt;p&gt;VNF 카탈로그는 사용 가능한 모든 VNFD(VNF Descriptor)의 저장소입니다.&lt;/p&gt;
&lt;p&gt;VNFD는 VNF의 배포 및 동작 요구 사항 측면에서 VNF를 설명하는 배포 템플릿(deployment template)입니다.
주로 VNFM이 VNF 인스턴스화 및 VNF 인스턴스의 라이프사이클 관리 프로세스에서 사용합니다.
VNFD에서 제공된 정보는 NFVO가 NFVI의 네트워크 서비스와 가상화된 자원을 관리 및 조정하는 데도 사용됩니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[역주] 예시&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docbox.etsi.org/ISG/NFV/Open/other/Tutorials/201810-Tutorials-SDN_NFV_World_Congress-The_Haque/ETSI_NFV_Layer123_SDN_NFV_WC_2018_VNFD_RX15002.pdf&#34;&gt;VNF Descriptor (VNFD) Overview | ETSI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.openstack.org/tacker/newton/devref/vnfd_template_description.html&#34;&gt;VNF Descriptor Template Guide | Openstack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;network-services-ns-catalog&#34;&gt;Network Services (NS) Catalog&lt;/h2&gt;
&lt;p&gt;사용 가능한 네트워크 서비스의 목록입니다.
가상 링크를 통한 연결에 대한 설명과 VNF 측면에서 네트워크 서비스를 위한 배포 템플릿은 향후 사용을 위해 NS 카탈로그에 저장됩니다.&lt;/p&gt;
&lt;h2 id=&#34;nfv-instances&#34;&gt;NFV Instances&lt;/h2&gt;
&lt;p&gt;NFV 인스턴스 목록에는 네트워크 서비스 인스턴스 및 관련 VNF 인스턴스에 대한 모든 세부 정보가 들어 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;nfvi-resources&#34;&gt;NFVI Resources&lt;/h2&gt;
&lt;p&gt;NFV 서비스 구축에 활용되는 NFVI 자원의 리포지토리입니다.&lt;/p&gt;
&lt;p&gt;다음 두 가지 관리 시스템은 NFV MANO에 속하지 않지만 NFVO MANO 기능 블록과 정보를 교환하기 때문에 설명합니다.&lt;/p&gt;
&lt;h1 id=&#34;5-element-management-em&#34;&gt;5. Element Management (EM)&lt;/h1&gt;
&lt;p&gt;EM은 MANO에 속하지 않지만 중요한 역할을 합니다.&lt;/p&gt;
&lt;p&gt;EM은 VNF의 기능 부분에 대한 FCAPS를 담당합니다.
VNFM은 VNF의 FCAPS도 하지만 가상 부분에서만 합니다.&lt;/p&gt;
&lt;p&gt;명확히 하기 위해 예를 들면, 일반적으로 MANO는 가상과 물리적 세계의 델타에만 책임이 있습니다.
VNFM을 예로 들면 VNF의 라이프사이클 관리와 FCAPS를 수행합니다.
장애 관리(fault management) 측면에서 VNF를 실행하는 데 문제가 있으면 VNFM이 보고하지만,
기능과 관련된 장애인 경우(예: 모바일 코어에서 일부 신호 전달 문제) EM이 보고합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;델타(delta): 수학에서 &lt;code&gt;&#39;차이&#39;&lt;/code&gt;, &lt;code&gt;&#39;변화&#39;&lt;/code&gt;를 나타냄.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;VNFM은 운영자가 모든 종류의 FCAPS(가상 + 기능)에 대해 단일 GUI를 사용하고자 하는 경우에 대비하여 EM에 인터페이스를 노출시킵니다.&lt;/p&gt;
&lt;h1 id=&#34;6-ossbss&#34;&gt;6. OSS/BSS&lt;/h1&gt;
&lt;p&gt;OSS/BSS는 서비스 사업자가 사업을 운영하기 위해 사용하는 시스템/애플리케이션 모음을 포함합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;OSS: Operations Support Systems&lt;/li&gt;
&lt;li&gt;BSS: Business Support Systems&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;NFV는 OSS/BSS와 같이 동작해야 합니다.&lt;/p&gt;
&lt;p&gt;원칙적으로는 VNF와 NFVI를 직접 관리하기 위해 기존 OSS/BSS의 기능을 확장할 수 있지만,
그것은 벤더의 독점적 구현일 수 있습니다.
(적어도 현재까지는 ETSI가 EM과 VNF 간의 인터페이스는 정의하지 않았습니다.)
NFV는 오픈 플랫폼(open platform)이기 때문에 MANO처럼 오픈 인터페이스(open interfaces)를 통해 NFV 엔터티를 관리하는 것이 더 타당합니다.&lt;/p&gt;
&lt;p&gt;그러나 기존의 OSS/BBS는 NFV MANO의 특정 구현으로 인해 지원되지 않는 경우,
추가 기능을 제공함으로써 NFV MANO에 부가 가치를 만들 수 있습니다.
이는 NFV MANO와 기존 OSS/BSS 사이의 &lt;a href=&#34;https://telcocloudbridge.com/blog/open-ran-tutorial/&#34;&gt;오픈 참조점(open reference point)&lt;/a&gt;(Or-Ma-NFVO)을 통해 이루어집니다.&lt;/p&gt;
&lt;h1 id=&#34;7-reference-points&#34;&gt;7. Reference Points&lt;/h1&gt;
&lt;p&gt;마지막으로 &lt;code&gt;참조점&lt;/code&gt;에 대해 언급할 가치가 있습니다.&lt;/p&gt;
&lt;p&gt;MANO에는 그림과 같이 기능 블록 간의 연결 포인트(interconnection point)로 표시되는 여러 참조점이 있습니다.
Or-Vi, NF-Vi, Or-Vnfm 등입니다.&lt;/p&gt;
&lt;p&gt;왜 MANO는 그들을 인터페이스가 아닌 참조점이라고 부를까요?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;인터페이스&lt;/code&gt;가 엔터티 간의 양방향 통신을 허용하는 것과 관련이 있기 때문에 MANO는 참조점을 인터페이스라고 부르지 않습니다.
참조점은 기능 블록의 외부 관점(external view)을 정의하고 노출하는 아키텍처 개념입니다.
그리고 MANO는 기능 블록에 대해 이야기하기 때문에 &lt;code&gt;참조점&lt;/code&gt;이라는 단어를 대신 사용합니다.&lt;/p&gt;
&lt;p&gt;이것이 NFV MANO에 대한 전부입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;당신의 견해를 알려주세요.
최종 사용자라면 NFV의 여러 관리 시스템에 대해 어떻게 생각하시나요?
그들이 당신에게 타당한가요?
기존 EMS/OSS와 어떻게 비교하시나요?&lt;br&gt;
&lt;br&gt;
벤더라면 NFV MANO에서 구현 중인 부분과 힘든 점은 무엇인가요?
어떠한 견해라도 알려주세요.&lt;/p&gt;
&lt;/blockquote&gt;
- https://markruler.github.io/posts/nfv/beginners-guide-to-nfv-mano/ - Im Changsu | Since 2020</description>
        </item>
    
    
    
        <item>
        <title>&#34;NFV 아키텍처&#34; 이해를 위한 치트 시트</title>
        <link>https://markruler.github.io/posts/nfv/cheat-sheet-understanding-nfv-architecture/</link>
        <pubDate>Tue, 22 Sep 2020 21:58:08 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/nfv/cheat-sheet-understanding-nfv-architecture/</guid>
        <description>임창수 https://markruler.github.io/posts/nfv/cheat-sheet-understanding-nfv-architecture/ -&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.telcocloudbridge.com/blog/a-cheat-sheet-for-understanding-nfv-architecture/&#34;&gt;Faisal Khan의 A Cheat Sheet for Understanding &amp;ldquo;NFV Architecture&amp;rdquo;&lt;/a&gt;를 번역한 글입니다.&lt;/li&gt;
&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;시간이 없으신가요?&lt;/p&gt;
&lt;p&gt;쉽게 이해할 수 있는 NFV 용어/아키텍처에 대한 빠른 업데이트가 필요하신가요?&lt;/p&gt;
&lt;p&gt;그렇다면 NFV 아키텍처를 시작하는 데 필요한 모든 정보를 얻을 수 있는 아래 7가지 주요 블록을 보세요.
블록 번호 및 정의를 따라가세요.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/nfv/nfv-architecture.png&#34; alt=&#34;nfv-architecture&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-vnf-virtual-network-function&#34;&gt;1. VNF (Virtual Network Function)&lt;/h2&gt;
&lt;p&gt;VNF는 가상화된 네트워크 요소로 NFV 아키텍처의 기본 블록입니다.
예를 들어 라우터를 가상화하면 라우터 VNF라고 부르고, 다른 예는 기지국(base station) VNF도 있습니다.
네트워크 요소의 한 가지 하위 기능(sub-function)만 가상화해도 VNF라고 합니다.
예를 들어 라우터의 다양한 하위 기능은 가상 라우터로서 함께 작동하는 별도의 VNF가 될 수 있다.&lt;/p&gt;
&lt;p&gt;VNF의 다른 예로는 방화벽(firewall), IPS, GGSN, SGSN, RNC, EPC 등이 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;2-em-element-management&#34;&gt;2. EM (Element Management)&lt;/h2&gt;
&lt;p&gt;EM은 VNF의 요소 관리 시스템(EMS)입니다.
이것은 VNF(즉, FCAPS: Fault, Configuration, Accounting, Perfomance, Security) 기능을 관리합니다.
독점적 인터페이스를 통해 VNF를 관리할 수도 있습니다.
VNF당 1개의 EMS가 있을 수도 있고 하나의 EMS가 여러 개의 VNF를 관리할 수도 있습니다.
EMS 자체가 VNF일 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;3-vnf-manager&#34;&gt;3. VNF Manager&lt;/h2&gt;
&lt;p&gt;VNF 매니저는 하나 또는 여러 VNF 인스턴스의 라이프사이클을 관리합니다.
라이프사이클 관리란 VNF를 할당, 유지, 해제하는 것을 말합니다.&lt;/p&gt;
&lt;p&gt;또한 VNFM(VNF 매니저)은 VNF의 가상 부분에 대해 FCAPS를 수행한다.&lt;/p&gt;
&lt;p&gt;EM 및 VNFM의 차이에 유의해야 합니다.
EM은 기능 요소를 관리하는 반면, VNFM은 가상 요소를 관리합니다.
다음 예시로 명확하게 설명하겠습니다. 모바일 코어가 가상화된 경우,
EM은 기능 부분(예: 모바일 신호 전달)을 관리하고,
VNFM은 가상 부분(예: 자체 VNF 생성)을 관리합니다.&lt;/p&gt;
&lt;h2 id=&#34;4-nfvi-network-function-virtualization-infrastructure&#34;&gt;4. NFVI (Network Function Virtualization Infrastructure)&lt;/h2&gt;
&lt;p&gt;NFVI는 VNF가 실행되는 환경입니다.
여기에는 아래에 설명된 물리 자원, 가상 자원 및 가상화 계층이 포함된다.&lt;/p&gt;
&lt;h3 id=&#34;41-compute-memory-and-networking-resources&#34;&gt;4.1 Compute, Memory and Networking Resources&lt;/h3&gt;
&lt;p&gt;NFVI의 물리적인 부분입니다.
가상 자원은 이러한 물리 자원에 의해 인스턴스화 됩니다.
모든 물리 스위치 또는 물리 서버, 물리 스토리지 서버는 이 범주에 포함됩니다.&lt;/p&gt;
&lt;h3 id=&#34;42-virtual-compute-virtual-memory-and-virtual-networking-resources&#34;&gt;4.2 Virtual Compute, Virtual Memory and Virtual Networking Resources&lt;/h3&gt;
&lt;p&gt;NFVI의 가상 부분입니다.
물리 자원은 궁극적으로 VNF가 활용하는 가상 자원으로 추상화됩니다.&lt;/p&gt;
&lt;h3 id=&#34;43-virtualization-layer&#34;&gt;4.3 Virtualization Layer&lt;/h3&gt;
&lt;p&gt;가상화 계층은 물리 자원을 가상 자원으로 추상화하는 역할을 담당합니다. 일반적인 산업 용어로 &lt;code&gt;하이퍼바이저&lt;/code&gt;라고 합니다.
이 계층은 소프트웨어가 하드웨어로부터 독립적으로 실행될 수 있도록 합니다.&lt;/p&gt;
&lt;p&gt;가상화 계층이 없다고 가정할 때, VNF가 물리 자원에서 직접 실행될 수 있다고 생각할 수 있습니다.
그러나 정의상 VNF라고 부를 수 없으며 NFV 아키텍처라고도 할 수 없습니다.
적절하게 PNF(물리 네트워크 기능)라고 불릴 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;5-vim-virtualized-infrastructure-manager&#34;&gt;5. VIM (Virtualized Infrastructure Manager)&lt;/h2&gt;
&lt;p&gt;NFVI를 위한 관리 시스템입니다.
한 사업자의 인프라 도메인 내에서 NFVI 컴퓨팅, 네트워크 및 스토리지 리소스를 제어하고 관리합니다.
성능 측정 및 이벤트 수집도 담당합니다.&lt;/p&gt;
&lt;h2 id=&#34;6-nfv-orchestrator&#34;&gt;6. NFV Orchestrator&lt;/h2&gt;
&lt;p&gt;VNF의 네트워크 서비스를 직접 생성, 유지, 해제합니다.
VNF가 여러 개 있는 경우 여러 VNF 종단 간(end-to-end) 서비스를 생성할 수 있도록 합니다.&lt;/p&gt;
&lt;p&gt;NFVI 자원의 전역 자원(global resource)도 관리합니다.
예를 들어 네트워크에 있는 여러 VIM 간에 컴퓨팅, 스토리지 및 네트워킹 자원 등의 NFVI 자원을 관리합니다.&lt;/p&gt;
&lt;p&gt;오케스트레이터는 VNF와 직접 통신하지 않고 VNFM과 VIM을 통해 기능을 수행합니다.&lt;/p&gt;
&lt;p&gt;예시:
종단 간 서비스를 생성하기 위해 체인을 연결해야 하는 VNF가 여러 개 있다고 가정해 봅시다.
이러한 사례의 한 예는 가상 기지국과 가상 EPC입니다. 이것들은 동일하거나 다른 벤더일 수 있습니다.
양쪽의 VNF를 모두 사용하여 종단 간 서비스를 생성해야 할 것입니다.
이를 위해서는 서비스 오케스트레이터가 두 VNF와 통신하여 종단 간 서비스를 생성해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;7-ossbssoperation-support-systembusiness-support-system&#34;&gt;7. OSS/BSS(Operation Support System/Business Support System)&lt;/h2&gt;
&lt;p&gt;OSS/BSS는 사업자의 OSS/BSS를 말한다.
OSS는 네트워크, 장애, 구성, 서비스를 관리합니다.
BSS는 고객, 제품, 주문 등을 관리합니다.&lt;/p&gt;
&lt;p&gt;NFV 아키텍처에서 사업자의 현재 BSS/OSS는 표준 인터페이스를 통해 NFV MANO (Management and Orchestration)와 통합할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이게 전부입니다!&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.telcocloudbridge.com/blog/a-cheat-sheet-for-understanding-nfv-architecture/&#34;&gt;원문 링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;사용 사례 및 SDN과의 관계를 포함한 NFV에 대한 자세한 내용을 보려면
헤더 섹션의 링크에서 NFV 마인드맵을 다운로드하세요.
개념을 더 쉽게 따라가기 위해 레퍼런스로 사용할 수 있도록 NFV 마인드 맵을 만들었습니다.&lt;/p&gt;
&lt;p&gt;코멘트를 남겨서 NFV 아키텍처용 &lt;code&gt;치트 시트&lt;/code&gt;에 대해 어떻게 생각하는지 알려주세요.&lt;/p&gt;
- https://markruler.github.io/posts/nfv/cheat-sheet-understanding-nfv-architecture/ - Im Changsu | Since 2020</description>
        </item>
    
    
  </channel>
</rss> 