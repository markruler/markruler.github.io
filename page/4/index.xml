<?xml-stylesheet href="/rss.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>임창수</title>
    <link>https://markruler.github.io/</link>
    <description>Recent content on 임창수</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <managingEditor>imcxsu@gmail.com (Im Changsu)</managingEditor>
    <webMaster>imcxsu@gmail.com (Im Changsu)</webMaster>
    <copyright>Im Changsu 2020 - 2024</copyright>
    <lastBuildDate>Fri, 06 Dec 2024 13:26:00 +0900</lastBuildDate>
    
        <atom:link href="https://markruler.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>VIM 에디터 명령어 정리</title>
        <link>https://markruler.github.io/posts/shell/vim-editor-shortcuts/</link>
        <pubDate>Mon, 07 Dec 2020 00:44:00 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/shell/vim-editor-shortcuts/</guid>
        <description>임창수 https://markruler.github.io/posts/shell/vim-editor-shortcuts/ -&lt;blockquote&gt;
&lt;p&gt;업무 중에 구성 파일을 편집하기 위해 VIM 에디터를 사용할 일이 많은데,
VIM 명령어 중에서도 가장 자주 쓰는 명령어를 정리한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;설정&#34;&gt;설정&lt;/h1&gt;
&lt;p&gt;설정 파일인 &lt;code&gt;~/.vimrc&lt;/code&gt;에서 큰따옴표(&lt;code&gt;&amp;quot;&lt;/code&gt;, double quote)가 앞에 있다면 주석(comment)이 된다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-vim&#34; data-lang=&#34;vim&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;syntax&lt;/span&gt; on &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;구문강조 사용&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;colorscheme&lt;/span&gt; desert &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;color 폴더에 colorscheme 설치 필요&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; background=dark &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;하이라이팅 lihgt / dark&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; autoindent
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; shiftwidth=&lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;autoindent width&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; ts=&lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;tabstop, width&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; softtabstop=&lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; cindent &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;C Language indent&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; nu &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;number&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; cul &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;Highlight current line&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; hls &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;hlsearch, 검색어 강조&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; incsearch &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;키워드 입력시 점진적 검색&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; ic &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;ignorecase, 검색시 대소문자 무시&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; expandtab &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;탭 대신 스페이스&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; laststatus=&lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;status line&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; nowrapscan &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;검색할 때 문서의 끝에서 처음으로 안돌아감&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; visualbell &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;키를 잘못눌렀을 때 화면 프레시&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; ruler &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;화면 우측 하단에 현재 커서의 위치(줄,칸) 표시&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; fileencoding=utf&lt;span style=&#34;color:#f60&#34;&gt;-8&lt;/span&gt; &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;파일저장인코딩&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; tenc=utf&lt;span style=&#34;color:#f60&#34;&gt;-8&lt;/span&gt; &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;터미널 인코딩&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; history=&lt;span style=&#34;color:#f60&#34;&gt;1000&lt;/span&gt; &lt;span style=&#34;color:#0f0&#34;&gt;&amp;#34;vi 편집기록 기억갯수 .viminfo에 기록&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;set&lt;/span&gt; showbreak=+++\
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/shell/vim.png&#34; alt=&#34;vim&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;입력-모드-insert-mode&#34;&gt;입력 모드 (Insert Mode)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; 현재 커서에서 편집
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Shift + i&lt;/code&gt; 현재 줄의 처음으로 커서를 옮긴 후 편집&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 현재 커서 한 글자 삭제 후 바로 입력 모드
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Shift + s&lt;/code&gt; 현재 줄 삭제 후 바로 입력 모드&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; 다음 칸으로 커서를 옮긴 후 편집
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Shift + a&lt;/code&gt; 현재 줄의 끝으로 커서를 옮긴 후 편집&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt; 다음 줄로 커서를 옮긴 후 편집
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Shift + o&lt;/code&gt; 이전 줄로 커서를 옮긴 후 편집&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;마지막-행-모드-last-line-mode&#34;&gt;마지막 행 모드 (Last Line Mode)&lt;/h1&gt;
&lt;h2 id=&#34;last-line-command-&#34;&gt;Last Line Command (:)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:q&lt;/code&gt; 종료&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:q!&lt;/code&gt; 강제 종료&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:w&lt;/code&gt; 저장&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:%s/old/new/gi&lt;/code&gt; 문자열 교체 (old -&amp;gt; new)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt; 옵션을 빼면 해당 줄의 첫 번째 문자열만 교체&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:!&lt;/code&gt; 명령어 실행
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:!ls&lt;/code&gt; 현재 디렉토리 파일 목록 출력&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:!pwd&lt;/code&gt; 현재 디렉토리 경로 출력&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:!date&lt;/code&gt; 현재 시간 출력&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:tabnew [file]&lt;/code&gt; 새로운 탭 열기 (file이 없으면 빈 탭)
&lt;ul&gt;
&lt;li&gt;실제로는 에디터 밖에서도 사용할 수 있는 tmux나 terminal 자체 기능을 활용하는 편.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gt&lt;/code&gt; 다음 탭으로 이동하기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gT&lt;/code&gt; 이전 탭으로 이동하기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;search-mode--&#34;&gt;Search mode (/, ?)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/regex-pattern&lt;/code&gt; (&lt;code&gt;?regex-pattern&lt;/code&gt;) 검색
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt; 다음 단어 (?는 반대)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N&lt;/code&gt; 이전 단어 (?는 반대)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;명령-모드-command-mode&#34;&gt;명령 모드 (Command Mode)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt; - undo&lt;/li&gt;
&lt;li&gt;&lt;code&gt;control + r&lt;/code&gt; - redo&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; - 이전 명령 다시 실행&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;이동&#34;&gt;이동&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hjkl&lt;/code&gt; 좌하상우 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + b&lt;/code&gt; 이전 페이지로 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + f&lt;/code&gt; 다음 페이지로 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + u&lt;/code&gt; 이전 half page로 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + d&lt;/code&gt; 다음 half page로 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gg&lt;/code&gt; 문서 맨 앞으로 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G&lt;/code&gt; 문서 맨 뒤로 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; 현재 줄 앞으로 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; 현재 줄 끝으로 이동&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;간단한-편집&#34;&gt;간단한 편집&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt; 복사 (yank)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt; 붙여넣기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; 들여쓰기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; 내어쓰기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Shift + j&lt;/code&gt; 현재 줄과 다음 줄 합치기&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;삭제&#34;&gt;삭제&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; 현재 커서 한 글자 교체(replace)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; 현재 커서 한 글자 삭제 (delete)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Shift + x&lt;/code&gt; 현재 커서 앞에 한 글자 삭제 (backspace)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:1,.d&lt;/code&gt; 첫 번째 줄부터 현재 커서까지 삭제 (LLM)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:5,10d&lt;/code&gt; 5번 줄부터 10번 줄까지 삭제 (LLM)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dd&lt;/code&gt; 현재 줄 삭제 (이후 p를 통해 삭제한 줄을 붙여넣을 수 있다)
&lt;ul&gt;
&lt;li&gt;이동키와 조합해 삭제할 수도 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;5dd&lt;/code&gt; 현재 줄 포함 아래로 5줄 삭제&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dgg&lt;/code&gt; 현재 커서에서 첫 줄까지 삭제&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dG&lt;/code&gt; 현재 커서에서 마지막 줄까지 삭제&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d$&lt;/code&gt; 현재 커서에서 현재 줄 마지막 단어까지 삭제&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d^&lt;/code&gt; 현재 커서에서 현재 줄 첫 단어까지 삭제&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dw&lt;/code&gt; 현재 커서에서 현재 단어까지 삭제&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;비주얼-모드visual-mode&#34;&gt;비주얼 모드(visual mode)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;v&lt;/code&gt; 비주얼 모드&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shift + v&lt;/code&gt; 비주얼 라인&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl + v&lt;/code&gt; 비주얼 블록
&lt;ul&gt;
&lt;li&gt;비주얼 블록 모드에서 &lt;code&gt;Shift + i&lt;/code&gt;를 누르면 블록의 첫 줄에 커서가 위치하고, 입력 모드로 전환된다.&lt;/li&gt;
&lt;li&gt;입력을 마치고 &lt;code&gt;ESC&lt;/code&gt;를 누르면 블록의 모든 줄에 입력한 내용이 삽입된다. (여러 줄을 주석 처리할 때 유용)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;화면-분할&#34;&gt;화면 분할&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;탭 기능과 동일하게 터미널 자체 기능을 선호하는 편.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;s&lt;/code&gt; horizontal split
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt; horizontal split한 후 새로운 창 생성&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;v&lt;/code&gt; vertical split
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vs&lt;/code&gt; vertical split한 후 현재 창 복제&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;방향키&lt;/code&gt; 분할된 창 간 이동&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;&amp;gt;&lt;/code&gt; 창 폭 늘리기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;&amp;lt;&lt;/code&gt; 창 폭 줄이기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;+&lt;/code&gt; 창 높이 늘리기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;-&lt;/code&gt; 창 높이 줄이기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;=&lt;/code&gt; 창 폭, 높이 원래 상태로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + w&lt;/code&gt; + &lt;code&gt;o&lt;/code&gt; only one window&lt;/li&gt;
&lt;/ul&gt;
- https://markruler.github.io/posts/shell/vim-editor-shortcuts/ - Im Changsu 2020 - 2024</description>
        </item>
    
    
    
        <item>
        <title>NFV 도커 컨테이너 초심자 가이드</title>
        <link>https://markruler.github.io/posts/nfv/beginners-guide-docker-container-nfv/</link>
        <pubDate>Mon, 16 Nov 2020 22:40:00 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/nfv/beginners-guide-docker-container-nfv/</guid>
        <description>임창수 https://markruler.github.io/posts/nfv/beginners-guide-docker-container-nfv/ -&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://telcocloudbridge.com/blog/beginners-guide-docker-container-nfv/&#34;&gt;Faisal Khan의 A Beginner&amp;rsquo;s Guide to Docker Container in NFV&lt;/a&gt;를 번역한 글입니다.&lt;/li&gt;
&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;
&lt;li&gt;2016년 3월 3일에 쓰여진 글로 현재와 다를 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;새롭게 등장한 도커(Docker) 컨테이너는 NFV를 혁신할 수 있는 잠재력을 가지고 있습니다.&lt;/p&gt;
&lt;p&gt;무엇보다 도커 컨테이너는 가상 머신에 비해 가볍고, 적은 오버헤드와 리소스만을 요구하며, 동일한 운영 체제에서 실행되는 애플리케이션을 격리시킬 수 있습니다.&lt;/p&gt;
&lt;p&gt;즉, NFV의 VNF(가상 네트워크 기능)를 완전히 격리시켜 도커 컨테이너에서 실행할 수 있다면 가상 머신이 필요 없을 지도 모릅니다.&lt;/p&gt;
&lt;p&gt;하지만 그게 쉬울까요?&lt;/p&gt;
&lt;p&gt;가상 머신의 미래는 어떨까요?&lt;/p&gt;
&lt;p&gt;실제로 도커 컨테이너가 아직은 성장하는 단계에 있기 때문에 가상 머신의 미래에 대해 뭐라고 말하기에는 너무 이릅니다(NFV도 마찬가지입니다 😊).&lt;/p&gt;
&lt;p&gt;하지만 여러분이 이 글을 끝까지 읽는다면 현재 모든 사람들이 이야기하는 도커 컨테이너를 특별하게 만드는 것이 무엇인지 알 수 있습니다.&lt;/p&gt;
&lt;p&gt;본 가이드의 주목적은 도커 컨테이너의 아키텍처를 이해하는 데 있어 단계별로 안내하는 것입니다. 이 과정에서 하이퍼바이저 및 가상 머신의 기초도 이해하게 됩니다.&lt;/p&gt;
&lt;p&gt;이러한 개념들은 가상 머신 및 하이퍼바이저에 대한 사전 지식이 전혀 없다고 가정하여 설명됩니다.&lt;/p&gt;
&lt;h1 id=&#34;컨테이너란-무엇인가요&#34;&gt;컨테이너란 무엇인가요?&lt;/h1&gt;
&lt;p&gt;과거에는 보다 유연하고 민첩한 방식의 애플리케이션 실행 방법으로 컨테이너가 등장했습니다. 리눅스 컨테이너는 리눅스 운영체제 내에서 직접 경량 애플리케이션을 실행할 수 있도록 해주었습니다. 하이퍼바이저와 가상 머신이 없어도 동일한 운영 체제에서 애플리케이션을 격리하여 실행할 수 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;도커-컨테이너란-무엇인가요&#34;&gt;도커 컨테이너란 무엇인가요?&lt;/h1&gt;
&lt;p&gt;구글(Google)은 데이터 센터에서 2006년부터 리눅스(Linux) 컨테이너를 사용하고 있습니다. 하지만 컨테이너는 2013년에 도커 컨테이너가 나오면서 더 유명해졌습니다. 이는 이전 버전의 컨테이너에 비해 컨테이너를 보다 단순하고 표준적인 방식으로 실행할 수 있는 방법입니다.&lt;/p&gt;
&lt;p&gt;도커 컨테이너는 리눅스에서도 실행됩니다. 하지만 도커만이 컨테이너를 운영하는 유일한 방법은 아닙니다. LXC는 컨테이너를 실행하는 또 다른 방법입니다. LXC와 도커는 모두 리눅스에 뿌리를 두고 있습니다.&lt;/p&gt;
&lt;p&gt;도커 컨테이너가 LXC와 같은 경쟁 컨테이너에 비해 더 인기 있는 이유 중 하나는 호스트 운영 체제에서 간단하고 빠르게 &amp;ldquo;이미지&amp;quot;로 불러올 수 있기 때문입니다. 도커는 클라우드에 이미지로 저장되며, 필요한 경우 간단한 방법으로 사용자가 실행을 요청합니다.&lt;/p&gt;
&lt;p&gt;앞으로 &amp;ldquo;컨테이너&amp;quot;와 &amp;ldquo;도커 컨테이너&amp;quot;라는 단어를 동일한 의미처럼 사용하겠습니다.&lt;/p&gt;
&lt;p&gt;NFV에서의 도커 컨테이너를 이해하기 위해 단계별로 안내합니다.&lt;/p&gt;
&lt;p&gt;가상 머신은 좋지만 다음과 같은 문제점이 있습니다.&lt;/p&gt;
&lt;p&gt;전용 운영 체제가 필요합니다. 또한 가상화를 구현하려면 가상 머신을 분리하는 하이퍼바이저가 필요합니다.&lt;/p&gt;
&lt;p&gt;애플리케이션이  많을수록 소프트웨어 오버헤드가 증가하고 비용이 많이 들며 업데이트 상태를 유지해야 합니다.&lt;/p&gt;
&lt;p&gt;하지만 NFV 아키텍처에는 가상 머신이 필요합니다. NFV 아키텍처를 살펴보겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;1단계-nfv-아키텍처의-하이퍼바이저부터-살펴보겠습니다&#34;&gt;1단계: NFV 아키텍처의 하이퍼바이저부터 살펴보겠습니다.&lt;/h2&gt;
&lt;p&gt;아래 다이어그램에 NFV 아키텍처가 있는데, 아마 여러 번 보셨을 것입니다. (모르시는 분은 &lt;a href=&#34;../cheat-sheet-understanding-nfv-architecture/&#34;&gt;여기를 확인해주세요&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/nfv/hypervisor-in-nfv.png&#34; alt=&#34;hypervisor-in-nfv&#34;&gt;&lt;/p&gt;
&lt;p&gt;이 논의를 위해 세 가지 고유한 구성 요소가 있는 NFVI(NFV Infrastructure)만 살펴보겠습니다.&lt;/p&gt;
&lt;p&gt;하이퍼바이저 도메인, 컴퓨팅 도메인 및 네트워크 인프라 도메인입니다.&lt;/p&gt;
&lt;p&gt;가상화 계층(Virtualization Layer)은 실제로 컴퓨팅 도메인(물리적 서버 및 x86 서버)의 하드웨어 리소스 분리를 담당하는 하이퍼바이저입니다. 예를 들어 단일 물리 서버(물리 메모리 및 물리 컴퓨팅)가 있을 수 있지만 하이퍼바이저는 각 엔터티가 독립하는 방식으로 이를 여러 가상 메모리 및 가상 컴퓨팅으로 파티셔닝할 수 있습니다.&lt;/p&gt;
&lt;p&gt;가상 리소스와 함께 (하이퍼바이저라고 하는) 가상화 계층을 &amp;ldquo;하이퍼바이저 도메인&amp;quot;이라고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;2단계-가상-머신을-자세히-살펴보겠습니다&#34;&gt;2단계: 가상 머신을 자세히 살펴보겠습니다.&lt;/h2&gt;
&lt;p&gt;이제 가상 머신을 이해하기 위해 하이퍼바이저 도메인을 확장하여 이 도메인 내에 무엇이 있는지 보여드리겠습니다.&lt;/p&gt;
&lt;p&gt;아래 두 번째 그림을 확인하세요.&lt;/p&gt;
&lt;p&gt;위의 첫 번째 그림과 동일한 하이퍼바이저 도메인이 왼쪽에 있습니다. 오른쪽 그림에는 하이퍼바이저 도메인을 확장하여 가상 머신이 있습니다. 즉, 하이퍼바이저 도메인의 가상 리소스가 이제 가상 머신으로 표시됩니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/nfv/hypervisor-domain-with-vm.png&#34; alt=&#34;hypervisor-domain-with-vm&#34;&gt;&lt;/p&gt;
&lt;p&gt;간단하게 설명하기 위해 왼쪽의 가상 네트워크 블록 및 네트워크 블록을 제거했습니다. 이 블록들은 여기서 중요하지 않습니다.&lt;/p&gt;
&lt;p&gt;가상화 계층이 리소스 관리자 및 네트워크 관리자가 되었습니다. 가상 컴퓨팅 및 가상 메모리가 가상 머신이 되었습니다.&lt;/p&gt;
&lt;p&gt;그렇다면 가상 머신이란 무엇일까요?&lt;/p&gt;
&lt;p&gt;가상 머신은 VNF(가상 네트워크 기능)가 실행되는 환경을 제공합니다.&lt;/p&gt;
&lt;p&gt;다이어그램을 보면 각 가상 머신이 VNF에 연결됩니다.&lt;/p&gt;
&lt;p&gt;명확하게 하기 위해 예를 들어 설명하겠습니다. Virtual CPE라는 VNF1과 Virtual Firewall이라는 VNF2가 있습니다. 위의 예에서 각각 고유한 가상 머신으로 실행됩니다. 그런 다음 하이퍼바이저 도메인을 통해 체인으로 연결하고 내부적으로 연결할 수 있습니다.&lt;/p&gt;
&lt;p&gt;또한 가상 머신은 논리적으로 서로 분리되어 있습니다. 따라서 각 가상 머신에서 독립적인 운영 체제를 실행할 수 있습니다. 예를 들어 게스트 운영 체제 OS1은 리눅스일 수 있고 게스트 OS2는 솔라리스일 수 있습니다.&lt;/p&gt;
&lt;p&gt;또한 게스트 운영 체제 외에도 하이퍼바이저가 실행되는 환경인 호스트 운영 체제가 필요합니다. 다음 단락에서 컨테이너에 대해 논의할 때 이 중요한 점을 명심하세요.&lt;/p&gt;
&lt;p&gt;이제 가상 머신을 제거해 보겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;3단계-가상-머신을-제거하고-컨테이너를-도입하세요&#34;&gt;3단계: 가상 머신을 제거하고 컨테이너를 도입하세요!&lt;/h2&gt;
&lt;p&gt;이제 가상 머신 대신 완전히 새로운 구성 요소 컨테이너를 도입합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/nfv/vm-replaced-with-container.png&#34; alt=&#34;vm-replaced-with-container&#34;&gt;&lt;/p&gt;
&lt;p&gt;이제 VNF1은 컨테이너 1에서 실행되고 VNF2는 가상 머신과 동일한 기능을 제공하는 컨테이너 2에서 실행됩니다.&lt;/p&gt;
&lt;p&gt;가상 머신과 동일한 기능을 제공하지만 동일한 OS (여기서는 리눅스) 내에서 제공합니다.&lt;/p&gt;
&lt;p&gt;이제 게스트 OS가 필요하지 않다는 것을 알아차리셨나요?&lt;/p&gt;
&lt;p&gt;단순한 아키텍처입니다. 그렇죠?&lt;/p&gt;
&lt;h2 id=&#34;컨테이너로-무엇을-달성했나요&#34;&gt;컨테이너로 무엇을 달성했나요?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;호스트 OS가 리눅스인 것을 알 수 있으므로 컨테이너 환경에 게스트 OS가 필요하지 않습니다. 따라서 가상 머신에 비해 가볍고 오버헤드가 적습니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현재 컨테이너가 동일한 호스트 OS 내의 OS 수준에서 충분히 격리 상태를 유지할 수 있으므로 하이퍼바이저를 제거하여 아키텍처를 단순화합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가상 머신(VM)은 하드웨어 레벨 가상화를 제공하므로 기존의 가상 머신이 하이퍼바이저 소프트웨어를 통해 호스트를 가져오고 파티션을 분할합니다. 이는 기본적으로 VM이 호스트 머신의 OS에서 분리됨을 의미합니다. 리눅스 운영 체제에서 윈도우즈(Windows) 호스트를 실행할 수 있습니다. 반면에 컨테이너는 OS 수준 가상화를 제공합니다. 즉, 동일한 OS에서 애플리케이션은 자체적으로 격리될 수 있습니다. 이는 전체 OS가 중복되지 않기 때문에 VM에 비해 훨씬 적은 오버헤드입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;컨테이너 얘기는 여기까지입니다.&lt;/p&gt;
&lt;h2 id=&#34;nfv용-컨테이너의-미래&#34;&gt;NFV용 컨테이너의 미래&lt;/h2&gt;
&lt;p&gt;현실을 보면 현재의 NFV 아키텍처와 표준은 가상 머신을 기반으로 합니다.&lt;/p&gt;
&lt;p&gt;컨테이너는 아직 NFV에서 새로운 개념입니다. 특히 보안 측면에서 여전히 많은 개발이 진행되고 있습니다. 보시다시피 호스트 OS가 모든 컨테이너에 노출되어 있어 멀티 테넌시 보안 문제가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;그러나 컨테이너 환경에서 VNF를 쉽고 간단하게 실행할 수 있다는 것을 고려할 때 좋은 미래가 있을 것 같습니다. 또한 가상 머신에서 전체 VNF를 실행하는 대신 마이크로 서비스를 실행할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예를 들어 가상 CPE(vCPE, Virtual Customer Premises Equipment)의 경우 많은 구성요소를 작은 컨테이너로 분해하여 체인으로 연결할 수 있습니다. 이 기능을 분해하면 소규모 소프트웨어 벤더가 적은 오버헤드로 VNF의 작은 기능을 쉽게 개발할 수 있습니다.&lt;/p&gt;
- https://markruler.github.io/posts/nfv/beginners-guide-docker-container-nfv/ - Im Changsu 2020 - 2024</description>
        </item>
    
    
    
        <item>
        <title>쿠버네티스 컴포넌트를 로컬에서 직접 빌드 및 디버깅하기</title>
        <link>https://markruler.github.io/posts/kubernetes/local-build-kube/</link>
        <pubDate>Sun, 11 Oct 2020 14:48:00 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/kubernetes/local-build-kube/</guid>
        <description>임창수 https://markruler.github.io/posts/kubernetes/local-build-kube/ -&lt;blockquote&gt;
&lt;p&gt;직접 빌드해서 사용한다면 쿠버네티스 기능을 확장해서 사용할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.19/build/README.md&#34;&gt;kubernetes/build/README.md&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;사용할-명령어&#34;&gt;사용할 명령어&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# master 브랜치&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone --depth &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt; https://github.com/kubernetes/kubernetes.git
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# 특정 브랜치&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone --depth &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt; --single-branch --branch release-1.19 https://github.com/kubernetes/kubernetes.git
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# cmd 디렉터리에 있는 다른 컴포넌트도 같은 방식으로 빌드할 수 있다.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# cmd/kubeadm, kubectl, kubelet, kube-apiserver, kube-proxy, kube-controller-manager, kube-scheduler, ...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make all &lt;span style=&#34;color:#eedd82&#34;&gt;WHAT&lt;/span&gt;=cmd/kubectl &lt;span style=&#34;color:#eedd82&#34;&gt;GOFLAGS&lt;/span&gt;=-v
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# 그냥 간단히 go build 명령도 가능하다.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;go build -o k cmd/kubectl
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;빌드-실행-따라가기&#34;&gt;빌드 실행 따라가기&lt;/h2&gt;
&lt;h3 id=&#34;makefile&#34;&gt;Makefile&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;make 명령을 내릴 루트 디렉터리 Makefile을 보면 아래와 같이 다른 Makefile을 가리킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;build/root/Makefile
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;실제로-빌드되는-makefile&#34;&gt;실제로 빌드되는 Makefile&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.19/build/root/Makefile&#34;&gt;build/root/Makefile&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;all 타겟은 WHAT 전달인자와 함께 build.sh 쉘 스크립트 파일을 실행시킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# Build code.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# Args:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   WHAT: Directory names to build.  If any of these directories has a &amp;#39;main&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#     package, the build will produce executable files under $(OUT_DIR)/bin.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#     If not specified, &amp;#34;everything&amp;#34; will be built.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   GOFLAGS: Extra flags to pass to &amp;#39;go&amp;#39; when building.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   GOLDFLAGS: Extra linking flags passed to &amp;#39;go&amp;#39; when building.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   GOGCFLAGS: Additional go compile flags passed to &amp;#39;go&amp;#39; when building.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# Example:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   make
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   make all
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   make all WHAT=cmd/kubelet GOFLAGS=-v
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   make all GOLDFLAGS=&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#     Note: Specify GOLDFLAGS as an empty string for building unstripped binaries, which allows
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#           you to use code debugging tools like delve. When GOLDFLAGS is unspecified, it defaults
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#           to &amp;#34;-s -w&amp;#34; which strips debug information. Other flags that can be used for GOLDFLAGS 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#           are documented at https://golang.org/cmd/link/
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;endef
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff0&#34;&gt;.PHONY&lt;/span&gt;: all
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ifeq (&lt;span style=&#34;color:#f00&#34;&gt;$(&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;PRINT_HELP&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;)&lt;/span&gt;,y)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff0&#34;&gt;all&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	@echo &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;$$&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;ALL_HELP_INFO&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;else
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff0&#34;&gt;all&lt;/span&gt;: generated_files
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	hack/make-rules/build.sh &lt;span style=&#34;color:#f00&#34;&gt;$(&lt;/span&gt;WHAT&lt;span style=&#34;color:#f00&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;endif
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;all-generated_files&#34;&gt;all: generated_files&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.19/hack/make-rules/build.sh&#34;&gt;hack/make-rules/build.sh&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e5e5e5&#34;&gt;#!/usr/bin/env bash
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e5e5e5&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# This script sets up a go workspace locally and builds all go components.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set -o errexit
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set -o nounset
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set -o pipefail
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;KUBE_ROOT&lt;/span&gt;=&lt;span style=&#34;color:#f00&#34;&gt;$(&lt;/span&gt;dirname &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;BASH_SOURCE&lt;/span&gt;[0]&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;)&lt;/span&gt;/../..
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;KUBE_VERBOSE&lt;/span&gt;=&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;KUBE_VERBOSE&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:-&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;source &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;KUBE_ROOT&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;/hack/lib/init.sh&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# 👉 hack/lib/golang.sh&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kube::golang::build_binaries &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;$@&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kube::golang::place_bins
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;kubegolang&#34;&gt;kube::golang::&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.19/hack/lib/golang.sh&#34;&gt;hack/lib/golang.sh&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;참고로 쉘 스크립트의 function 키워드는 생략할 수 있으며, double colon(::)은 쿠버네티스의 Naming Convection으로 보인다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# Build binaries targets specified&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# Input:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   $@ - targets and go flags.  If no targets are set then all binaries targets&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#     are built.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#   KUBE_BUILD_PLATFORMS - Incoming variable of targets to build for.  If unset&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#     then just the host architecture is built.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kube::golang::build_binaries() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# This will take binaries from $GOPATH/bin and copy them to the appropriate&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# place in ${KUBE_OUTPUT_BINDIR}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;#&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# Ideally this wouldn&amp;#39;t be necessary and we could just set GOBIN to&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# KUBE_OUTPUT_BINDIR but that won&amp;#39;t work in the face of cross compilation.  &amp;#39;go&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# install&amp;#39; will place binaries that match the host platform directly in $GOBIN&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# while placing cross compiled binaries into `platform_arch` subdirs.  This&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# complicates pretty much everything else we do around packaging and such.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kube::golang::place_bins() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0f0&#34;&gt;# V=2 kube::log::status ${KUBE_OUTPUT_BINPATH}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0f0&#34;&gt;# 위 로그 함수를 추가해서 빌드하면 어디에 빌드되었는지 확인할 수 있다.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0f0&#34;&gt;# &amp;gt; [%m%d %H:%M:%S] /home/kubernetes/kubernetes/_output/local/bin&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;로그-레벨&#34;&gt;로그 레벨&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/hack/lib/logging.sh&#34;&gt;hack/lib/logging.sh&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# This controls the verbosity of the build. Higher numbers mean more output.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;KUBE_VERBOSE&lt;/span&gt; ?= &lt;span style=&#34;color:#f60&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# 찾아보면 V=4까지 있는 것 같아서 4로 지정했다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;# 👉 hack/lib/logging.sh
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ff0&#34;&gt;kube&lt;/span&gt;::log::status() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  local &lt;span style=&#34;color:#eedd82&#34;&gt;V&lt;/span&gt;=&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;V&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;:-&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; [[ &lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;KUBE_VERBOSE&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;V&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt; ]]; &lt;span style=&#34;color:#f00&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;fi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eedd82&#34;&gt;timestamp&lt;/span&gt;=&lt;span style=&#34;color:#f00&#34;&gt;$(&lt;/span&gt;date +&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;[%m%d %H:%M:%S]&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f00&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  echo &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;+++ &lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;timestamp&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  shift
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;for&lt;/span&gt; message; &lt;span style=&#34;color:#f00&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    echo &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;    &lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#eedd82&#34;&gt;message&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;cmdkubectl&#34;&gt;cmd/kubectl&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.19/cmd/kubectl/kubectl.go&#34;&gt;kubectl.go&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;package&lt;/span&gt; main
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	goflag &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;flag&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;math/rand&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;os&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;time&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;github.com/spf13/pflag&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	cliflag &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;k8s.io/component-base/cli/flag&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;k8s.io/kubectl/pkg/util/logs&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;k8s.io/kubernetes/pkg/kubectl/cmd&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0f0&#34;&gt;// Import to initialize client auth plugins.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;	_ &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;k8s.io/client-go/plugin/pkg/client/auth&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#ff0&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	rand.&lt;span style=&#34;color:#ff0&#34;&gt;Seed&lt;/span&gt;(time.&lt;span style=&#34;color:#ff0&#34;&gt;Now&lt;/span&gt;().&lt;span style=&#34;color:#ff0&#34;&gt;UnixNano&lt;/span&gt;())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	command := cmd.&lt;span style=&#34;color:#ff0&#34;&gt;NewDefaultKubectlCommand&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0f0&#34;&gt;// TODO: once we switch everything over to Cobra commands, we can go back to calling
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#0f0&#34;&gt;// cliflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#0f0&#34;&gt;// normalize func and add the go flag set by hand.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;	pflag.CommandLine.&lt;span style=&#34;color:#ff0&#34;&gt;SetNormalizeFunc&lt;/span&gt;(cliflag.WordSepNormalizeFunc)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	pflag.CommandLine.&lt;span style=&#34;color:#ff0&#34;&gt;AddGoFlagSet&lt;/span&gt;(goflag.CommandLine)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0f0&#34;&gt;// cliflag.InitFlags()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;	logs.&lt;span style=&#34;color:#ff0&#34;&gt;InitLogs&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f00&#34;&gt;defer&lt;/span&gt; logs.&lt;span style=&#34;color:#ff0&#34;&gt;FlushLogs&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; err := command.&lt;span style=&#34;color:#ff0&#34;&gt;Execute&lt;/span&gt;(); err != &lt;span style=&#34;color:#f00&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		os.&lt;span style=&#34;color:#ff0&#34;&gt;Exit&lt;/span&gt;(&lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;pkgkubectlcmdhttpsgithubcomkuberneteskubernetesblobrelease-119pkgkubectlcmdcmdgo&#34;&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.19/pkg/kubectl/cmd/cmd.go&#34;&gt;pkg/kubectl/cmd&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&#34;디버깅&#34;&gt;디버깅&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;환경은 VS Code에 github.com/go-delve/delve/cmd/dlv 를 설치한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://code.visualstudio.com/docs/editor/debugging&#34;&gt;launch.json&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;#34;version&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;0.2.0&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;#34;configurations&amp;#34;: [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;type&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;go&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;request&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;launch&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;name&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;kubectl&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;program&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;${workspaceFolder}/cmd/kubectl/kubectl.go&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;args&amp;#34;: [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;config&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;view&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/kubernetes/vscode-debugging-golang.png&#34; alt=&#34;vscode-debugging-golang&#34;&gt;&lt;/p&gt;
- https://markruler.github.io/posts/kubernetes/local-build-kube/ - Im Changsu 2020 - 2024</description>
        </item>
    
    
    
        <item>
        <title>Observability 용어 정리</title>
        <link>https://markruler.github.io/posts/cloud/monitor-trace-log-metric/</link>
        <pubDate>Fri, 02 Oct 2020 16:24:00 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/cloud/monitor-trace-log-metric/</guid>
        <description>임창수 https://markruler.github.io/posts/cloud/monitor-trace-log-metric/ -&lt;h1 id=&#34;observability&#34;&gt;Observability&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;관측성&lt;/li&gt;
&lt;li&gt;관찰성&lt;/li&gt;
&lt;li&gt;관측 가능성&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;제어 이론에서 &amp;lsquo;observability&amp;rsquo;라는 용어는
시스템의 내부 상태 변수와 그에 따른 행동을
시스템에 대한 입력과 출력만 보고 결정할 수 있다면
그 시스템이 관측 가능하다는 것을 나타낸다.&lt;/p&gt;
&lt;h1 id=&#34;event-logging&#34;&gt;Event Logging&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/cloud/kibana5-fluentd.png&#34; alt=&#34;kibana5-fluentd&#34;&gt;
&lt;em&gt;Fluentd-Kibana&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;로그는 시스템 프로세스의 개별 이벤트를 기록하는 것이다.
하지만 각 로그 스트림은 단일 인스턴스에 대해서만 알려주기 때문에
마이크로서비스에서 전체적인 모니터링을 하기에는 어려움이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.fluentd.org/&#34;&gt;Fluentd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.elastic.co/&#34;&gt;Elastic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.datadoghq.com/logs/&#34;&gt;Datadog Log Management&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;software-tracing&#34;&gt;Software Tracing&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/cloud/jaeger-embed-trace-view.png&#34; alt=&#34;jaeger-embed-trace-view&#34;&gt;
&lt;em&gt;Jaeger&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;사용자의 트래픽이 지나가는 애플리케이션의 전체 스택을 추적한다.
주로 서비스를 최적화하는 데 사용된다.
예를 들어, 특정 서비스에 병목이 예상되는 경우
트레이싱해서 어떤 부분인지 확인하고 최적화를 시도해볼 수 있다.
결국 트레이싱은 구조화된 형태의 로그 이벤트일 뿐이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jaegertracing.io/&#34;&gt;Jaeger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://opentracing.io/&#34;&gt;OpenTracing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linux.die.net/man/1/strace&#34;&gt;strace&lt;/a&gt; - Linux man page&lt;/li&gt;
&lt;li&gt;구글 크롬의 &lt;a href=&#34;https://developers.google.com/web/tools/chrome-devtools/network/&#34;&gt;Network log&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;logging--tracing&#34;&gt;Logging : Tracing&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;Event logging&lt;/th&gt;
          &lt;th&gt;Software tracing&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Consumed primarily by system administrators&lt;/td&gt;
          &lt;td&gt;Consumed primarily by developers&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Logs &amp;ldquo;high level&amp;rdquo; information (e.g. failed installation of a program)&lt;/td&gt;
          &lt;td&gt;Logs &amp;ldquo;low level&amp;rdquo; information (e.g. a thrown exception)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Must not be too &amp;ldquo;noisy&amp;rdquo; (containing many duplicate events or information that is not helpful for its intended audience)&lt;/td&gt;
          &lt;td&gt;Can be noisy&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;A standards-based output format is often desirable, sometimes even required&lt;/td&gt;
          &lt;td&gt;Few limitations on output format&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Event log messages are often localized&lt;/td&gt;
          &lt;td&gt;Localization is rarely a concern&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Addition of new types of events, as well as new event messages, need not be agile&lt;/td&gt;
          &lt;td&gt;Addition of new tracing messages must be agile&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;trace--track&#34;&gt;Trace : Track&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;track은 시작 지점에서 시작해서 현재 지점으로 새로운 경로를 계속 따라가는 것이다.
&lt;ul&gt;
&lt;li&gt;To track: follow the emerging path forwards from your starting point to wherever the thing currently is.&lt;/li&gt;
&lt;li&gt;When you &amp;ldquo;track&amp;rdquo; a cellphone, you monitor its current location,
right now, and follow it wherever it goes in the future.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;trace는 현재 지점에서 시작된 지점까지 이미 완료된 경로를 따라가는 것이다.
&lt;ul&gt;
&lt;li&gt;To trace: follow the completed path backwards from its current point to where it began.&lt;/li&gt;
&lt;li&gt;When you &amp;ldquo;trace&amp;rdquo; a cellphone call, you try to determine its origin.
This is the same whether done right now, or for a call made a month ago.
You go backward to the starting point.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;distributed-tracing&#34;&gt;Distributed tracing&lt;/h2&gt;
&lt;p&gt;분산 추적은 종단 간 또는 워크플로 중심 추적이라고도 하며,
분산 시스템의 구성 요소에 의해 수행되는 인과관계가 있는 활동의 상세한 실행 정보를 수집하는 것을 목적으로 하는 일련의 기법이다.
기존의 코드 프로파일러나 dtrace 같은 호스트 레벨 추적 도구와는 달리
종단 간 추적은 주로 여러 다른 프로세스에 의해 협력적으로 수행되는 개별 실행 정보를 프로파일링하는 데 초점을 맞추고 있으며,
이와 같은 환경은 현대적이고 클라우드 네이티브한 마이크로서비스 기반 애플리케이션이 대표적이다.&lt;/p&gt;
&lt;h1 id=&#34;monitoring&#34;&gt;Monitoring&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/cloud/grafana-visualize.jpg&#34; alt=&#34;grafana-visualize&#34;&gt;
&lt;em&gt;Grafana&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;애플리케이션 계측(measure), 메트릭 수집(collect), 집계(aggregate), 분석(analyze) 등을 포함하는 시스템이다.
진단 목적으로 가장 많이 사용되고, 문제가 발생했을 경우 관리자에게 알람을 보낸다.
예를 들어 설정한 임계점(threshold)을 넘을 경우 이메일을 보내거나 슬랙 채널에 메시지를 보낼 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://prometheus.io/&#34;&gt;Prometheus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://grafana.com/&#34;&gt;Grafana&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://thanos.io/&#34;&gt;Thanos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.datadoghq.com/getting_started/&#34;&gt;Datadog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;profiling&#34;&gt;Profiling&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/cloud/android-profiler-callouts.png&#34; alt=&#34;android-profiler-callouts&#34;&gt;&lt;/p&gt;
&lt;p&gt;프로그램의 공간(메모리) 또는 시간 복잡성, 특정 명령의 사용 또는 빈도를 측정하는
&lt;a href=&#34;https://en.wikipedia.org/wiki/Dynamic_program_analysis&#34;&gt;동적 프로그램 분석(Dynamic program analysis)&lt;/a&gt;의 한 형태다.
모니터링과 달리 벤치마킹에 주 목적이 있다.
분산 환경보다 단일 애플리케이션을 배포하기 전 성능 테스트 및 통계에 쓰인다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/java-profilers&#34;&gt;A Guide to Java Profilers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.datadoghq.com/tracing/profiler/&#34;&gt;Datadog Continuous Profiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.android.com/studio/profile&#34;&gt;Android Profiler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;참조&#34;&gt;참조&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Observability
&lt;ul&gt;
&lt;li&gt;유리 슈쿠로 &amp;lt;마스터링 분산 추적&amp;gt; 6쪽&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Observability&#34;&gt;Observability&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://landscape.cncf.io/&#34;&gt;CNCF Landscape&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Logging
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Logging_(software)&#34;&gt;Logging&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Log_management&#34;&gt;Log management&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Log_analysis&#34;&gt;Log analysis&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Tracing
&lt;ul&gt;
&lt;li&gt;유리 슈쿠로 &amp;lt;마스터링 분산 추적&amp;gt; 58쪽&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Tracing_(software)&#34;&gt;Tracing&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Audit_trail&#34;&gt;Audit trail&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ell.stackexchange.com/questions/34391/difference-between-track-and-trace&#34;&gt;Difference between Tracking and Tracing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://opentracing.io/docs/overview/what-is-tracing/&#34;&gt;What is Distributed Tracing? - OpenTracing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bmc.com/blogs/monitoring-logging-tracing&#34;&gt;Tracing vs Logging vs Monitoring: What’s the Difference?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://winderresearch.com/logging-vs-tracing-vs-monitoring/&#34;&gt;Logging vs Tracing vs Monitoring&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Monitoring
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Application_performance_management&#34;&gt;Application performance management&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Event_monitoring&#34;&gt;Event monitoring&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Log_monitor&#34;&gt;Log monitor&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://techbeacon.com/enterprise-it/monitoring-demystified-guide-logging-tracing-metrics&#34;&gt;Monitoring demystified: A guide for logging, tracing, metrics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Profiling
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Profiling_(computer_programming)&#34;&gt;Profiling&lt;/a&gt; - Wikipedia&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://markruler.github.io/posts/cloud/monitor-trace-log-metric/ - Im Changsu 2020 - 2024</description>
        </item>
    
    
    
        <item>
        <title>NFV의 컴퓨팅 도메인에 대한 오해!</title>
        <link>https://markruler.github.io/posts/nfv/the-misunderstood-facts-about-compute-domain-in-nfv/</link>
        <pubDate>Thu, 01 Oct 2020 22:23:00 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/nfv/the-misunderstood-facts-about-compute-domain-in-nfv/</guid>
        <description>임창수 https://markruler.github.io/posts/nfv/the-misunderstood-facts-about-compute-domain-in-nfv/ -&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://telcocloudbridge.com/blog/the-misunderstood-facts-about-compute-domain-in-nfv/&#34;&gt;Faisal Khan의 The Misunderstood Facts about Compute Domain in NFV!&lt;/a&gt;를 번역한 글입니다.&lt;/li&gt;
&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;NFV에 대해 생각해 보세요! 그리고 x86 프로세서를 생각해 보세요&amp;hellip; 둘은 뗄 수 없는 사이입니다. 그렇죠?&lt;/p&gt;
&lt;p&gt;프로세서(컴퓨팅 파트)가 아무리 단순하게 들리더라도 NFV의 컴퓨팅 도메인(compute domain)이 노드의 컴퓨팅 프로세서(compute processor)가 같지 않다는 사실을 모르는 사람이 많을 것입니다. 사실&amp;hellip; 훨씬 더 많습니다.&lt;/p&gt;
&lt;p&gt;NFV의 &amp;ldquo;Compute Domain&amp;quot;과 &amp;ldquo;Compute Node&amp;quot;는 ETSI 정의에 따르면 동일한 것을 의미하지 않습니다. 이를 잘 알고 있으면 NFV 기본 아키텍처를 이해하는 데 많은 혼란을 피할 수 있으며, 벤더 및 고객과 이 주제에 대해 소통하는 과정에서 오해를 피할 수 있습니다.&lt;/p&gt;
&lt;p&gt;물론 NFV의 뼈대를 제대로 세우고 싶을 겁니다. 그렇죠?&lt;/p&gt;
&lt;p&gt;뿐만 아니라 끝까지 읽으신다면 COTs, NIC, 하드웨어 가속기와 같이 매일 듣는 서버의 필수 용어가 명확해질 것입니다.&lt;/p&gt;
&lt;h1 id=&#34;우선-etsi의-용어로-compute-domain과-compute-node는-무엇일까요&#34;&gt;우선 ETSI의 용어로 &amp;ldquo;Compute Domain&amp;quot;과 &amp;ldquo;Compute Node&amp;quot;는 무엇일까요?&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/nfv/computer-domain-in-nfv.png&#34; alt=&#34;computer-domain-in-nfv&#34;&gt;&lt;/p&gt;
&lt;p&gt;(NFV 아키텍처에 대한 자세한 내용을 보려면 &lt;a href=&#34;../beginners-guide-to-nfv-mano/&#34;&gt;NFV 아키텍처&lt;/a&gt; 또는 &lt;a href=&#34;../cheat-sheet-understanding-nfv-architecture&#34;&gt;NFV MANO 치트 시트&lt;/a&gt;에 대한 글을 읽는 것이 좋습니다.)&lt;/p&gt;
&lt;p&gt;위의 NFV Infrastructure (NFVI) 블록에 명확히 나와 있듯이 컴퓨팅 도메인에는 컴퓨팅 하드웨어와 스토리지 하드웨어가 포함됩니다. 컴퓨팅 도메인은 상위 집합이며, 그 중 컴퓨팅 하드에어와 노드는 한 부분에 불과합니다.&lt;/p&gt;
&lt;p&gt;놀랍죠? 스토리지를 컴퓨팅 도메인의 일부로 생각하는 사람이 얼마나 되겠습니까?&lt;/p&gt;
&lt;p&gt;이제 컴퓨팅 도메인에 무엇이 포함되는지 자세히 살펴보겠습니다.&lt;/p&gt;
&lt;h1 id=&#34;컴퓨팅-도메인의-세-가지-부분&#34;&gt;컴퓨팅 도메인의 세 가지 부분&lt;/h1&gt;
&lt;h2 id=&#34;1-컴퓨팅-노드-compute-node&#34;&gt;1. 컴퓨팅 노드 (Compute Node)&lt;/h2&gt;
&lt;p&gt;상용 제품(COTS, Commercial Off-the-Shelf) 아키텍처에서 컴퓨팅 노드에는 멀티 코어 프로세서와 칩셋이 포함되어 있으며, 여기에는 다음과 같은 물리적 리소스가 포함될 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 및 칩셋 (예: x86, ARM etc.)&lt;/li&gt;
&lt;li&gt;메모리 하위 집합.&lt;/li&gt;
&lt;li&gt;임의의 하드웨어 가속기 (예: co-processor)&lt;/li&gt;
&lt;li&gt;NICs (임의의 가속기를 포함한 네트워크 인터페이스 카드)&lt;/li&gt;
&lt;li&gt;블레이드 내부 스토리지 (비휘발성 메모리, 로컬 디스크 스토리지)&lt;/li&gt;
&lt;li&gt;BIOS/부트 로더 (실행 환경의 일부)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;COTS 서버 블레이드는 컴퓨팅 노드의 한 가지 예입니다.&lt;/p&gt;
&lt;h2 id=&#34;2-네트워크-인터페이스-카드-nic-및-io-가속기&#34;&gt;2. 네트워크 인터페이스 카드 (NIC) 및 I/O 가속기&lt;/h2&gt;
&lt;p&gt;이전 섹션에서 컴퓨팅 노드의 일부로 NIC를 언급했습니다. 이건 사실입니다.
위의 경우 NIC 기능이 서버에 있기 때문입니다.
그러나 최근 세분화된 모델(예: &lt;a href=&#34;http://www.opencompute.org/about/&#34;&gt;Open Compute Project, OCP&lt;/a&gt;) 트렌드가 있습니다.
이 폼-팩터(form-factor)에서 CPU 블레이드/섀시는 NIC/가속기 섀시 및 스토리지 섀시와 분리됩니다.
이 블레이드/섀시들 간의 상호 연결은 광섬유를 통해 이루어질 수 있습니다.
이러한 이유로 NIC가 중요하기 때문에 별도로 설명합니다.&lt;/p&gt;
&lt;p&gt;NIC의 주요 기능은 CPU에 네트워크 I/O 기능을 제공하는 것입니다.&lt;/p&gt;
&lt;p&gt;NFV의 비전은 standard generic x86 서버에서 네트워크 기능을 실행하는 것입니다. 그러나 실제로 머신의 I/O 처리량을 향상시키기 위해 가속 기술을 요구하는 많은 I/O 집약적 애플리케이션(예: 가상 라우터)이 있습니다.&lt;/p&gt;
&lt;p&gt;일부 하드웨어 가속 기술에는 다음이 포함됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;디지털 신호 처리(DSP, Digital Signal Processing), 패킷 헤더 처리, 패킷 버퍼링 및 스케줄링과 같은 하드웨어 가속.&lt;/li&gt;
&lt;li&gt;캐시 관리 기능.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이외에 새로운 소프트웨어 가속 기능을 구현하는 명령어 집합 아키텍처(ISA, Instruction Set Architecture)(예: x86, ARMv8 등)가 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;3-스토리지-빌딩-블록&#34;&gt;3. 스토리지 빌딩 블록&lt;/h2&gt;
&lt;p&gt;스토리지 인프라는 주요 드라이브 유형들을 포함합니다. 반드시 이해하고 넘어가야 하는 하드 디스크 드라이브(HDD), 솔리드 스테이트 디스크(SDD), 캐시 스토리지 등이 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;31-hard-disk-drives-hdd&#34;&gt;3.1 Hard Disk Drives (HDD)&lt;/h3&gt;
&lt;p&gt;하드 디스크는 마그네틱 스토리지를 사용하여 마그네틱 재질로 코팅된 하나 이상의
견고한 고속 회전 디스크(플래터)를 사용하여 디지털 정보를 저장하고 검색하는 데이터 저장 장치입니다.
플래터는 표면에 데이터를 읽고 쓰는 자기 헤드(magnetic heads)와 쌍을 이룹니다.
데이터는 랜덤 액세스 방식으로 접근하므로 어느 순서로도 데이터를 검색할 수 있다는 장점이 있습니다.
HDD는 비휘발성 스토리지입니다. 즉, 전원이 꺼진 상태에서도 저장된 데이터를 유지할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;32-solid-state-disks-ssd&#34;&gt;3.2 Solid State Disks (SSD)&lt;/h3&gt;
&lt;p&gt;SSD는 HDD와 달리 움직이는 부품이 없습니다.
따라서 HDD에 비해 SSD는 일반적으로 물리적 충격에 더 강하고,
조용히 실행되며, 액세스 시간과 대기 시간이 짧습니다.
따라서 SSD는 상당한 랜덤 액세스가 필요한 애플리케이션에서 사용하기 적합한 기술입니다.
하지만 HDD에 비해 상대적으로 비쌉니다.&lt;/p&gt;
&lt;h3 id=&#34;33-hybrid-disk-drive&#34;&gt;3.3 Hybrid Disk Drive&lt;/h3&gt;
&lt;p&gt;점점 인기를 얻고 있는 하이브리드 하드 드라이브는 기존의 회전 플래터와
소량의 고속 플래시 메모리를 단일 드라이브에 배치하여 SSD 속도의 HDD 기능을 제공합니다.
그래서 SSD를 고속 캐시(또는 tier로 사용 가능)로 사용하고
HDD를 영구 스토리지에 사용한다는 것이 장점입니다.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Compute Node&amp;rdquo;, &amp;ldquo;NIC&amp;rdquo; 및 &amp;ldquo;Storage&amp;rdquo; 세 부분을 이해하면 컴퓨팅 도메인의 그림이 완성되고
완전한 NFV 아키텍처 서버를 만들기 때문에 정말 중요합니다.&lt;/p&gt;
- https://markruler.github.io/posts/nfv/the-misunderstood-facts-about-compute-domain-in-nfv/ - Im Changsu 2020 - 2024</description>
        </item>
    
    
    
        <item>
        <title>NFV MANO 초심자 가이드</title>
        <link>https://markruler.github.io/posts/nfv/beginners-guide-to-nfv-mano/</link>
        <pubDate>Wed, 23 Sep 2020 00:58:08 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/nfv/beginners-guide-to-nfv-mano/</guid>
        <description>임창수 https://markruler.github.io/posts/nfv/beginners-guide-to-nfv-mano/ -&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.telcocloudbridge.com/blog/a-beginners-guide-to-nfv-management-orchestration-mano/&#34;&gt;Faisal Khan의 A Beginner&amp;rsquo;s Guide to NFV Management &amp;amp; Orchestration (MANO)&lt;/a&gt;을 번역한 글입니다.&lt;/li&gt;
&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#nfv%EC%97%90%EC%84%9C-mano%EB%9E%80&#34;&gt;NFV에서 MANO란?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1-virtualized-infrastructure-manager-vim&#34;&gt;1. Virtualized Infrastructure Manager (VIM)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-virtual-network-function-manager-vnfm&#34;&gt;2. Virtual Network Function Manager (VNFM)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-nfv-orchestrator-nfvo&#34;&gt;3. NFV Orchestrator (NFVO)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#resource-orchestration&#34;&gt;Resource Orchestration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#service-orchestration&#34;&gt;Service Orchestration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-repositories&#34;&gt;4. Repositories&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#vnf-catalog&#34;&gt;VNF Catalog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#network-services-ns-catalog&#34;&gt;Network Services (NS) Catalog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nfv-instances&#34;&gt;NFV Instances&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nfvi-resources&#34;&gt;NFVI Resources&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-element-management-em&#34;&gt;5. Element Management (EM)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-ossbss&#34;&gt;6. OSS/BSS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-reference-points&#34;&gt;7. Reference Points&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NFV가 처음이라면 NFV Management &amp;amp; Orchestration (NFV MANO)를 이해하려고 할 때 두 가지 어려운 점이 있습니다.&lt;/p&gt;
&lt;p&gt;첫번째로 기존의 네트워크는 EMS, NMS 또는 OSS가 지원하는 것처럼 하나의 관리 시스템만 필요하지만
NFV 네트워크는 VIM 관리자, VNF 관리자, 오케스트레이터와 같이 여러 관리자가 필요합니다.
이것도 괜찮다면 기존 EMS와 OSS/BSS가 있습니다.
즉, 5개의 다른 관리 시스템이 필요합니다.
이 정도만 해도 NFV 초심자에게는 충분히 어렵습니다.&lt;/p&gt;
&lt;p&gt;두번째로 NFV MANO 모델을 단순하게 설명하는 정보가 부족합니다.
예를 들어 Google의 많은 기술들은 주로 벤더의 MANO 구현 방식을 설명합니다.&lt;/p&gt;
&lt;p&gt;ETSI 표준과 같이 MANO 아키텍처를 정의하는 표준 레퍼런스 문서가 있다고 해도
초심자가 그 문서들을 따라가기는 쉽지 않습니다.&lt;/p&gt;
&lt;p&gt;하지만 ETSI의 MANO 모델을 이해하는 것은 굉장히 중요합니다.
우선 ETSI는 NFV 아키텍처와 프레임워크 정의에 상당한 작업을 한 최초이자 유일한 표준 기관입니다.
따라서 ETSI 모델을 이해하여 MANO를 이해할 만한 가치가 있습니다.&lt;/p&gt;
&lt;p&gt;이 글은 가능한 한 간단하게 ETSI MANO 모델을 보여주려는 조그만 시도입니다.&lt;/p&gt;
&lt;p&gt;그 전에 하나만 묻겠습니다!&lt;/p&gt;
&lt;p&gt;먼저 NFV MANO에 대해 아는 것이 왜 중요할까요?&lt;/p&gt;
&lt;p&gt;그 이유는 MANO가 NFV 아키텍처의 심장과 두뇌 역할을 하며
MANO를 이해하는 것은 전체 NFV 아키텍처를 명확하게 해줄 것이기 때문입니다.&lt;/p&gt;
&lt;p&gt;두번째로 ETSI 모델을 참조하여 모든 벤더의 NFV 솔루션을 이해하고 벤치마킹하는 데 도움이 될 것입니다.&lt;/p&gt;
&lt;p&gt;아니면 당신은 곧 RFP 작성을 끝내야하며 MANO 부분에 무엇을 포함해야 하는지 알고 싶을 수도 있습니다.&lt;/p&gt;
&lt;p&gt;목표가 무엇이든 이 가이드로부터 무언가 얻고 가시기를 바랍니다.&lt;/p&gt;
&lt;p&gt;(NFV 용어를 다시 상기해야 할 경우 &lt;a href=&#34;../cheat-sheet-understanding-nfv-architecture/&#34;&gt;NFV 아키텍처의 치트 시트&lt;/a&gt;를 참조하세요)&lt;/p&gt;
&lt;h1 id=&#34;nfv에서-mano란&#34;&gt;NFV에서 MANO란?&lt;/h1&gt;
&lt;p&gt;MANO는 관리 및 오케스트레이션(Management and Orchestration)을 의미합니다.&lt;/p&gt;
&lt;p&gt;MANO는 아래 다이어그램에서 세 가지 관리자를 포함하는 회색 블록입니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Virtualized Infrastructure Manager (VIM).&lt;/li&gt;
&lt;li&gt;VNF Manager (VNFM).&lt;/li&gt;
&lt;li&gt;NFV Orchestrator (VNFO).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그리고 리포지토리 그룹까지(블록 4, 그 밑에 더 있음)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/nfv/mano-in-nfv.png&#34; alt=&#34;mano-in-nfv&#34;&gt;&lt;/p&gt;
&lt;p&gt;MANO 내부에 있는 4개의 블록 외에도, 외부에 기존의 요소 관리(EM)와 OSS/BSS라는 두 개의 블록이 있습니다.
두 블록은 MANO에 직접 속하지 않지만 MANO와 정보를 교환하기 때문에, 초심자는 MANO 블록과 적절한 위치에 두어야 합니다.&lt;/p&gt;
&lt;p&gt;가상화 인프라 매니저(VIM)부터 6개 블록에 대해 설명드리겠습니다.&lt;/p&gt;
&lt;h1 id=&#34;1-virtualized-infrastructure-manager-vim&#34;&gt;1. Virtualized Infrastructure Manager (VIM)&lt;/h1&gt;
&lt;p&gt;VIM은 &lt;code&gt;하나의 도메인&lt;/code&gt;에서 NFVI 리소스를 관리합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NFVI는 NFV 환경의 물리 자원(서버, 스토리지 등), 가상 자원(가상 머신), 소프트웨어 자원(하이퍼바이저)을 포함하는 NFV 인프라(Network Functions Virtualization Infrastructure)입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여기에서 &lt;code&gt;하나의 도메인&lt;/code&gt;이라는 단어를 기억하세요.
NFV 아키텍처에는 각각의 NFVI 도메인을 관리하는 &lt;code&gt;multiple VIM&lt;/code&gt;이 있을 수 있습니다.
오케스트레이터 섹션에서 다시 볼 것이므로 &lt;code&gt;multiple VIM&lt;/code&gt;이라는 개념을 염두에 두세요.&lt;/p&gt;
&lt;p&gt;그렇다면 VIM이 일반적으로 처리하는 작업은 무엇일까요?&lt;/p&gt;
&lt;p&gt;다음과 같은 작업을 처리합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NFVI 도메인에 있는 가상 자원의 라이프사이클 관리. 즉, NFVI 도메인의 물리 자원으로부터 VM(가상 머신)을 생성, 유지, 해제하는 것&lt;/li&gt;
&lt;li&gt;물리 자원과 연결된 가상 머신(VM) 목록 유지&lt;/li&gt;
&lt;li&gt;하드웨어, 소프트웨어, 가상 자원의 성능 및 장애 관리&lt;/li&gt;
&lt;li&gt;Northbound API를 유지하여 물리/가상 자원을 다른 관리 시스템에 노출&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-virtual-network-function-manager-vnfm&#34;&gt;2. Virtual Network Function Manager (VNFM)&lt;/h1&gt;
&lt;p&gt;VIM이 NFVI을 위한 것이라면 VNFM은 VNF을 위한 것입니다.&lt;/p&gt;
&lt;p&gt;즉, VNFM은 VNF를 관리합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;VNF는 라우터 VNF, 스위치 VNF 등과 같은 가상화된 네트워크 요소입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;구체적으로 VNFM은 다음을 수행합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VNFM은 VNF의 라이프사이클을 관리. 즉, VNF 인스턴스를 생성, 유지, 종료(VIM이 생성하고 관리하는 VM에 설치됨)&lt;/li&gt;
&lt;li&gt;VNF의 FCAPS(즉, VNF의 장애, 구성, 계정, 성능, 보안) 관리&lt;/li&gt;
&lt;li&gt;VNF를 스케일 업/다운하여 CPU 사용량을 스케일 업/다운&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;별도의 VNF를 관리하는 VNFM이 여러 개 있을 수도 있고,
여러 VNF를 관리하는 하나의 VNFM이 있을 수도 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;3-nfv-orchestrator-nfvo&#34;&gt;3. NFV Orchestrator (NFVO)&lt;/h1&gt;
&lt;p&gt;위의 섹션 1과 2를 살펴보셨다면 NFVO가 왜 필요한지 알 수 있을 것입니다.&lt;/p&gt;
&lt;p&gt;위의 섹션 1에서 보았듯이, 각각의 NFVI 도메인을 관리하는 VIM이 여러 개 있을 수 있습니다. 이것은 &lt;code&gt;과제 1&lt;/code&gt;을 만듭니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;과제 1&lt;/p&gt;
&lt;p&gt;동일한 또는 서로 다른 PoP(Point of Presence)에 여러 VIM이 있는 경우, 누가 다른 VIM의 자원을 관리/조정할까요?
섹션 2에서 언급한 바와 같이, 각각의 VNF를 관리하는 VNFM이 여러 개 있을 수 있습니다. 이것은 &lt;code&gt;과제 2&lt;/code&gt;를 만듭니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;과제 2&lt;/p&gt;
&lt;p&gt;서로 다른 VNFM 도메인의 VNF를 포함하는 종단 간(end-to-end) 서비스 생성을
누가 관리/조정할까요?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이러한 과제는 NFVO의 다음 두 가지 기능이 해결해 줍니다.&lt;/p&gt;
&lt;h2 id=&#34;resource-orchestration&#34;&gt;Resource Orchestration&lt;/h2&gt;
&lt;p&gt;NFVO는 서로 다른 PoP 간에 또는 하나의 PoP 내에서 NFVI 자원을 조정, 승인, 해제, 결합합니다.
이는 NFVI 자원을 직접 사용하는 대신 Northbound API를 통해 VIM과 직접 연결함으로써 수행합니다.&lt;/p&gt;
&lt;p&gt;이 기능은 서로 다른 VIM의 자원 할당하는 &lt;code&gt;과제 1&lt;/code&gt;을 직접 해결합니다.&lt;/p&gt;
&lt;h2 id=&#34;service-orchestration&#34;&gt;Service Orchestration&lt;/h2&gt;
&lt;p&gt;서비스 오케스트레이션은 서로 다른 VNF(다른 VNFM이 관리할 수 있는) 간에 종단 간 서비스를 생성하는 &lt;code&gt;과제 2&lt;/code&gt;를 해결합니다.&lt;/p&gt;
&lt;p&gt;다음과 같은 방법으로 해결합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서비스 오케스트레이션은 VNF와 직접 통신할 필요가 없도록 각 VNFM과 조정하여 서로 다른 VNF 간에 종단 간 서비스를 생성합니다.
예를 들면 한 벤더의 기지국 VNF와 다른 벤더의 중심 노드 VNF 사이에 서비스를 생성하는 것입니다.&lt;/li&gt;
&lt;li&gt;서비스 오케스트레이션은 해당되는 VNFM을 인스턴스화할 수 있습니다.&lt;/li&gt;
&lt;li&gt;네트워크 서비스 인스턴스의 토폴로지(&lt;a href=&#34;https://docs.openstack.org/tacker/queens/user/vnffg_usage_guide.html&#34;&gt;VNF Forwarding Graph&lt;/a&gt;, &lt;code&gt;VNFFG&lt;/code&gt;라고도 함)도 관리합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NFVO가 서로 다른 기능을 결합하고 서로 다른 방법으로 분산된 NFV 환경에서 종단 간 서비스를 생성하며 자원을 조정하는,
NFV의 접착제와 같다는 점을 알 수 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;4-repositories&#34;&gt;4. Repositories&lt;/h1&gt;
&lt;p&gt;NFV MANO에서 서로 다른 정보를 저장하는 리포지토리(파일/목록)를 이해하는 것은 매우 중요합니다.
리포지토리에는 네 가지 유형이 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;vnf-catalog&#34;&gt;VNF Catalog&lt;/h2&gt;
&lt;p&gt;VNF 카탈로그는 사용 가능한 모든 VNFD(VNF Descriptor)의 저장소입니다.&lt;/p&gt;
&lt;p&gt;VNFD는 VNF의 배포 및 동작 요구 사항 측면에서 VNF를 설명하는 배포 템플릿(deployment template)입니다.
주로 VNFM이 VNF 인스턴스화 및 VNF 인스턴스의 라이프사이클 관리 프로세스에서 사용합니다.
VNFD에서 제공된 정보는 NFVO가 NFVI의 네트워크 서비스와 가상화된 자원을 관리 및 조정하는 데도 사용됩니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[역주] 예시&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docbox.etsi.org/ISG/NFV/Open/other/Tutorials/201810-Tutorials-SDN_NFV_World_Congress-The_Haque/ETSI_NFV_Layer123_SDN_NFV_WC_2018_VNFD_RX15002.pdf&#34;&gt;VNF Descriptor (VNFD) Overview | ETSI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.openstack.org/tacker/newton/devref/vnfd_template_description.html&#34;&gt;VNF Descriptor Template Guide | Openstack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;network-services-ns-catalog&#34;&gt;Network Services (NS) Catalog&lt;/h2&gt;
&lt;p&gt;사용 가능한 네트워크 서비스의 목록입니다.
가상 링크를 통한 연결에 대한 설명과 VNF 측면에서 네트워크 서비스를 위한 배포 템플릿은 향후 사용을 위해 NS 카탈로그에 저장됩니다.&lt;/p&gt;
&lt;h2 id=&#34;nfv-instances&#34;&gt;NFV Instances&lt;/h2&gt;
&lt;p&gt;NFV 인스턴스 목록에는 네트워크 서비스 인스턴스 및 관련 VNF 인스턴스에 대한 모든 세부 정보가 들어 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;nfvi-resources&#34;&gt;NFVI Resources&lt;/h2&gt;
&lt;p&gt;NFV 서비스 구축에 활용되는 NFVI 자원의 리포지토리입니다.&lt;/p&gt;
&lt;p&gt;다음 두 가지 관리 시스템은 NFV MANO에 속하지 않지만 NFVO MANO 기능 블록과 정보를 교환하기 때문에 설명합니다.&lt;/p&gt;
&lt;h1 id=&#34;5-element-management-em&#34;&gt;5. Element Management (EM)&lt;/h1&gt;
&lt;p&gt;EM은 MANO에 속하지 않지만 중요한 역할을 합니다.&lt;/p&gt;
&lt;p&gt;EM은 VNF의 기능 부분에 대한 FCAPS를 담당합니다.
VNFM은 VNF의 FCAPS도 하지만 가상 부분에서만 합니다.&lt;/p&gt;
&lt;p&gt;명확히 하기 위해 예를 들면, 일반적으로 MANO는 가상과 물리적 세계의 델타에만 책임이 있습니다.
VNFM을 예로 들면 VNF의 라이프사이클 관리와 FCAPS를 수행합니다.
장애 관리(fault management) 측면에서 VNF를 실행하는 데 문제가 있으면 VNFM이 보고하지만,
기능과 관련된 장애인 경우(예: 모바일 코어에서 일부 신호 전달 문제) EM이 보고합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;델타(delta): 수학에서 &lt;code&gt;&#39;차이&#39;&lt;/code&gt;, &lt;code&gt;&#39;변화&#39;&lt;/code&gt;를 나타냄.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;VNFM은 운영자가 모든 종류의 FCAPS(가상 + 기능)에 대해 단일 GUI를 사용하고자 하는 경우에 대비하여 EM에 인터페이스를 노출시킵니다.&lt;/p&gt;
&lt;h1 id=&#34;6-ossbss&#34;&gt;6. OSS/BSS&lt;/h1&gt;
&lt;p&gt;OSS/BSS는 서비스 사업자가 사업을 운영하기 위해 사용하는 시스템/애플리케이션 모음을 포함합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;OSS: Operations Support Systems&lt;/li&gt;
&lt;li&gt;BSS: Business Support Systems&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;NFV는 OSS/BSS와 같이 동작해야 합니다.&lt;/p&gt;
&lt;p&gt;원칙적으로는 VNF와 NFVI를 직접 관리하기 위해 기존 OSS/BSS의 기능을 확장할 수 있지만,
그것은 벤더의 독점적 구현일 수 있습니다.
(적어도 현재까지는 ETSI가 EM과 VNF 간의 인터페이스는 정의하지 않았습니다.)
NFV는 오픈 플랫폼(open platform)이기 때문에 MANO처럼 오픈 인터페이스(open interfaces)를 통해 NFV 엔터티를 관리하는 것이 더 타당합니다.&lt;/p&gt;
&lt;p&gt;그러나 기존의 OSS/BBS는 NFV MANO의 특정 구현으로 인해 지원되지 않는 경우,
추가 기능을 제공함으로써 NFV MANO에 부가 가치를 만들 수 있습니다.
이는 NFV MANO와 기존 OSS/BSS 사이의 &lt;a href=&#34;https://telcocloudbridge.com/blog/open-ran-tutorial/&#34;&gt;오픈 참조점(open reference point)&lt;/a&gt;(Or-Ma-NFVO)을 통해 이루어집니다.&lt;/p&gt;
&lt;h1 id=&#34;7-reference-points&#34;&gt;7. Reference Points&lt;/h1&gt;
&lt;p&gt;마지막으로 &lt;code&gt;참조점&lt;/code&gt;에 대해 언급할 가치가 있습니다.&lt;/p&gt;
&lt;p&gt;MANO에는 그림과 같이 기능 블록 간의 연결 포인트(interconnection point)로 표시되는 여러 참조점이 있습니다.
Or-Vi, NF-Vi, Or-Vnfm 등입니다.&lt;/p&gt;
&lt;p&gt;왜 MANO는 그들을 인터페이스가 아닌 참조점이라고 부를까요?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;인터페이스&lt;/code&gt;가 엔터티 간의 양방향 통신을 허용하는 것과 관련이 있기 때문에 MANO는 참조점을 인터페이스라고 부르지 않습니다.
참조점은 기능 블록의 외부 관점(external view)을 정의하고 노출하는 아키텍처 개념입니다.
그리고 MANO는 기능 블록에 대해 이야기하기 때문에 &lt;code&gt;참조점&lt;/code&gt;이라는 단어를 대신 사용합니다.&lt;/p&gt;
&lt;p&gt;이것이 NFV MANO에 대한 전부입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;당신의 견해를 알려주세요.
최종 사용자라면 NFV의 여러 관리 시스템에 대해 어떻게 생각하시나요?
그들이 당신에게 타당한가요?
기존 EMS/OSS와 어떻게 비교하시나요?&lt;br&gt;
&lt;br&gt;
벤더라면 NFV MANO에서 구현 중인 부분과 힘든 점은 무엇인가요?
어떠한 견해라도 알려주세요.&lt;/p&gt;
&lt;/blockquote&gt;
- https://markruler.github.io/posts/nfv/beginners-guide-to-nfv-mano/ - Im Changsu 2020 - 2024</description>
        </item>
    
    
    
        <item>
        <title>&#34;NFV 아키텍처&#34; 이해를 위한 치트 시트</title>
        <link>https://markruler.github.io/posts/nfv/cheat-sheet-understanding-nfv-architecture/</link>
        <pubDate>Tue, 22 Sep 2020 21:58:08 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/nfv/cheat-sheet-understanding-nfv-architecture/</guid>
        <description>임창수 https://markruler.github.io/posts/nfv/cheat-sheet-understanding-nfv-architecture/ -&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.telcocloudbridge.com/blog/a-cheat-sheet-for-understanding-nfv-architecture/&#34;&gt;Faisal Khan의 A Cheat Sheet for Understanding &amp;ldquo;NFV Architecture&amp;rdquo;&lt;/a&gt;를 번역한 글입니다.&lt;/li&gt;
&lt;li&gt;저자의 허락을 받고 번역했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;시간이 없으신가요?&lt;/p&gt;
&lt;p&gt;쉽게 이해할 수 있는 NFV 용어/아키텍처에 대한 빠른 업데이트가 필요하신가요?&lt;/p&gt;
&lt;p&gt;그렇다면 NFV 아키텍처를 시작하는 데 필요한 모든 정보를 얻을 수 있는 아래 7가지 주요 블록을 보세요. 블록 번호 및 정의를 따라가세요.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/nfv/nfv-architecture.png&#34; alt=&#34;nfv-architecture&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-vnf-virtual-network-function&#34;&gt;1. VNF (Virtual Network Function)&lt;/h2&gt;
&lt;p&gt;VNF는 가상화된 네트워크 요소로 NFV 아키텍처의 기본 블록입니다.
예를 들어 라우터를 가상화하면 라우터 VNF라고 부르고, 다른 예는 기지국(base station) VNF도 있습니다.
네트워크 요소의 한 가지 하위 기능(sub-function)만 가상화해도 VNF라고 합니다.
예를 들어 라우터의 다양한 하위 기능은 가상 라우터로서 함께 작동하는 별도의 VNF가 될 수 있다.&lt;/p&gt;
&lt;p&gt;VNF의 다른 예로는 방화벽(firewall), IPS, GGSN, SGSN, RNC, EPC 등이 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;2-em-element-management&#34;&gt;2. EM (Element Management)&lt;/h2&gt;
&lt;p&gt;EM은 VNF의 요소 관리 시스템(EMS)입니다.
이것은 VNF(즉, FCAPS: Fault, Configuration, Accounting, Perfomance, Security) 기능을 관리합니다.
독점적 인터페이스를 통해 VNF를 관리할 수도 있습니다.
VNF당 1개의 EMS가 있을 수도 있고 하나의 EMS가 여러 개의 VNF를 관리할 수도 있습니다.
EMS 자체가 VNF일 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;3-vnf-manager&#34;&gt;3. VNF Manager&lt;/h2&gt;
&lt;p&gt;VNF 매니저는 하나 또는 여러 VNF 인스턴스의 라이프사이클을 관리합니다.
라이프사이클 관리란 VNF를 할당, 유지, 해제하는 것을 말합니다.&lt;/p&gt;
&lt;p&gt;또한 VNFM(VNF 매니저)은 VNF의 가상 부분에 대해 FCAPS를 수행한다.&lt;/p&gt;
&lt;p&gt;EM 및 VNFM의 차이에 유의해야 합니다.
EM은 기능 요소를 관리하는 반면, VNFM은 가상 요소를 관리합니다.
다음 예시로 명확하게 설명하겠습니다. 모바일 코어가 가상화된 경우,
EM은 기능 부분(예: 모바일 신호 전달)을 관리하고,
VNFM은 가상 부분(예: 자체 VNF 생성)을 관리합니다.&lt;/p&gt;
&lt;h2 id=&#34;4-nfvi-network-function-virtualization-infrastructure&#34;&gt;4. NFVI (Network Function Virtualization Infrastructure)&lt;/h2&gt;
&lt;p&gt;NFVI는 VNF가 실행되는 환경입니다.
여기에는 아래에 설명된 물리 자원, 가상 자원 및 가상화 계층이 포함된다.&lt;/p&gt;
&lt;h3 id=&#34;41-compute-memory-and-networking-resources&#34;&gt;4.1 Compute, Memory and Networking Resources&lt;/h3&gt;
&lt;p&gt;NFVI의 물리적인 부분입니다.
가상 자원은 이러한 물리 자원에 의해 인스턴스화 됩니다.
모든 물리 스위치 또는 물리 서버, 물리 스토리지 서버는 이 범주에 포함됩니다.&lt;/p&gt;
&lt;h3 id=&#34;42-virtual-compute-virtual-memory-and-virtual-networking-resources&#34;&gt;4.2 Virtual Compute, Virtual Memory and Virtual Networking Resources&lt;/h3&gt;
&lt;p&gt;NFVI의 가상 부분입니다.
물리 자원은 궁극적으로 VNF가 활용하는 가상 자원으로 추상화됩니다.&lt;/p&gt;
&lt;h3 id=&#34;43-virtualization-layer&#34;&gt;4.3 Virtualization Layer&lt;/h3&gt;
&lt;p&gt;가상화 계층은 물리 자원을 가상 자원으로 추상화하는 역할을 담당합니다. 일반적인 산업 용어로 &lt;code&gt;하이퍼바이저&lt;/code&gt;라고 합니다.
이 계층은 소프트웨어가 하드웨어로부터 독립적으로 실행될 수 있도록 합니다.&lt;/p&gt;
&lt;p&gt;가상화 계층이 없다고 가정할 때, VNF가 물리 자원에서 직접 실행될 수 있다고 생각할 수 있습니다.
그러나 정의상 VNF라고 부를 수 없으며 NFV 아키텍처라고도 할 수 없습니다.
적절하게 PNF(물리 네트워크 기능)라고 불릴 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;5-vim-virtualized-infrastructure-manager&#34;&gt;5. VIM (Virtualized Infrastructure Manager)&lt;/h2&gt;
&lt;p&gt;NFVI를 위한 관리 시스템입니다.
한 사업자의 인프라 도메인 내에서 NFVI 컴퓨팅, 네트워크 및 스토리지 리소스를 제어하고 관리합니다.
성능 측정 및 이벤트 수집도 담당합니다.&lt;/p&gt;
&lt;h2 id=&#34;6-nfv-orchestrator&#34;&gt;6. NFV Orchestrator&lt;/h2&gt;
&lt;p&gt;VNF의 네트워크 서비스를 직접 생성, 유지, 해제합니다.
VNF가 여러 개 있는 경우 여러 VNF 종단 간(end-to-end) 서비스를 생성할 수 있도록 합니다.&lt;/p&gt;
&lt;p&gt;NFVI 자원의 전역 자원(global resource)도 관리합니다.
예를 들어 네트워크에 있는 여러 VIM 간에 컴퓨팅, 스토리지 및 네트워킹 자원 등의 NFVI 자원을 관리합니다.&lt;/p&gt;
&lt;p&gt;오케스트레이터는 VNF와 직접 통신하지 않고 VNFM과 VIM을 통해 기능을 수행합니다.&lt;/p&gt;
&lt;p&gt;예시:
종단 간 서비스를 생성하기 위해 체인을 연결해야 하는 VNF가 여러 개 있다고 가정해 봅시다.
이러한 사례의 한 예는 가상 기지국과 가상 EPC입니다. 이것들은 동일하거나 다른 벤더일 수 있습니다.
양쪽의 VNF를 모두 사용하여 종단 간 서비스를 생성해야 할 것입니다.
이를 위해서는 서비스 오케스트레이터가 두 VNF와 통신하여 종단 간 서비스를 생성해야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;7-ossbssoperation-support-systembusiness-support-system&#34;&gt;7. OSS/BSS(Operation Support System/Business Support System)&lt;/h2&gt;
&lt;p&gt;OSS/BSS는 사업자의 OSS/BSS를 말한다.
OSS는 네트워크, 장애, 구성, 서비스를 관리합니다.
BSS는 고객, 제품, 주문 등을 관리합니다.&lt;/p&gt;
&lt;p&gt;NFV 아키텍처에서 사업자의 현재 BSS/OSS는 표준 인터페이스를 통해 NFV MANO (Management and Orchestration)와 통합할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이게 전부입니다!&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.telcocloudbridge.com/blog/a-cheat-sheet-for-understanding-nfv-architecture/&#34;&gt;원문 링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;사용 사례 및 SDN과의 관계를 포함한 NFV에 대한 자세한 내용을 보려면
헤더 섹션의 링크에서 NFV 마인드맵을 다운로드하세요.
개념을 더 쉽게 따라가기 위해 레퍼런스로 사용할 수 있도록 NFV 마인드 맵을 만들었습니다.&lt;/p&gt;
&lt;p&gt;코멘트를 남겨서 NFV 아키텍처용 &lt;code&gt;치트 시트&lt;/code&gt;에 대해 어떻게 생각하는지 알려주세요.&lt;/p&gt;
- https://markruler.github.io/posts/nfv/cheat-sheet-understanding-nfv-architecture/ - Im Changsu 2020 - 2024</description>
        </item>
    
    
    
        <item>
        <title>쿠버네티스 API 접근 제어</title>
        <link>https://markruler.github.io/posts/kubernetes/controlling-access-api/</link>
        <pubDate>Thu, 17 Sep 2020 06:58:08 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/kubernetes/controlling-access-api/</guid>
        <description>임창수 https://markruler.github.io/posts/kubernetes/controlling-access-api/ -&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/controlling-access/&#34;&gt;쿠버네티스 공식 문서&lt;/a&gt;를 번역했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- overview --&gt;
&lt;p&gt;이 페이지는 쿠버네티스 API에 대한 접근 제어의 개요를 제공한다.&lt;/p&gt;
&lt;!-- body --&gt;
&lt;p&gt;사용자는&lt;code&gt;kubectl&lt;/code&gt;, 클라이언트 라이브러리
또는 REST 요청을 통해
&lt;a href=&#34;https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/&#34;&gt;API에 접근한다&lt;/a&gt;.
사용자와 쿠버네티스 서비스 어카운트 모두 API에 접근할 수 있다.
요청이 API에 도달하면,
다음 다이어그램에 설명된 몇 가지 단계를 거친다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/kubernetes/access-control-overview.svg&#34; alt=&#34;Diagram of request handling steps for Kubernetes API request&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;전송-보안&#34;&gt;전송 보안&lt;/h2&gt;
&lt;p&gt;일반적인 쿠버네티스 클러스터에서 API는 443번 포트에서 서비스한다.
API 서버는 인증서를 제시한다.
이 인증서는 종종 자체 서명되기 때문에 일반적으로 사용자 머신의 &lt;code&gt;$USER/.kube/config&lt;/code&gt;은
API 서버의 인증서에 대한 루트 인증서를 포함하며,
시스템 기본 루트 인증서 대신 사용된다.
&lt;code&gt;kube-up.sh&lt;/code&gt;을 사용하여 클러스터를 직접 생성할 때
이 인증서는 일반적으로 &lt;code&gt;$USER/.kube/config&lt;/code&gt;에 자동으로 기록된다.
클러스터에 여러 명의 사용자가 있는 경우, 작성자는 인증서를 다른 사용자와 공유해야 한다.&lt;/p&gt;
&lt;h2 id=&#34;인증&#34;&gt;인증&lt;/h2&gt;
&lt;p&gt;TLS가 설정되면 HTTP 요청이 인증 단계로 넘어간다.
이는 다이어그램에 &lt;strong&gt;1&lt;/strong&gt;단계로 표시되어 있다.
클러스터 생성 스크립트 또는 클러스터 관리자는
API 서버가 하나 이상의 인증기 모듈을 실행하도록 구성하십시오.
인증기는 &lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/authentication/&#34;&gt;여기&lt;/a&gt;에서 더 자세히 서술한다.&lt;/p&gt;
&lt;p&gt;인증 단계로 들어가는 것은 온전한 HTTP 요청이지만
일반적으로 헤더 그리고/또는 클라이언트 인증서만 검사한다.&lt;/p&gt;
&lt;p&gt;인증 모듈은 클라이언트 인증서, 암호 및 일반 토큰, 부트스트랩 토큰,
JWT 토큰(서비스 어카운트에 사용됨)을 포함한다.&lt;/p&gt;
&lt;p&gt;여러 개의 인증 모듈을 지정할 수 있으며,
이 경우 하나의 인증 모듈이 성공할 때까지 각 모듈을 순차적으로 시도한다.&lt;/p&gt;
&lt;p&gt;GCE에서는 클라이언트 인증서, 암호, 일반 토큰 및 JWT 토큰이 모두 사용 가능하다.&lt;/p&gt;
&lt;p&gt;요청을 인증할 수 없는 경우 HTTP 상태 코드 401과 함께 거부된다.
이 외에는 사용자가 특정 &lt;code&gt;username&lt;/code&gt;으로 인증되며,
이 username은 다음 단계에서 사용자의 결정에 사용할 수 있다.
일부 인증기는 사용자 그룹 관리 기능을 제공하는 반면,
이외의 인증기는 그렇지 않다.&lt;/p&gt;
&lt;p&gt;쿠버네티스는 접근 제어 결정과 요청 기록 시 &lt;code&gt;usernames&lt;/code&gt;를 사용하지만,
&lt;code&gt;user&lt;/code&gt; 오브젝트를 가지고 있지 않고 usernames 나 기타 사용자 정보를
오브젝트 저장소에 저장하지도 않는다.&lt;/p&gt;
&lt;h2 id=&#34;인가&#34;&gt;인가&lt;/h2&gt;
&lt;p&gt;특정 사용자로부터 온 요청이 인증된 후에는 인가되어야 한다. 이는 다이어그램에 &lt;strong&gt;2&lt;/strong&gt;단계로 표시되어 있다.&lt;/p&gt;
&lt;p&gt;요청은 요청자의 username, 요청된 작업 및 해당 작업이 영향을 주는 오브젝트를 포함해야 한다. 기존 정책이 요청된 작업을 완료할 수 있는 권한이 해당 사용자에게 있다고 선언하는 경우 요청이 인가된다.&lt;/p&gt;
&lt;p&gt;예를 들어 Bob이 아래와 같은 정책을 가지고 있다면 &lt;code&gt;projectCaribou&lt;/code&gt; 네임스페이스에서만 파드를 읽을 수 있다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &amp;#34;apiVersion&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;abac.authorization.kubernetes.io/v1beta1&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &amp;#34;kind&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;Policy&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &amp;#34;spec&amp;#34;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &amp;#34;user&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;bob&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &amp;#34;namespace&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;projectCaribou&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &amp;#34;resource&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;pods&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &amp;#34;readonly&amp;#34;: &lt;span style=&#34;color:#f00&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Bob이 다음과 같은 요청을 하면 &amp;lsquo;projectCaribou&amp;rsquo; 네임스페이스의 오브젝트를 읽을 수 있기 때문에 요청이 인가된다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;#34;apiVersion&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;authorization.k8s.io/v1beta1&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;#34;kind&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;SubjectAccessReview&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;#34;spec&amp;#34;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &amp;#34;resourceAttributes&amp;#34;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;namespace&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;projectCaribou&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;verb&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;get&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;group&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;unicorn.example.org&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;resource&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;pods&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Bob이 &lt;code&gt;projectCaribou&lt;/code&gt; 네임스페이스에 있는 오브젝트에 쓰기(&lt;code&gt;create&lt;/code&gt; 또는 &lt;code&gt;update&lt;/code&gt;) 요청을 하면 그의 인가는 거부된다. 만약 Bob이 &lt;code&gt;projectFish&lt;/code&gt;처럼 다른 네임스페이스의 오브젝트 읽기(&lt;code&gt;get&lt;/code&gt;) 요청을 하면 그의 인가는 거부된다.&lt;/p&gt;
&lt;p&gt;쿠버네티스 인가는 공통 REST 속성을 사용하여 기존 조직 전체 또는 클라우드 제공자 전체의 접근 제어 시스템과 상호 작용할 것을 요구한다. 이러한 제어 시스템은 쿠버네티스 API 이외의 다른 API와 상호작용할 수 있으므로 REST 형식을 사용하는 것이 중요하다.&lt;/p&gt;
&lt;p&gt;쿠버네티스는 ABAC 모드, RBAC 모드, 웹훅 모드와 같은 여러 개의 인가 모듈을 지원한다. 관리자가 클러스터를 생성할 때 API 서버에서 사용해야 하는 인가 모듈을 구성했다. 인가 모듈이 2개 이상 구성되면 쿠버네티스가 각 모듈을 확인하고, 어느 모듈이 요청을 승인하면 요청을 진행할 수 있다. 모든 모듈이 요청을 거부하면 요청이 거부된다(HTTP 상태 코드 403).&lt;/p&gt;
&lt;p&gt;인가 모듈을 사용한 정책 생성을 포함해 쿠버네티스 인가에 대해 더 배우려면 &lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz//authorization/&#34;&gt;인가 개요&lt;/a&gt;를 참조하십시오.&lt;/p&gt;
&lt;h2 id=&#34;승인-제어&#34;&gt;승인 제어&lt;/h2&gt;
&lt;p&gt;승인 제어 모듈은 요청을 수정하거나 거부할 수 있는 소프트웨어 모듈이다.
인가 모듈에서 사용할 수 있는 속성 외에도
승인 제어 모듈은 생성되거나 수정된 오브젝트 내용에 접근할 수 있다.&lt;/p&gt;
&lt;p&gt;어드미션 컨트롤러는 오브젝트를 생성, 수정, 삭제 또는 (프록시에) 연결하는 요청에 따라 작동한다.
어드미션 컨트롤러는 단순히 객체를 읽는 요청에 작동하지 않는다.
여러 개의 어드미션 컨트롤러가 구성되면 순서대로 호출된다.&lt;/p&gt;
&lt;p&gt;이는 다이어그램에 &lt;strong&gt;3&lt;/strong&gt;단계로 표시되어 있다.&lt;/p&gt;
&lt;p&gt;인증 및 인가 모듈과 달리,
승인 제어 모듈이 거부되면 요청은 즉시 거부된다.&lt;/p&gt;
&lt;p&gt;승인 제어 모듈은 오브젝트를 거부하는 것 외에도
필드의 복잡한 기본값을 설정할 수 있다.&lt;/p&gt;
&lt;p&gt;사용 가능한 승인 제어 모듈은 &lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/&#34;&gt;여기&lt;/a&gt;에 서술되어 있다.&lt;/p&gt;
&lt;p&gt;요청이 모든 승인 제어 모듈을 통과하면 유효성 검사 루틴을 사용하여 해당 API 오브젝트를 검증한 후
오브젝트 저장소에 기록(&lt;strong&gt;4단계&lt;/strong&gt;)된다.&lt;/p&gt;
&lt;h2 id=&#34;api-서버-포트와-ip&#34;&gt;API 서버 포트와 IP&lt;/h2&gt;
&lt;p&gt;이전의 논의는 (일반적인 경우) API 서버의 보안 포트로 전송되는 요청에 적용된다.
API 서버는 실제로 다음과 같이 2개의 포트에서 서비스할 수 있다.&lt;/p&gt;
&lt;p&gt;기본적으로 쿠버네티스 API 서버는 2개의 포트에서 HTTP 서비스를 한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;로컬호스트 포트&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테스트 및 부트스트랩을 하기 위한 것이며 마스터 노드의 다른 구성요소
(스케줄러, 컨트롤러 매니저)가 API와 통신하기 위한 것이다.&lt;/li&gt;
&lt;li&gt;TLS가 없다.&lt;/li&gt;
&lt;li&gt;기본 포트는 8080이며, &lt;code&gt;--insecure-port&lt;/code&gt; 플래그를 사용하여 변경한다.&lt;/li&gt;
&lt;li&gt;기본 IP는 로컬호스트(localhost)이며, &lt;code&gt;--insecure-bind-address&lt;/code&gt; 플래그를 사용하여 변경한다.&lt;/li&gt;
&lt;li&gt;요청이 인증 및 인가 모듈을 &lt;strong&gt;우회한다&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;요청이 승인 제어 모듈(들)에 의해 처리된다.&lt;/li&gt;
&lt;li&gt;호스트 접근 요구로부터 보호를 받는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;보안 포트&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가능하면 언제나 사용하십시오.&lt;/li&gt;
&lt;li&gt;TLS를 사용하십시오. &lt;code&gt;--tls-cert-file&lt;/code&gt; 플래그로 인증서를 지정하고 &lt;code&gt;--tls-private-key-file&lt;/code&gt; 플래그로 키를 지정하십시오.&lt;/li&gt;
&lt;li&gt;기본 포트는 6443이며, &lt;code&gt;--secure-port&lt;/code&gt; 플래그를 사용하여 변경한다.&lt;/li&gt;
&lt;li&gt;기본 IP는 로컬호스트가 아닌 첫 번째 네트워크 인터페이스이며, &lt;code&gt;--bind-address&lt;/code&gt; 플래그를 사용하여 변경한다.&lt;/li&gt;
&lt;li&gt;요청이 인증 및 인가 모듈에 의해 처리된다.&lt;/li&gt;
&lt;li&gt;요청이 승인 제어 모듈(들)에 의해 처리된다.&lt;/li&gt;
&lt;li&gt;인증 및 인가 모듈을 실행한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GCE(구글 컴퓨트 엔진) 및 다른 클라우드 제공자에서 &lt;code&gt;kube-up.sh&lt;/code&gt;로 클러스터를 생성하면
API 서버는 포트 443에서 서비스한다.
GCE에서는 외부 HTTPS가 API에 접근할 수 있도록 프로젝트에서 방화벽 규칙이 구성된다.
이외에 클러스터 설정 방법은 다양하다.&lt;/p&gt;
- https://markruler.github.io/posts/kubernetes/controlling-access-api/ - Im Changsu 2020 - 2024</description>
        </item>
    
    
    
        <item>
        <title>MEC 아키텍처 초심자 가이드</title>
        <link>https://markruler.github.io/posts/mec/beginners-guide-to-mec-architecture/</link>
        <pubDate>Sun, 13 Sep 2020 20:58:08 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/mec/beginners-guide-to-mec-architecture/</guid>
        <description>임창수 https://markruler.github.io/posts/mec/beginners-guide-to-mec-architecture/ -&lt;blockquote&gt;
&lt;p&gt;Faisal Khan의 &lt;a href=&#34;https://www.telcocloudbridge.com/blog/beginners-guide-to-mec-architecture-multi-access-edge-computing/&#34;&gt;Beginners Guide to MEC Architecture (Multi-access Edge Computing)&lt;/a&gt;을 번역한 글입니다.
저자의 허락을 받아 번역했습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MEC&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 아키텍처 가이드에 오신 것을 환영합니다!&lt;/p&gt;
&lt;p&gt;MEC는 5G의 저지연(low-latency) 서비스를 활용하려는 이동통신사들의 새로운 투자 물결을 가져올 것입니다.
이는 소비자와 더 가까운 곳, 즉 무선 기지국(radio site)과 가까운 곳에서 서비스를 운영하겠다는 것을 의미합니다.&lt;/p&gt;
&lt;p&gt;MEC는 서비스 사업자들에게 새로운 서비스 분야와 수익 창출의 수단입니다.
예를 들어 더 빠른 게임 경험, 증강/가상 현실, 커넥티드 카 등이 있습니다.&lt;/p&gt;
&lt;p&gt;이러한 잠재력 때문에 Azure, AWS, Google과 같은 웹 스케일러(web scaler)도
이 흐름에 뛰어들어 갑자기 자신들의 MEC 플랫폼을 구축하는 데 자금을 투입하기 시작한 것입니다.&lt;/p&gt;
&lt;p&gt;이 MEC 아키텍처 가이드는 사실상 MEC 표준 기구인 ETSI 모델을 기반으로 하고 있습니다.
MEC 아키텍처를 처음부터 단계적으로 설명하며, 사전 지식이 없더라도 이해할 수 있도록 구성되어 있습니다.&lt;/p&gt;
&lt;p&gt;MEC 아키텍처를 이해하면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서비스 사업자는 표준 기반 MEC 플랫폼/아키텍처로 전환하는 방법을 알게 됩니다.&lt;/li&gt;
&lt;li&gt;벤더와 개발사는 솔루션 제품이 ETSI MEC 모델에 얼마나 부합하는지 고객에게 설명할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그럼 바로 시작해 보겠습니다!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-mec%EC%9D%98-%EC%A0%95%EC%9D%98&#34;&gt;1. MEC의 정의&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-etsi%EC%97%90-%EB%94%B0%EB%A5%B8-mec-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98&#34;&gt;2. ETSI에 따른 MEC 아키텍처&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#2-0-%EA%B0%80%EC%83%81%ED%99%94-%EC%9D%B8%ED%94%84%EB%9D%BC-%EB%A7%A4%EB%8B%88%EC%A0%80-vim-virtualization-infrastructure-manager&#34;&gt;2-0. 가상화 인프라 매니저 (VIM, Virtualization Infrastructure Manager)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-1-mec-host&#34;&gt;2-1. MEC Host&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#2-1-1-mec-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98&#34;&gt;2-1-1. MEC 애플리케이션&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-1-2-mec-%ED%94%8C%EB%9E%AB%ED%8F%BC&#34;&gt;2-1-2. MEC 플랫폼&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#2-1-2-1-mec-%EC%84%9C%EB%B9%84%EC%8A%A4&#34;&gt;2-1-2-1. MEC 서비스&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-1-2-2-%ED%8A%B8%EB%9E%98%ED%94%BD-%EA%B7%9C%EC%B9%99-%EC%A0%9C%EC%96%B4-traffic-rules-control&#34;&gt;2-1-2-2. 트래픽 규칙 제어 (Traffic Rules Control)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-1-2-3-dns-%ED%95%B8%EB%93%A4%EB%A7%81&#34;&gt;2-1-2-3. DNS 핸들링&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-2-mec-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EB%A7%A4%EB%8B%88%EC%A0%80-mec-platform-manager&#34;&gt;2-2. MEC 플랫폼 매니저 (MEC Platform Manager)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-3-%EB%A9%80%ED%8B%B0-%EC%95%A1%EC%84%B8%EC%8A%A4-%EC%97%90%EC%A7%80-%EC%98%A4%EC%BC%80%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0-multi-access-edge-orchestrator&#34;&gt;2-3. 멀티 액세스 에지 오케스트레이터 (Multi-access Edge Orchestrator)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cfs-portal&#34;&gt;CFS Portal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%88%98%EB%AA%85-%EC%A3%BC%EA%B8%B0-%EA%B4%80%EB%A6%AC-%ED%94%84%EB%A1%9D%EC%8B%9C-user-app-lcm-proxy&#34;&gt;사용자 애플리케이션 수명 주기 관리 프록시 (User App LCM Proxy)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%EC%B0%B8%EC%A1%B0&#34;&gt;참조&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;우리는 밑바닥부터 블록 단위로 MEC 아키텍처를 구축할 것입니다. 🙂&lt;/p&gt;
&lt;h1 id=&#34;1-mec의-정의&#34;&gt;1. MEC의 정의&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.etsi.org/technologies/multi-access-edge-computing&#34;&gt;ETSI&lt;/a&gt;에 따르면 MEC는 다음과 같이 정의됩니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Multi-access Edge Computing (MEC) offers application developers and content providers
cloud-computing capabilities and an IT service environment at the edge of the network.
This environment is characterized by ultra-low latency and high bandwidth
as well as real-time access to radio network information that can be leveraged by applications.&lt;br&gt;
&lt;br&gt;
멀티 액세스 에지 컴퓨팅(MEC)은 애플리케이션 개발자와 콘텐츠 제공자에게
네트워크 에지(edge)에서 클라우드 컴퓨팅 기능과 IT 서비스 환경을 제공합니다.
이 환경은 초저지연과 고대역폭으로 특정지어지며,
애플리케이션에서 활용할 수 있는 무선 네트워크 정보에 대한 접근을 제공합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;2-etsi에-따른-mec-아키텍처&#34;&gt;2. ETSI에 따른 MEC 아키텍처&lt;/h1&gt;
&lt;p&gt;그럼 아래에 표시된 것처럼 완전한 MEC ETSI 아키텍처를 살펴보겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/mec-architecture-according-to-etsi.jpg&#34; alt=&#34;mec-architecture-according-to-etsi&#34;&gt;&lt;/p&gt;
&lt;p&gt;MEC 호스트, MEC 플랫폼 매니저, MEC 오케스트레이터라는 세 가지 주요 블록(block)이 있습니다.&lt;/p&gt;
&lt;p&gt;그러나 이 세 블록을 살펴보기 전에 가장 기본적인 블록인
가상화 인프라 매니저(Virtualization Infrastructure Manager, VIM)부터 시작해보겠습니다.&lt;/p&gt;
&lt;p&gt;가상 네트워크에서는 항상 서버가 필요하며, 이 서버 위에서 가상 머신(VM)을 구동할 수 있어야 합니다.
그리고 이러한 VM에는 관리 계층이 필요합니다.&lt;/p&gt;
&lt;h2 id=&#34;2-0-가상화-인프라-매니저-vim-virtualization-infrastructure-manager&#34;&gt;2-0. 가상화 인프라 매니저 (VIM, Virtualization Infrastructure Manager)&lt;/h2&gt;
&lt;p&gt;VIM은 &lt;a href=&#34;../../nfv/cheat-sheet-understanding-nfv-architecture/#5-vim-virtualized-infrastructure-manager&#34;&gt;NFV의 VIM&lt;/a&gt;과 유사한 기능을 합니다.
물리적 인프라(컴퓨팅, 스토리지, 네트워킹) 위에 VM을 관리하는 것이 목적입니다.
&amp;lsquo;가상화 인프라&amp;rsquo;의 가상 자원을 할당, 유지, 해제하는 역할을 담당합니다.
왼쪽에는 가상화된 인프라로 전환된 서버가 있고, 오른쪽에는 이러한 서버 위의 가상 자원을 관리하는 VIM이 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/virtualization-infrastructure-manager.jpg&#34; alt=&#34;virtualization-infrastructure-manager&#34;&gt;&lt;/p&gt;
&lt;p&gt;VIM과 가상 자원을 이해한 후, 이제 그 위에 MEC 플랫폼과 MEC 애플리케이션을 구축해보겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;2-1-mec-host&#34;&gt;2-1. MEC Host&lt;/h2&gt;
&lt;p&gt;가상화 인프라, MEC 애플리케이션, MEC 플랫폼을 함께 묶어 MEC 호스트라고 부릅니다.&lt;/p&gt;
&lt;p&gt;MEC 애플리케이션부터 살펴보겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;2-1-1-mec-애플리케이션&#34;&gt;2-1-1. MEC 애플리케이션&lt;/h3&gt;
&lt;p&gt;우리가 MEC를 실행하는 이유는 무엇일까요? 바로 애플리케이션을 실행하기 위해서입니다.&lt;/p&gt;
&lt;p&gt;MEC 애플리케이션은 MEC에서 VM 위에서 실행되는 실제 애플리케이션입니다.
쉽게 말해, MEC에서 실행되는 실제 앱들은 게임 애플리케이션이나 가상 현실(VR) 또는 증강 현실(AR)과 같은 것입니다.&lt;/p&gt;
&lt;p&gt;아래 다이어그램은 가상화 인프라 내의 가상 머신 위에 MEC 애플리케이션을 실행하는 모습을 보여줍니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/mec-application.jpg&#34; alt=&#34;mec-application&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-1-2-mec-플랫폼&#34;&gt;2-1-2. MEC 플랫폼&lt;/h3&gt;
&lt;p&gt;이제 다음 단계로 나아가서 우리의 빌딩 블록에 MEC 플랫폼을 추가해 보겠습니다.
MEC 플랫폼 안에는 여러 구성 요소가 있습니다.
그중에서 가장 중요한 것은 &lt;strong&gt;MEC 서비스&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/mec-platform.jpg&#34; alt=&#34;mec-platform&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-1-2-1-mec-서비스&#34;&gt;2-1-2-1. MEC 서비스&lt;/h4&gt;
&lt;p&gt;&amp;lsquo;MEC 서비스&amp;rsquo;는 MEC에서 중요한 블록입니다.
네트워크 관련 API는 MEC 서비스에 의해 노출되며, 위에 표시된 참조점(Reference Point) &lt;code&gt;Mp1&lt;/code&gt;을 통해 MEC 애플리케이션에 제공됩니다.
또한 MEC 플랫폼도 이러한 서비스를 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;여전히 헷갈리시나요?&lt;/p&gt;
&lt;p&gt;MEC ETSI 아키텍처의 장점은 MEC 애플리케이션들이 네트워크 정보를 알고 있다는 점입니다.
즉, MEC 애플리케이션이 네트워크 상태에 따라 조치를 취할 수 있습니다.
여기서 MEC 서비스는 API를 통해 네트워크 정보를 노출시켜 도움을 줄 수 있습니다.&lt;/p&gt;
&lt;p&gt;ETSI에 따르면 &amp;lsquo;MEC 서비스&amp;rsquo;에 의해 적어도 세 가지 유형의 서비스를 노출시켜야 하며,
이들은 서비스 레지스트리의 일부입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;무선 네트워크 상태&lt;/li&gt;
&lt;li&gt;위치 정보 (예: 사용자 장비&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;의 위치)&lt;/li&gt;
&lt;li&gt;대역폭 관리자 - 이 서비스를 사용하면 MEC 애플리케이션과 관련된 트래픽에 대해 대역폭을 할당하고 우선순위를 지정할 수 있도록 해줍니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MEC 서비스에 대해 논의한 후, 우리는 MEC 플랫폼의 다른 두 가지 구성요소도 알아야 합니다.&lt;/p&gt;
&lt;h4 id=&#34;2-1-2-2-트래픽-규칙-제어-traffic-rules-control&#34;&gt;2-1-2-2. 트래픽 규칙 제어 (Traffic Rules Control)&lt;/h4&gt;
&lt;p&gt;이것은 MEC 플랫폼의 중요한 부분입니다.
MEC 플랫폼은 여러 애플리케이션을 동시에 서비스하므로 &amp;lsquo;트래픽 규칙 제어&amp;rsquo; 를 통해 우선순위를 할당할 수 있어야 합니다.&lt;/p&gt;
&lt;h4 id=&#34;2-1-2-3-dns-핸들링&#34;&gt;2-1-2-3. DNS 핸들링&lt;/h4&gt;
&lt;p&gt;모바일 에지 플랫폼은 모든 사용자 장비로부터 수신된 DNS 트래픽을
로컬 DNS 서버/프록시로 라우팅하는 기능을 제공해야 합니다.&lt;/p&gt;
&lt;p&gt;이것이 왜 중요할까요? MEC의 이점은 많은 정보를 인터넷으로 보내지 않고 MEC 내에서 로컬로 처리하는 것입니다.
따라서 트래픽이 인터넷으로 전송되는 대신 로컬에서 처리되도록 로컬 DNS 서버에 DNS 리다이렉션을 처리할 수 있는 방법이 있어야 합니다.&lt;/p&gt;
&lt;p&gt;또한 &lt;code&gt;Mp3&lt;/code&gt; 인터페이스를 통해 기존 MEC 호스트에 연결된 다른 MEC 호스트가 있을 수 있다는 점도 유의해야 합니다.&lt;/p&gt;
&lt;p&gt;지금까지 VIM, MEC 플랫폼, MEC 애플리케이션을 다뤘지만,
MEC 플랫폼과 애플리케이션 자체의 관리는 어떻게 이루어질까요?
여기서 &lt;strong&gt;MEC 플랫폼 매니저&lt;/strong&gt;가 등장합니다.&lt;/p&gt;
&lt;h2 id=&#34;2-2-mec-플랫폼-매니저-mec-platform-manager&#34;&gt;2-2. MEC 플랫폼 매니저 (MEC Platform Manager)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/mec-platform-manager.jpg&#34; alt=&#34;mec-platform-manager&#34;&gt;&lt;/p&gt;
&lt;p&gt;NFV의 VNFM에 대해 알고 있으시죠?&lt;/p&gt;
&lt;p&gt;MEC 플랫폼 매니저는 VNFM과 동일하거나 더 많은 기능을 수행합니다. 다음과 같은 기능들을 포함합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MEC 애플리케이션의 수명 주기 관리: VM에서 MEC 애플리케이션을 생성(instantiating), 유지(maintaining), 종료(tearing down)하는 작업&lt;/li&gt;
&lt;li&gt;요소 관리: MEC 플랫폼의 FCAPS&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; 관리&lt;/li&gt;
&lt;li&gt;애플리케이션 규칙, 트래픽 규칙, DNS 구성 관리&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;지금까지는 MEC 플랫폼을 관리할 수 있게 되었지만 아직 끝난 것이 아닙니다.
여러 MEC 호스트가 있을 수 있으므로 MEC 플랫폼 관리자도 여러 개 있을 수 있습니다.
따라서 다양한 MEC 플랫폼 매니저들 간의 조정을 담당할 상위 계층이 필요합니다.
여기서 &lt;strong&gt;MEC 오케스트레이터&lt;/strong&gt;가 등장하며, 이를 통해 ETSI 아키텍처가 완성됩니다.&lt;/p&gt;
&lt;h2 id=&#34;2-3-멀티-액세스-에지-오케스트레이터-multi-access-edge-orchestrator&#34;&gt;2-3. 멀티 액세스 에지 오케스트레이터 (Multi-access Edge Orchestrator)&lt;/h2&gt;
&lt;p&gt;MEC 오케스트레이터는 여기서 NFVO 오케스트레이터와 비유할 수 있습니다.&lt;/p&gt;
&lt;p&gt;다음과 같은 기능을 수행합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MEC 애플리케이션 수명 주기 관리(MEC 플랫폼 매니저와 비교해보면 유사한 기능을 수행할 수 있습니다).
오케스트레이터는 MEC 플랫폼 매니저를 통해 애플리케이션과 통신하여 이 기능을 수행합니다.&lt;/li&gt;
&lt;li&gt;패키지 무결성(integrity) 및 신뢰성(authenticity) 검증 기능을 포함하여
애플리케이션 패키지를 설치(on-boarding)합니다.&lt;/li&gt;
&lt;li&gt;지연 시간, 사용 가능한 자원, 제공 가능한 서비스와 같은 제약 조건을 고려하여
애플리케이션 생성(instantiation)에 적합한 MEC 호스트를 선택합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/multi-access-edge-orchestrator.jpg&#34; alt=&#34;multi-access-edge-orchestrator&#34;&gt;&lt;/p&gt;
&lt;p&gt;마지막으로 몇 가지 언급해야 할 것들이 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;cfs-portal&#34;&gt;CFS Portal&lt;/h2&gt;
&lt;p&gt;CFS는 &amp;lsquo;고객 대면 서비스(Customer Facing Service)&amp;lsquo;를 의미합니다.
CFS를 통해 이동통신사의 고객은 새로운 MEC 애플리케이션을 주문하거나
서비스의 SLA(Service Level Agreement, 서비스 수준 계약)를 모니터링할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;사용자-애플리케이션-수명-주기-관리-프록시-user-app-lcm-proxy&#34;&gt;사용자 애플리케이션 수명 주기 관리 프록시 (User App LCM Proxy)&lt;/h2&gt;
&lt;p&gt;이것은 MEC 시스템에서 선택적 기능입니다.
이를 위해 시스템은 &lt;code&gt;UserApps&lt;/code&gt;라는 기능을 지원해야 합니다.&lt;/p&gt;
&lt;p&gt;모바일 에지 시스템이 &lt;code&gt;UserApps&lt;/code&gt; 기능을 지원할 때,
시스템은 사용자 장비(디바이스 애플리케이션이 실행되는 장비)와
특정 모바일 에지 애플리케이션(ME App) 인스턴스 간의 연결을 허용합니다.&lt;/p&gt;
&lt;p&gt;사용자 애플리케이션 LCM 프록시를 지원한다면
디바이스 애플리케이션이 사용자 애플리케이션의 설치(on-boarding), 생성(instantiation), 종료(termination)를 요청할 수 있게 해줍니다.&lt;/p&gt;
&lt;p&gt;간단히 말해, 이 기능이 MEC 시스템에서 지원되면
사용자는 자신의 디바이스에서 MEC 시스템 내 특정 애플리케이션을 실행할 수 있게 됩니다.&lt;/p&gt;
&lt;p&gt;이것으로 MEC 아키텍처 초심자 가이드를 마칩니다.
이제 이 아키텍처에 대해 궁금한 것이 있으면 언제든 질문해 주세요.&lt;/p&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.etsi.org/deliver/etsi_gs/MEC/001_099/003/01.01.01_60/gs_MEC003v010101p.pdf&#34;&gt;ETSI GS MEC 002 V1.1.1 (2016-03)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.etsi.org/deliver/etsi_gs/MEC/001_099/003/02.01.01_60/gs_MEC003v020101p.pdf&#34;&gt;ETSI GS MEC 003 V2.1.1 (2019-01)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;처음에는 MEC가 &lt;a href=&#34;https://www.etsi.org/deliver/etsi_gs/MEC/001_099/003/01.01.01_60/gs_MEC003v010101p.pdf&#34;&gt;Mobile Edge Computing&lt;/a&gt; 의 줄임말이었지만 현재는 &lt;a href=&#34;https://www.etsi.org/deliver/etsi_gs/MEC/001_099/003/02.01.01_60/gs_MEC003v020101p.pdf&#34;&gt;Multi-access Edge Computing&lt;/a&gt;입니다.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;사용자 장비(UE, User Equipment)는 휴대폰을 의미할 수 있습니다. 모바일 동글이 있는 노트북을 의미하기도 합니다.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://ko.wikipedia.org/wiki/FCAPS&#34;&gt;FCAPS&lt;/a&gt;: &lt;strong&gt;F&lt;/strong&gt;ault(장애), &lt;strong&gt;C&lt;/strong&gt;onfiguration(구성), &lt;strong&gt;A&lt;/strong&gt;ccounting(계정), &lt;strong&gt;P&lt;/strong&gt;erformance(성능), &lt;strong&gt;S&lt;/strong&gt;ecurity(보안)&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
- https://markruler.github.io/posts/mec/beginners-guide-to-mec-architecture/ - Im Changsu 2020 - 2024</description>
        </item>
    
    
    
    
  </channel>
</rss> 