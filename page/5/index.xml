<?xml-stylesheet href="/rss.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>임창수</title>
    <link>https://markruler.github.io/</link>
    <description>Recent content on 임창수</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <managingEditor>imcxsu@gmail.com (Im Changsu)</managingEditor>
    <webMaster>imcxsu@gmail.com (Im Changsu)</webMaster>
    <copyright>Im Changsu 2020 - 2024</copyright>
    <lastBuildDate>Mon, 30 Dec 2024 18:38:00 +0900</lastBuildDate>
    
        <atom:link href="https://markruler.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>쿠버네티스 API 접근 제어</title>
        <link>https://markruler.github.io/posts/kubernetes/controlling-access-api/</link>
        <pubDate>Thu, 17 Sep 2020 06:58:08 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/kubernetes/controlling-access-api/</guid>
        <description>임창수 https://markruler.github.io/posts/kubernetes/controlling-access-api/ -&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/controlling-access/&#34;&gt;쿠버네티스 공식 문서&lt;/a&gt;를 번역했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- overview --&gt;
&lt;p&gt;이 페이지는 쿠버네티스 API에 대한 접근 제어의 개요를 제공한다.&lt;/p&gt;
&lt;!-- body --&gt;
&lt;p&gt;사용자는&lt;code&gt;kubectl&lt;/code&gt;, 클라이언트 라이브러리
또는 REST 요청을 통해
&lt;a href=&#34;https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/&#34;&gt;API에 접근한다&lt;/a&gt;.
사용자와 쿠버네티스 서비스 어카운트 모두 API에 접근할 수 있다.
요청이 API에 도달하면,
다음 다이어그램에 설명된 몇 가지 단계를 거친다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/kubernetes/access-control-overview.svg&#34; alt=&#34;Diagram of request handling steps for Kubernetes API request&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;전송-보안&#34;&gt;전송 보안&lt;/h2&gt;
&lt;p&gt;일반적인 쿠버네티스 클러스터에서 API는 443번 포트에서 서비스한다.
API 서버는 인증서를 제시한다.
이 인증서는 종종 자체 서명되기 때문에 일반적으로 사용자 머신의 &lt;code&gt;$USER/.kube/config&lt;/code&gt;은
API 서버의 인증서에 대한 루트 인증서를 포함하며,
시스템 기본 루트 인증서 대신 사용된다.
&lt;code&gt;kube-up.sh&lt;/code&gt;을 사용하여 클러스터를 직접 생성할 때
이 인증서는 일반적으로 &lt;code&gt;$USER/.kube/config&lt;/code&gt;에 자동으로 기록된다.
클러스터에 여러 명의 사용자가 있는 경우, 작성자는 인증서를 다른 사용자와 공유해야 한다.&lt;/p&gt;
&lt;h2 id=&#34;인증&#34;&gt;인증&lt;/h2&gt;
&lt;p&gt;TLS가 설정되면 HTTP 요청이 인증 단계로 넘어간다.
이는 다이어그램에 &lt;strong&gt;1&lt;/strong&gt;단계로 표시되어 있다.
클러스터 생성 스크립트 또는 클러스터 관리자는
API 서버가 하나 이상의 인증기 모듈을 실행하도록 구성하십시오.
인증기는 &lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/authentication/&#34;&gt;여기&lt;/a&gt;에서 더 자세히 서술한다.&lt;/p&gt;
&lt;p&gt;인증 단계로 들어가는 것은 온전한 HTTP 요청이지만
일반적으로 헤더 그리고/또는 클라이언트 인증서만 검사한다.&lt;/p&gt;
&lt;p&gt;인증 모듈은 클라이언트 인증서, 암호 및 일반 토큰, 부트스트랩 토큰,
JWT 토큰(서비스 어카운트에 사용됨)을 포함한다.&lt;/p&gt;
&lt;p&gt;여러 개의 인증 모듈을 지정할 수 있으며,
이 경우 하나의 인증 모듈이 성공할 때까지 각 모듈을 순차적으로 시도한다.&lt;/p&gt;
&lt;p&gt;GCE에서는 클라이언트 인증서, 암호, 일반 토큰 및 JWT 토큰이 모두 사용 가능하다.&lt;/p&gt;
&lt;p&gt;요청을 인증할 수 없는 경우 HTTP 상태 코드 401과 함께 거부된다.
이 외에는 사용자가 특정 &lt;code&gt;username&lt;/code&gt;으로 인증되며,
이 username은 다음 단계에서 사용자의 결정에 사용할 수 있다.
일부 인증기는 사용자 그룹 관리 기능을 제공하는 반면,
이외의 인증기는 그렇지 않다.&lt;/p&gt;
&lt;p&gt;쿠버네티스는 접근 제어 결정과 요청 기록 시 &lt;code&gt;usernames&lt;/code&gt;를 사용하지만,
&lt;code&gt;user&lt;/code&gt; 오브젝트를 가지고 있지 않고 usernames 나 기타 사용자 정보를
오브젝트 저장소에 저장하지도 않는다.&lt;/p&gt;
&lt;h2 id=&#34;인가&#34;&gt;인가&lt;/h2&gt;
&lt;p&gt;특정 사용자로부터 온 요청이 인증된 후에는 인가되어야 한다. 이는 다이어그램에 &lt;strong&gt;2&lt;/strong&gt;단계로 표시되어 있다.&lt;/p&gt;
&lt;p&gt;요청은 요청자의 username, 요청된 작업 및 해당 작업이 영향을 주는 오브젝트를 포함해야 한다. 기존 정책이 요청된 작업을 완료할 수 있는 권한이 해당 사용자에게 있다고 선언하는 경우 요청이 인가된다.&lt;/p&gt;
&lt;p&gt;예를 들어 Bob이 아래와 같은 정책을 가지고 있다면 &lt;code&gt;projectCaribou&lt;/code&gt; 네임스페이스에서만 파드를 읽을 수 있다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &amp;#34;apiVersion&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;abac.authorization.kubernetes.io/v1beta1&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &amp;#34;kind&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;Policy&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &amp;#34;spec&amp;#34;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &amp;#34;user&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;bob&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &amp;#34;namespace&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;projectCaribou&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &amp;#34;resource&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;pods&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &amp;#34;readonly&amp;#34;: &lt;span style=&#34;color:#f00&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Bob이 다음과 같은 요청을 하면 &amp;lsquo;projectCaribou&amp;rsquo; 네임스페이스의 오브젝트를 읽을 수 있기 때문에 요청이 인가된다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;#34;apiVersion&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;authorization.k8s.io/v1beta1&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;#34;kind&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;SubjectAccessReview&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;#34;spec&amp;#34;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &amp;#34;resourceAttributes&amp;#34;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;namespace&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;projectCaribou&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;verb&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;get&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;group&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;unicorn.example.org&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &amp;#34;resource&amp;#34;: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;pods&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Bob이 &lt;code&gt;projectCaribou&lt;/code&gt; 네임스페이스에 있는 오브젝트에 쓰기(&lt;code&gt;create&lt;/code&gt; 또는 &lt;code&gt;update&lt;/code&gt;) 요청을 하면 그의 인가는 거부된다. 만약 Bob이 &lt;code&gt;projectFish&lt;/code&gt;처럼 다른 네임스페이스의 오브젝트 읽기(&lt;code&gt;get&lt;/code&gt;) 요청을 하면 그의 인가는 거부된다.&lt;/p&gt;
&lt;p&gt;쿠버네티스 인가는 공통 REST 속성을 사용하여 기존 조직 전체 또는 클라우드 제공자 전체의 접근 제어 시스템과 상호 작용할 것을 요구한다. 이러한 제어 시스템은 쿠버네티스 API 이외의 다른 API와 상호작용할 수 있으므로 REST 형식을 사용하는 것이 중요하다.&lt;/p&gt;
&lt;p&gt;쿠버네티스는 ABAC 모드, RBAC 모드, 웹훅 모드와 같은 여러 개의 인가 모듈을 지원한다. 관리자가 클러스터를 생성할 때 API 서버에서 사용해야 하는 인가 모듈을 구성했다. 인가 모듈이 2개 이상 구성되면 쿠버네티스가 각 모듈을 확인하고, 어느 모듈이 요청을 승인하면 요청을 진행할 수 있다. 모든 모듈이 요청을 거부하면 요청이 거부된다(HTTP 상태 코드 403).&lt;/p&gt;
&lt;p&gt;인가 모듈을 사용한 정책 생성을 포함해 쿠버네티스 인가에 대해 더 배우려면 &lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz//authorization/&#34;&gt;인가 개요&lt;/a&gt;를 참조하십시오.&lt;/p&gt;
&lt;h2 id=&#34;승인-제어&#34;&gt;승인 제어&lt;/h2&gt;
&lt;p&gt;승인 제어 모듈은 요청을 수정하거나 거부할 수 있는 소프트웨어 모듈이다.
인가 모듈에서 사용할 수 있는 속성 외에도
승인 제어 모듈은 생성되거나 수정된 오브젝트 내용에 접근할 수 있다.&lt;/p&gt;
&lt;p&gt;어드미션 컨트롤러는 오브젝트를 생성, 수정, 삭제 또는 (프록시에) 연결하는 요청에 따라 작동한다.
어드미션 컨트롤러는 단순히 객체를 읽는 요청에 작동하지 않는다.
여러 개의 어드미션 컨트롤러가 구성되면 순서대로 호출된다.&lt;/p&gt;
&lt;p&gt;이는 다이어그램에 &lt;strong&gt;3&lt;/strong&gt;단계로 표시되어 있다.&lt;/p&gt;
&lt;p&gt;인증 및 인가 모듈과 달리,
승인 제어 모듈이 거부되면 요청은 즉시 거부된다.&lt;/p&gt;
&lt;p&gt;승인 제어 모듈은 오브젝트를 거부하는 것 외에도
필드의 복잡한 기본값을 설정할 수 있다.&lt;/p&gt;
&lt;p&gt;사용 가능한 승인 제어 모듈은 &lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/&#34;&gt;여기&lt;/a&gt;에 서술되어 있다.&lt;/p&gt;
&lt;p&gt;요청이 모든 승인 제어 모듈을 통과하면 유효성 검사 루틴을 사용하여 해당 API 오브젝트를 검증한 후
오브젝트 저장소에 기록(&lt;strong&gt;4단계&lt;/strong&gt;)된다.&lt;/p&gt;
&lt;h2 id=&#34;api-서버-포트와-ip&#34;&gt;API 서버 포트와 IP&lt;/h2&gt;
&lt;p&gt;이전의 논의는 (일반적인 경우) API 서버의 보안 포트로 전송되는 요청에 적용된다.
API 서버는 실제로 다음과 같이 2개의 포트에서 서비스할 수 있다.&lt;/p&gt;
&lt;p&gt;기본적으로 쿠버네티스 API 서버는 2개의 포트에서 HTTP 서비스를 한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;로컬호스트 포트&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테스트 및 부트스트랩을 하기 위한 것이며 마스터 노드의 다른 구성요소
(스케줄러, 컨트롤러 매니저)가 API와 통신하기 위한 것이다.&lt;/li&gt;
&lt;li&gt;TLS가 없다.&lt;/li&gt;
&lt;li&gt;기본 포트는 8080이며, &lt;code&gt;--insecure-port&lt;/code&gt; 플래그를 사용하여 변경한다.&lt;/li&gt;
&lt;li&gt;기본 IP는 로컬호스트(localhost)이며, &lt;code&gt;--insecure-bind-address&lt;/code&gt; 플래그를 사용하여 변경한다.&lt;/li&gt;
&lt;li&gt;요청이 인증 및 인가 모듈을 &lt;strong&gt;우회한다&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;요청이 승인 제어 모듈(들)에 의해 처리된다.&lt;/li&gt;
&lt;li&gt;호스트 접근 요구로부터 보호를 받는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;보안 포트&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가능하면 언제나 사용하십시오.&lt;/li&gt;
&lt;li&gt;TLS를 사용하십시오. &lt;code&gt;--tls-cert-file&lt;/code&gt; 플래그로 인증서를 지정하고 &lt;code&gt;--tls-private-key-file&lt;/code&gt; 플래그로 키를 지정하십시오.&lt;/li&gt;
&lt;li&gt;기본 포트는 6443이며, &lt;code&gt;--secure-port&lt;/code&gt; 플래그를 사용하여 변경한다.&lt;/li&gt;
&lt;li&gt;기본 IP는 로컬호스트가 아닌 첫 번째 네트워크 인터페이스이며, &lt;code&gt;--bind-address&lt;/code&gt; 플래그를 사용하여 변경한다.&lt;/li&gt;
&lt;li&gt;요청이 인증 및 인가 모듈에 의해 처리된다.&lt;/li&gt;
&lt;li&gt;요청이 승인 제어 모듈(들)에 의해 처리된다.&lt;/li&gt;
&lt;li&gt;인증 및 인가 모듈을 실행한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GCE(구글 컴퓨트 엔진) 및 다른 클라우드 제공자에서 &lt;code&gt;kube-up.sh&lt;/code&gt;로 클러스터를 생성하면
API 서버는 포트 443에서 서비스한다.
GCE에서는 외부 HTTPS가 API에 접근할 수 있도록 프로젝트에서 방화벽 규칙이 구성된다.
이외에 클러스터 설정 방법은 다양하다.&lt;/p&gt;
- https://markruler.github.io/posts/kubernetes/controlling-access-api/ - Im Changsu 2020 - 2024</description>
        </item>
    
    
    
        <item>
        <title>MEC 아키텍처 초심자 가이드</title>
        <link>https://markruler.github.io/posts/mec/beginners-guide-to-mec-architecture/</link>
        <pubDate>Sun, 13 Sep 2020 20:58:08 +0900</pubDate>
        <author>imcxsu@gmail.com (Im Changsu)</author>
        <guid>https://markruler.github.io/posts/mec/beginners-guide-to-mec-architecture/</guid>
        <description>임창수 https://markruler.github.io/posts/mec/beginners-guide-to-mec-architecture/ -&lt;blockquote&gt;
&lt;p&gt;Faisal Khan의 &lt;a href=&#34;https://www.telcocloudbridge.com/blog/beginners-guide-to-mec-architecture-multi-access-edge-computing/&#34;&gt;Beginners Guide to MEC Architecture (Multi-access Edge Computing)&lt;/a&gt;을 번역한 글입니다.
저자의 허락을 받아 번역했습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MEC&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 아키텍처 가이드에 오신 것을 환영합니다!&lt;/p&gt;
&lt;p&gt;MEC는 5G의 저지연(low-latency) 서비스를 활용하려는 이동통신사들의 새로운 투자 물결을 가져올 것입니다.
이는 소비자와 더 가까운 곳, 즉 무선 기지국(radio site)과 가까운 곳에서 서비스를 운영하겠다는 것을 의미합니다.&lt;/p&gt;
&lt;p&gt;MEC는 서비스 사업자들에게 새로운 서비스 분야와 수익 창출의 수단입니다.
예를 들어 더 빠른 게임 경험, 증강/가상 현실, 커넥티드 카 등이 있습니다.&lt;/p&gt;
&lt;p&gt;이러한 잠재력 때문에 Azure, AWS, Google과 같은 웹 스케일러(web scaler)도
이 흐름에 뛰어들어 갑자기 자신들의 MEC 플랫폼을 구축하는 데 자금을 투입하기 시작한 것입니다.&lt;/p&gt;
&lt;p&gt;이 MEC 아키텍처 가이드는 사실상 MEC 표준 기구인 ETSI 모델을 기반으로 하고 있습니다.
MEC 아키텍처를 처음부터 단계적으로 설명하며, 사전 지식이 없더라도 이해할 수 있도록 구성되어 있습니다.&lt;/p&gt;
&lt;p&gt;MEC 아키텍처를 이해하면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서비스 사업자는 표준 기반 MEC 플랫폼/아키텍처로 전환하는 방법을 알게 됩니다.&lt;/li&gt;
&lt;li&gt;벤더와 개발사는 솔루션 제품이 ETSI MEC 모델에 얼마나 부합하는지 고객에게 설명할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그럼 바로 시작해 보겠습니다!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-mec%EC%9D%98-%EC%A0%95%EC%9D%98&#34;&gt;1. MEC의 정의&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-etsi%EC%97%90-%EB%94%B0%EB%A5%B8-mec-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98&#34;&gt;2. ETSI에 따른 MEC 아키텍처&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#2-0-%EA%B0%80%EC%83%81%ED%99%94-%EC%9D%B8%ED%94%84%EB%9D%BC-%EB%A7%A4%EB%8B%88%EC%A0%80-vim-virtualization-infrastructure-manager&#34;&gt;2-0. 가상화 인프라 매니저 (VIM, Virtualization Infrastructure Manager)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-1-mec-host&#34;&gt;2-1. MEC Host&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#2-1-1-mec-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98&#34;&gt;2-1-1. MEC 애플리케이션&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-1-2-mec-%ED%94%8C%EB%9E%AB%ED%8F%BC&#34;&gt;2-1-2. MEC 플랫폼&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#2-1-2-1-mec-%EC%84%9C%EB%B9%84%EC%8A%A4&#34;&gt;2-1-2-1. MEC 서비스&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-1-2-2-%ED%8A%B8%EB%9E%98%ED%94%BD-%EA%B7%9C%EC%B9%99-%EC%A0%9C%EC%96%B4-traffic-rules-control&#34;&gt;2-1-2-2. 트래픽 규칙 제어 (Traffic Rules Control)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-1-2-3-dns-%ED%95%B8%EB%93%A4%EB%A7%81&#34;&gt;2-1-2-3. DNS 핸들링&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-2-mec-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EB%A7%A4%EB%8B%88%EC%A0%80-mec-platform-manager&#34;&gt;2-2. MEC 플랫폼 매니저 (MEC Platform Manager)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-3-%EB%A9%80%ED%8B%B0-%EC%95%A1%EC%84%B8%EC%8A%A4-%EC%97%90%EC%A7%80-%EC%98%A4%EC%BC%80%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0-multi-access-edge-orchestrator&#34;&gt;2-3. 멀티 액세스 에지 오케스트레이터 (Multi-access Edge Orchestrator)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cfs-portal&#34;&gt;CFS Portal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%88%98%EB%AA%85-%EC%A3%BC%EA%B8%B0-%EA%B4%80%EB%A6%AC-%ED%94%84%EB%A1%9D%EC%8B%9C-user-app-lcm-proxy&#34;&gt;사용자 애플리케이션 수명 주기 관리 프록시 (User App LCM Proxy)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%EC%B0%B8%EC%A1%B0&#34;&gt;참조&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;우리는 밑바닥부터 블록 단위로 MEC 아키텍처를 구축할 것입니다. 🙂&lt;/p&gt;
&lt;h1 id=&#34;1-mec의-정의&#34;&gt;1. MEC의 정의&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.etsi.org/technologies/multi-access-edge-computing&#34;&gt;ETSI&lt;/a&gt;에 따르면 MEC는 다음과 같이 정의됩니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Multi-access Edge Computing (MEC) offers application developers and content providers
cloud-computing capabilities and an IT service environment at the edge of the network.
This environment is characterized by ultra-low latency and high bandwidth
as well as real-time access to radio network information that can be leveraged by applications.&lt;br&gt;
&lt;br&gt;
멀티 액세스 에지 컴퓨팅(MEC)은 애플리케이션 개발자와 콘텐츠 제공자에게
네트워크 에지(edge)에서 클라우드 컴퓨팅 기능과 IT 서비스 환경을 제공합니다.
이 환경은 초저지연과 고대역폭으로 특정지어지며,
애플리케이션에서 활용할 수 있는 무선 네트워크 정보에 대한 접근을 제공합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;2-etsi에-따른-mec-아키텍처&#34;&gt;2. ETSI에 따른 MEC 아키텍처&lt;/h1&gt;
&lt;p&gt;그럼 아래에 표시된 것처럼 완전한 MEC ETSI 아키텍처를 살펴보겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/mec-architecture-according-to-etsi.jpg&#34; alt=&#34;mec-architecture-according-to-etsi&#34;&gt;&lt;/p&gt;
&lt;p&gt;MEC 호스트, MEC 플랫폼 매니저, MEC 오케스트레이터라는 세 가지 주요 블록(block)이 있습니다.&lt;/p&gt;
&lt;p&gt;그러나 이 세 블록을 살펴보기 전에 가장 기본적인 블록인
가상화 인프라 매니저(Virtualization Infrastructure Manager, VIM)부터 시작해보겠습니다.&lt;/p&gt;
&lt;p&gt;가상 네트워크에서는 항상 서버가 필요하며, 이 서버 위에서 가상 머신(VM)을 구동할 수 있어야 합니다.
그리고 이러한 VM에는 관리 계층이 필요합니다.&lt;/p&gt;
&lt;h2 id=&#34;2-0-가상화-인프라-매니저-vim-virtualization-infrastructure-manager&#34;&gt;2-0. 가상화 인프라 매니저 (VIM, Virtualization Infrastructure Manager)&lt;/h2&gt;
&lt;p&gt;VIM은 &lt;a href=&#34;../../nfv/cheat-sheet-understanding-nfv-architecture/#5-vim-virtualized-infrastructure-manager&#34;&gt;NFV의 VIM&lt;/a&gt;과 유사한 기능을 합니다.
물리적 인프라(컴퓨팅, 스토리지, 네트워킹) 위에 VM을 관리하는 것이 목적입니다.
&amp;lsquo;가상화 인프라&amp;rsquo;의 가상 자원을 할당, 유지, 해제하는 역할을 담당합니다.
왼쪽에는 가상화된 인프라로 전환된 서버가 있고, 오른쪽에는 이러한 서버 위의 가상 자원을 관리하는 VIM이 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/virtualization-infrastructure-manager.jpg&#34; alt=&#34;virtualization-infrastructure-manager&#34;&gt;&lt;/p&gt;
&lt;p&gt;VIM과 가상 자원을 이해한 후, 이제 그 위에 MEC 플랫폼과 MEC 애플리케이션을 구축해보겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;2-1-mec-host&#34;&gt;2-1. MEC Host&lt;/h2&gt;
&lt;p&gt;가상화 인프라, MEC 애플리케이션, MEC 플랫폼을 함께 묶어 MEC 호스트라고 부릅니다.&lt;/p&gt;
&lt;p&gt;MEC 애플리케이션부터 살펴보겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;2-1-1-mec-애플리케이션&#34;&gt;2-1-1. MEC 애플리케이션&lt;/h3&gt;
&lt;p&gt;우리가 MEC를 실행하는 이유는 무엇일까요? 바로 애플리케이션을 실행하기 위해서입니다.&lt;/p&gt;
&lt;p&gt;MEC 애플리케이션은 MEC에서 VM 위에서 실행되는 실제 애플리케이션입니다.
쉽게 말해, MEC에서 실행되는 실제 앱들은 게임 애플리케이션이나 가상 현실(VR) 또는 증강 현실(AR)과 같은 것입니다.&lt;/p&gt;
&lt;p&gt;아래 다이어그램은 가상화 인프라 내의 가상 머신 위에 MEC 애플리케이션을 실행하는 모습을 보여줍니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/mec-application.jpg&#34; alt=&#34;mec-application&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-1-2-mec-플랫폼&#34;&gt;2-1-2. MEC 플랫폼&lt;/h3&gt;
&lt;p&gt;이제 다음 단계로 나아가서 우리의 빌딩 블록에 MEC 플랫폼을 추가해 보겠습니다.
MEC 플랫폼 안에는 여러 구성 요소가 있습니다.
그중에서 가장 중요한 것은 &lt;strong&gt;MEC 서비스&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/mec-platform.jpg&#34; alt=&#34;mec-platform&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-1-2-1-mec-서비스&#34;&gt;2-1-2-1. MEC 서비스&lt;/h4&gt;
&lt;p&gt;&amp;lsquo;MEC 서비스&amp;rsquo;는 MEC에서 중요한 블록입니다.
네트워크 관련 API는 MEC 서비스에 의해 노출되며, 위에 표시된 참조점(Reference Point) &lt;code&gt;Mp1&lt;/code&gt;을 통해 MEC 애플리케이션에 제공됩니다.
또한 MEC 플랫폼도 이러한 서비스를 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;여전히 헷갈리시나요?&lt;/p&gt;
&lt;p&gt;MEC ETSI 아키텍처의 장점은 MEC 애플리케이션들이 네트워크 정보를 알고 있다는 점입니다.
즉, MEC 애플리케이션이 네트워크 상태에 따라 조치를 취할 수 있습니다.
여기서 MEC 서비스는 API를 통해 네트워크 정보를 노출시켜 도움을 줄 수 있습니다.&lt;/p&gt;
&lt;p&gt;ETSI에 따르면 &amp;lsquo;MEC 서비스&amp;rsquo;에 의해 적어도 세 가지 유형의 서비스를 노출시켜야 하며,
이들은 서비스 레지스트리의 일부입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;무선 네트워크 상태&lt;/li&gt;
&lt;li&gt;위치 정보 (예: 사용자 장비&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;의 위치)&lt;/li&gt;
&lt;li&gt;대역폭 관리자 - 이 서비스를 사용하면 MEC 애플리케이션과 관련된 트래픽에 대해 대역폭을 할당하고 우선순위를 지정할 수 있도록 해줍니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MEC 서비스에 대해 논의한 후, 우리는 MEC 플랫폼의 다른 두 가지 구성요소도 알아야 합니다.&lt;/p&gt;
&lt;h4 id=&#34;2-1-2-2-트래픽-규칙-제어-traffic-rules-control&#34;&gt;2-1-2-2. 트래픽 규칙 제어 (Traffic Rules Control)&lt;/h4&gt;
&lt;p&gt;이것은 MEC 플랫폼의 중요한 부분입니다.
MEC 플랫폼은 여러 애플리케이션을 동시에 서비스하므로 &amp;lsquo;트래픽 규칙 제어&amp;rsquo; 를 통해 우선순위를 할당할 수 있어야 합니다.&lt;/p&gt;
&lt;h4 id=&#34;2-1-2-3-dns-핸들링&#34;&gt;2-1-2-3. DNS 핸들링&lt;/h4&gt;
&lt;p&gt;모바일 에지 플랫폼은 모든 사용자 장비로부터 수신된 DNS 트래픽을
로컬 DNS 서버/프록시로 라우팅하는 기능을 제공해야 합니다.&lt;/p&gt;
&lt;p&gt;이것이 왜 중요할까요? MEC의 이점은 많은 정보를 인터넷으로 보내지 않고 MEC 내에서 로컬로 처리하는 것입니다.
따라서 트래픽이 인터넷으로 전송되는 대신 로컬에서 처리되도록 로컬 DNS 서버에 DNS 리다이렉션을 처리할 수 있는 방법이 있어야 합니다.&lt;/p&gt;
&lt;p&gt;또한 &lt;code&gt;Mp3&lt;/code&gt; 인터페이스를 통해 기존 MEC 호스트에 연결된 다른 MEC 호스트가 있을 수 있다는 점도 유의해야 합니다.&lt;/p&gt;
&lt;p&gt;지금까지 VIM, MEC 플랫폼, MEC 애플리케이션을 다뤘지만,
MEC 플랫폼과 애플리케이션 자체의 관리는 어떻게 이루어질까요?
여기서 &lt;strong&gt;MEC 플랫폼 매니저&lt;/strong&gt;가 등장합니다.&lt;/p&gt;
&lt;h2 id=&#34;2-2-mec-플랫폼-매니저-mec-platform-manager&#34;&gt;2-2. MEC 플랫폼 매니저 (MEC Platform Manager)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/mec-platform-manager.jpg&#34; alt=&#34;mec-platform-manager&#34;&gt;&lt;/p&gt;
&lt;p&gt;NFV의 VNFM에 대해 알고 있으시죠?&lt;/p&gt;
&lt;p&gt;MEC 플랫폼 매니저는 VNFM과 동일하거나 더 많은 기능을 수행합니다. 다음과 같은 기능들을 포함합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MEC 애플리케이션의 수명 주기 관리: VM에서 MEC 애플리케이션을 생성(instantiating), 유지(maintaining), 종료(tearing down)하는 작업&lt;/li&gt;
&lt;li&gt;요소 관리: MEC 플랫폼의 FCAPS&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; 관리&lt;/li&gt;
&lt;li&gt;애플리케이션 규칙, 트래픽 규칙, DNS 구성 관리&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;지금까지는 MEC 플랫폼을 관리할 수 있게 되었지만 아직 끝난 것이 아닙니다.
여러 MEC 호스트가 있을 수 있으므로 MEC 플랫폼 관리자도 여러 개 있을 수 있습니다.
따라서 다양한 MEC 플랫폼 매니저들 간의 조정을 담당할 상위 계층이 필요합니다.
여기서 &lt;strong&gt;MEC 오케스트레이터&lt;/strong&gt;가 등장하며, 이를 통해 ETSI 아키텍처가 완성됩니다.&lt;/p&gt;
&lt;h2 id=&#34;2-3-멀티-액세스-에지-오케스트레이터-multi-access-edge-orchestrator&#34;&gt;2-3. 멀티 액세스 에지 오케스트레이터 (Multi-access Edge Orchestrator)&lt;/h2&gt;
&lt;p&gt;MEC 오케스트레이터는 여기서 NFVO 오케스트레이터와 비유할 수 있습니다.&lt;/p&gt;
&lt;p&gt;다음과 같은 기능을 수행합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MEC 애플리케이션 수명 주기 관리(MEC 플랫폼 매니저와 비교해보면 유사한 기능을 수행할 수 있습니다).
오케스트레이터는 MEC 플랫폼 매니저를 통해 애플리케이션과 통신하여 이 기능을 수행합니다.&lt;/li&gt;
&lt;li&gt;패키지 무결성(integrity) 및 신뢰성(authenticity) 검증 기능을 포함하여
애플리케이션 패키지를 설치(on-boarding)합니다.&lt;/li&gt;
&lt;li&gt;지연 시간, 사용 가능한 자원, 제공 가능한 서비스와 같은 제약 조건을 고려하여
애플리케이션 생성(instantiation)에 적합한 MEC 호스트를 선택합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/mec/multi-access-edge-orchestrator.jpg&#34; alt=&#34;multi-access-edge-orchestrator&#34;&gt;&lt;/p&gt;
&lt;p&gt;마지막으로 몇 가지 언급해야 할 것들이 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;cfs-portal&#34;&gt;CFS Portal&lt;/h2&gt;
&lt;p&gt;CFS는 &amp;lsquo;고객 대면 서비스(Customer Facing Service)&amp;lsquo;를 의미합니다.
CFS를 통해 이동통신사의 고객은 새로운 MEC 애플리케이션을 주문하거나
서비스의 SLA(Service Level Agreement, 서비스 수준 계약)를 모니터링할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;사용자-애플리케이션-수명-주기-관리-프록시-user-app-lcm-proxy&#34;&gt;사용자 애플리케이션 수명 주기 관리 프록시 (User App LCM Proxy)&lt;/h2&gt;
&lt;p&gt;이것은 MEC 시스템에서 선택적 기능입니다.
이를 위해 시스템은 &lt;code&gt;UserApps&lt;/code&gt;라는 기능을 지원해야 합니다.&lt;/p&gt;
&lt;p&gt;모바일 에지 시스템이 &lt;code&gt;UserApps&lt;/code&gt; 기능을 지원할 때,
시스템은 사용자 장비(디바이스 애플리케이션이 실행되는 장비)와
특정 모바일 에지 애플리케이션(ME App) 인스턴스 간의 연결을 허용합니다.&lt;/p&gt;
&lt;p&gt;사용자 애플리케이션 LCM 프록시를 지원한다면
디바이스 애플리케이션이 사용자 애플리케이션의 설치(on-boarding), 생성(instantiation), 종료(termination)를 요청할 수 있게 해줍니다.&lt;/p&gt;
&lt;p&gt;간단히 말해, 이 기능이 MEC 시스템에서 지원되면
사용자는 자신의 디바이스에서 MEC 시스템 내 특정 애플리케이션을 실행할 수 있게 됩니다.&lt;/p&gt;
&lt;p&gt;이것으로 MEC 아키텍처 초심자 가이드를 마칩니다.
이제 이 아키텍처에 대해 궁금한 것이 있으면 언제든 질문해 주세요.&lt;/p&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.etsi.org/deliver/etsi_gs/MEC/001_099/003/01.01.01_60/gs_MEC003v010101p.pdf&#34;&gt;ETSI GS MEC 002 V1.1.1 (2016-03)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.etsi.org/deliver/etsi_gs/MEC/001_099/003/02.01.01_60/gs_MEC003v020101p.pdf&#34;&gt;ETSI GS MEC 003 V2.1.1 (2019-01)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;처음에는 MEC가 &lt;a href=&#34;https://www.etsi.org/deliver/etsi_gs/MEC/001_099/003/01.01.01_60/gs_MEC003v010101p.pdf&#34;&gt;Mobile Edge Computing&lt;/a&gt; 의 줄임말이었지만 현재는 &lt;a href=&#34;https://www.etsi.org/deliver/etsi_gs/MEC/001_099/003/02.01.01_60/gs_MEC003v020101p.pdf&#34;&gt;Multi-access Edge Computing&lt;/a&gt;입니다.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;사용자 장비(UE, User Equipment)는 휴대폰을 의미할 수 있습니다. 모바일 동글이 있는 노트북을 의미하기도 합니다.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://ko.wikipedia.org/wiki/FCAPS&#34;&gt;FCAPS&lt;/a&gt;: &lt;strong&gt;F&lt;/strong&gt;ault(장애), &lt;strong&gt;C&lt;/strong&gt;onfiguration(구성), &lt;strong&gt;A&lt;/strong&gt;ccounting(계정), &lt;strong&gt;P&lt;/strong&gt;erformance(성능), &lt;strong&gt;S&lt;/strong&gt;ecurity(보안)&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
- https://markruler.github.io/posts/mec/beginners-guide-to-mec-architecture/ - Im Changsu 2020 - 2024</description>
        </item>
    
    
    
    
  </channel>
</rss> 