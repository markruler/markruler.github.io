<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>case on 임창수 블로그</title>
    <link>https://markruler.github.io/categories/case/</link>
    <description>Recent content in case on 임창수 블로그</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <managingEditor>imcxsu@gmail.com (Im Changsu)</managingEditor>
    <webMaster>imcxsu@gmail.com (Im Changsu)</webMaster>
    <copyright>Im Changsu 2020 - 2024</copyright>
    <lastBuildDate>Thu, 29 Aug 2024 22:38:00 +0900</lastBuildDate><atom:link href="https://markruler.github.io/categories/case/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>IP로 지리적 위치(Geolocation) 찾기</title>
      <link>https://markruler.github.io/posts/network/ip-geolocation/</link>
      <pubDate>Thu, 29 Aug 2024 22:38:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/network/ip-geolocation/</guid>
      <description>현상 약 10ms 응답속도가 예상되는 API에 500~700ms의 응답속도가 발생했다.
원인 해당 API에서는 국가별로 다른 정책을 적용하기 위해 IP로 국가 정보1를 조회하는 기능이 가장 먼저 수행되고 있다. 국가 정보의 출처는 ipapi라는 유료 API 서비스와 IPInfoDB라는 무료 서비스다. 대략적인 코드는 다음과 같다.
@Cacheable(value = CacheName.IPAPI_COUNTRY_CODE, key = &amp;#34;#ipAddress&amp;#34;) public Geolocation findIsoCountryCode(final String ipAddress) { if (isPrivate(ipAddress)) { return Geolocation.korea(); } var ipapi = ipapiFeignClient.findGeolocationByIpAddress(ipAddress, IPAPI_ACCESS_KEY); if (ipapi != null) { return Geolocation.from(ipapi); } var ipInfoDB = ipInfoDBFeignClient.</description>
    </item>
    
    <item>
      <title>Traceparent 헤더로 클라이언트부터 서버까지 추적하기</title>
      <link>https://markruler.github.io/posts/web/traceparent-datadog/</link>
      <pubDate>Thu, 22 Aug 2024 18:00:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/web/traceparent-datadog/</guid>
      <description>개요 모니터링 도구를 확인해보니 며칠동안 특정 기능에 에러가 발생하고 있었다. 해당 에러는 알람 임계점(threshold)보다 낮아서 알람이 발생하지 않았고, 이용자는 버그 리포팅을 하지 않았다. 에러 로그를 확인해보니 서버에서는 유효성 검사를 하지 않았고, 클라이언트 앱에서는 유효하지 않은 파라미터를 전달했다. 서버에서 유효성 검사를 추가할 수 있겠지만, 클라이언트 앱에서의 잘못된 요청(bug)은 원인을 알 수 없었다. 클라이언트 이벤트는 연결되어 있지 않기 때문이다.
또 다른 문제가 있었다. 서버에서는 정상적인 상태 코드와 함께 100ms 정도의 속도로 응답했지만 클라이언트에서는 4초 이상의 지연이 발생하거나 아래와 같은 Akamai 에러 페이지가 응답되었다.</description>
    </item>
    
    <item>
      <title>APM만큼 중요한 네트워크 모니터링</title>
      <link>https://markruler.github.io/posts/web/apm-network-device-troubleshooting-mistakes/</link>
      <pubDate>Thu, 25 Jul 2024 01:22:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/web/apm-network-device-troubleshooting-mistakes/</guid>
      <description>APM은 애플리케이션 성능 모니터링(Application Performance Monitoring)이다. 우리팀이 사용하는 모니터링 서비스 데이터독(Datadog)은 APM에서 많은 것을 확인할 수 있다. (인프라, 로그, 호스트의 프로세스, JVM 런타임 메트릭, 각 리소스별 레이턴시 등등)
문제 어느날 체감이 될 정도로 서비스의 레이턴시가 높아지고, 정각마다 스파이크 발생했다. 또한 서비스 전체에 영향이 있었다.
분석: 쉽게 간과했던 문제 Oracle Session 히스토리를 남겨서 확인했을 때 DB에 부하를 일으키면서 반복적으로 보이는 느린 쿼리가 없었다. DB 문제는 아니었다.
발생 시점에 반영된 소스 코드를 보니까 Public IP로 요청하던 내부 API를 Private IP로 요청하도록 변경했다.</description>
    </item>
    
    <item>
      <title>서버 to 서버 요청 시 발생한 DNS 레이턴시</title>
      <link>https://markruler.github.io/posts/network/server-to-server-dns/</link>
      <pubDate>Thu, 13 Jun 2024 17:40:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/network/server-to-server-dns/</guid>
      <description>배경 분석: dig 으로 테스트  nameserver 8.8.8.8 로 지정 nameserver는 resolv.conf 설정을 따름 비교   해결: 호스트 파일 수정  배경  약 200ms 응답 속도가 예상되는 API가 불규칙적으로 2s까지 스파이크가 발생함.  해당 API에는 서버 to 서버로 요청하는 기능이 여러 개 포함되어 있음.   환경: On-Premise(IDC) 환경에 애플리케이션 서버는 컨테이너가 아닌 스탠드얼론 호스트로 실행됨.  분석: dig 으로 테스트 nameserver 8.8.8.8 로 지정 dig @8.8.8.8 api.</description>
    </item>
    
    <item>
      <title>Too many open files</title>
      <link>https://markruler.github.io/posts/java/too-many-open-files/</link>
      <pubDate>Mon, 20 Mar 2023 21:58:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/java/too-many-open-files/</guid>
      <description>커버 이미지 출처: Stable diffusion &amp;ldquo;swimming pool lane pattern&amp;rdquo;
 증상 Spring framework로 만든 웹 애플리케이션에서 비동기로 HTTP 요청하는 기능을 개발하고 있었다. 요구 사항을 위해 동시에 1,000개 이상의 요청을 보낼 때가 있는데, Too many open files 에러가 발생했다. 작업 PC(Ubuntu 22.04)에서 문제 없이 동작하던 프로그램이 IDC에 위치한 서버(CentOS 7)에서는 OutOfMemoryError가 발생하면서 동작하지 않았다.
java.lang.OutOfMemoryError: unable to create new native thread ... java.util.concurrent.ExecutionException: com.markruler.RuntimeException: request error ... Caused by: java.net.SocketException: Too many open files SocketException인데 Too many open files?</description>
    </item>
    
    <item>
      <title>엘라스틱서치(Elasticsearch)와 데이터 인덱싱 전략</title>
      <link>https://markruler.github.io/posts/search/elasticsearch-batch/</link>
      <pubDate>Wed, 21 Dec 2022 22:20:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/search/elasticsearch-batch/</guid>
      <description>엘라스틱서치(Elasticsearch)는 문서 기반 검색 엔진으로 빠른 키워드 검색 속도를 제공한다. 엘라스틱서치가 빠른 이유는 문서의 단어(term)들을 역색인(inverted index)하기 때문이다. 책에서 특정 단어를 찾는 걸 상상해 보자. 관계형 데이터베이스(RDB, Relational Database)는 LIKE 검색을 통해 검색 키워드가 포함된 모든 페이지를 찾아야 한다. 엘라스틱서치는 책 뒷부분에 있는 색인(index)을 보고 필요한 페이지만 찾으면 된다. 이 글에서는 e커머스 서비스에서 검색 성능을 개선하기 위해 도입한 엘라스틱서치와 인덱싱 전략에 대해 소개한다.
 엘라스틱서치 도입 배경 RDB 데이터를 인덱싱하는 전략  1.</description>
    </item>
    
    <item>
      <title>Jenkins Workspace 동시성 문제</title>
      <link>https://markruler.github.io/posts/ci/jenkins-workspace-concurrency/</link>
      <pubDate>Mon, 14 Nov 2022 00:38:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/ci/jenkins-workspace-concurrency/</guid>
      <description>개요 Jenkins Pipeline을 사용해서 잡 스케줄러를 실행하기 위해 triggers directive를 사용했다.
pipeline { agent any triggers { cron(&amp;#34;* * * * *&amp;#34;) // HERE  } stages {...} post { always { cleanWs(cleanWhenNotBuilt: false, deleteDirs: true, disableDeferredWipeout: true, notFailBuild: true, patterns: [ [pattern: &amp;#39;.git/**&amp;#39;, type: &amp;#39;EXCLUDE&amp;#39;], [pattern: &amp;#39;.gitignore&amp;#39;, type: &amp;#39;EXCLUDE&amp;#39;], [pattern: &amp;#39;.meta/**&amp;#39;, type: &amp;#39;EXCLUDE&amp;#39;], ] ) } } } 해당 Job은 빌드 간 메타데이터(.meta/)를 공유해야 했기 때문에 cleanWs 플러그인에서도 .git 디렉토리와 함께 삭제되지 않도록 설정했다.</description>
    </item>
    
    <item>
      <title>Load Balancer를 활용해서 배포 프로세스를 개선해보자</title>
      <link>https://markruler.github.io/posts/ci/ci-with-lb/</link>
      <pubDate>Wed, 17 Aug 2022 03:44:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/ci/ci-with-lb/</guid>
      <description>개요  기존 프로세스 개선 프로세스 (Continuous Delivery)   도입 과정에서 발생한 문제들  Active Health Check가 필요하다 iptables 서비스를 다시 시작해야 할 때 httpd를 다시 실행해야 할 때   개선의 여지가 있다  SessionRepositoryFilter 에러 페이지 응답 Proxy Akamai 에러 페이지 응답 HAProxy 전환 선언형 배포 (GitOps?)   더 읽을 거리  각주    개요 현재 팀에서 빌드-배포 도구로 Bamboo를 사용하고 있다. 놀랍게도 개발자가 커밋한 소스 코드를 운영 환경에 반영하기까지 14단계의 수동 작업이 필요했다.</description>
    </item>
    
  </channel>
</rss>
