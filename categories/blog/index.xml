<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on 임창수</title>
    <link>https://markruler.github.io/categories/blog/</link>
    <description>Recent content in Blog on 임창수</description>
    <generator>Hugo</generator>
    <language>ko-kr</language>
    <managingEditor>imcxsu@gmail.com (Im Changsu)</managingEditor>
    <webMaster>imcxsu@gmail.com (Im Changsu)</webMaster>
    <copyright>Im Changsu | Since 2020</copyright>
    <lastBuildDate>Mon, 13 Jan 2025 19:13:00 +0900</lastBuildDate>
    <atom:link href="https://markruler.github.io/categories/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>네트워크 대역폭으로 발생한 복합적인 시스템 장애</title>
      <link>https://markruler.github.io/posts/network/nfs-network-bandwidth/</link>
      <pubDate>Mon, 13 Jan 2025 19:13:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/network/nfs-network-bandwidth/</guid>
      <description>&lt;h1 id=&#34;배경&#34;&gt;배경&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IDC마다 다르겠지만 일반적으로 Inbound/Outbound 네트워크 트래픽 양에 따라 비용을 부과합니다. 제가 속한 팀은 트래픽 비용을 줄이기 위해 기존에 사설망(private network) 없이 내부 서버 간 통신하던 시스템에 사설망을 추가했습니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/network/nfs-network-bandwidth/static-file-server.png&#34; alt=&#34;static-file-server.png&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DB 백업을 위해 Veeam을 사용하다가 expdp와 RMAN을 사용하기 시작했고, NFS 마운트 된 스토리지에 백업본을 저장했습니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;문제&#34;&gt;문제&lt;/h1&gt;&#xA;&lt;p&gt;NFS 마운트 된 정적 파일들(이미지, 스크립트 파일)을 조회하는 서버에서만 부하가 발생하기 시작했습니다.&lt;/p&gt;&#xA;&lt;p&gt;확인해보니 DB 서버 회선에서 허용되는 네트워크 대역폭(1Gbps)의 100%를 사용하는 경우가 계속 발생했고, 덩달아 NFS 접근도 느려진 것입니다.&#xA;백업 기능을 변경한 후 발생했습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>IP로 지리적 위치(Geolocation) 찾기</title>
      <link>https://markruler.github.io/posts/network/ip-geolocation/</link>
      <pubDate>Thu, 29 Aug 2024 22:38:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/network/ip-geolocation/</guid>
      <description>&lt;h1 id=&#34;현상&#34;&gt;현상&lt;/h1&gt;&#xA;&lt;p&gt;약 10ms 응답속도가 예상되는 API에 500~700ms의 응답속도가 발생했습니다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;원인&#34;&gt;원인&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/network/ip-geolocation/ipapi-latency.png&#34; alt=&#34;ipapi Latency&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;해당 API에서는 국가별로 다른 정책을 적용하기 위해 IP로 국가 정보&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;를 조회하는 기능이 가장 먼저 수행됩니다.&#xA;국가 정보의 출처는 ipapi라는 유료 API 서비스와 IPInfoDB라는 무료 서비스입니다.&#xA;대략적인 코드는 다음과 같습니다.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;@Cacheable(value = CacheName.IPAPI_COUNTRY_CODE, key = &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;#ipAddress&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;public&lt;/span&gt; Geolocation &lt;span style=&#34;color:#ff0&#34;&gt;findIsoCountryCode&lt;/span&gt;(&lt;span style=&#34;color:#f00&#34;&gt;final&lt;/span&gt; String ipAddress) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; (isPrivate(ipAddress)) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; Geolocation.korea();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;var&lt;/span&gt; ipapi = ipapiFeignClient.findGeolocationByIpAddress(ipAddress, IPAPI_ACCESS_KEY);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; (ipapi != &lt;span style=&#34;color:#f00&#34;&gt;null&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; Geolocation.from(ipapi);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;var&lt;/span&gt; ipInfoDB = ipInfoDBFeignClient.findGeolocationByIpAddress(ipAddress, IPINFODB_ACCESS_KEY);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;if&lt;/span&gt; (ipInfoDB != &lt;span style=&#34;color:#f00&#34;&gt;null&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; Geolocation.from(ipInfoDB);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00&#34;&gt;return&lt;/span&gt; Geolocation.korea();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;문제는 API가 아무리 빨라도 해당 IP Geolocation 서비스에서 응답받는 데에 평균 약 500ms 정도 소요되었다는 것입니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Traceparent 헤더로 클라이언트부터 서버까지 추적하기</title>
      <link>https://markruler.github.io/posts/web/traceparent-datadog/</link>
      <pubDate>Thu, 22 Aug 2024 18:00:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/web/traceparent-datadog/</guid>
      <description>&lt;h1 id=&#34;개요&#34;&gt;개요&lt;/h1&gt;&#xA;&lt;p&gt;모니터링 도구를 확인해보니 며칠동안 특정 기능에 에러가 발생하고 있었습니다.&#xA;해당 에러는 알람 임계점(threshold)보다 낮아서 알람이 발생하지 않았고, 이용자는 버그 리포팅을 하지 않았습니다.&#xA;에러 로그를 확인해보니 서버에서는 유효성 검사를 하지 않았고, 클라이언트 앱에서는 유효하지 않은 파라미터를 전달했습니다.&#xA;서버에서 유효성 검사를 추가할 수 있겠지만, 클라이언트 앱에서의 잘못된 요청(bug)은 원인을 알 수 없었습니다.&#xA;클라이언트 이벤트는 연결되어 있지 않았기 때문입니다.&lt;/p&gt;&#xA;&lt;p&gt;또 다른 문제가 있었습니다.&#xA;서버에서는 정상적인 상태 코드와 함께 100ms 정도의 속도로 응답했지만&#xA;클라이언트에서는 4초 이상의 지연이 발생하거나 아래와 같은 Akamai 에러 페이지가 응답되었습니다.&#xA;그리고 모든 요청이 아닌 전체 요청의 5% 정도에서만 발생하고 있었습니다.&#xA;하지만 국가, Edge IP, User Agent, 요청 URL 등을 확인해봐도 특정 패턴을 보이는 것이 없어서 원인을 알 수 없었습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>APM만큼 중요한 네트워크 모니터링</title>
      <link>https://markruler.github.io/posts/web/apm-network-device-troubleshooting-mistakes/</link>
      <pubDate>Thu, 25 Jul 2024 01:22:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/web/apm-network-device-troubleshooting-mistakes/</guid>
      <description>&lt;p&gt;APM은 애플리케이션 성능 모니터링(Application Performance Monitoring)입니다.&#xA;저희 팀이 사용하는 모니터링 서비스 데이터독(Datadog)은 APM에서 많은 것을 확인할 수 있습니다.&#xA;(인프라, 로그, 호스트의 프로세스, JVM 런타임 메트릭, 각 리소스별 레이턴시 등등)&lt;/p&gt;&#xA;&lt;h1 id=&#34;문제&#34;&gt;문제&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/apm-network-device-troubleshooting-mistakes/first.png&#34; alt=&#34;First&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;어느날 체감이 될 정도로 서비스의 레이턴시가 높아지고, 정각마다 스파이크 발생했습니다.&#xA;또한 서비스 전체에 영향이 있었습니다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;분석-쉽게-간과했던-문제&#34;&gt;분석: 쉽게 간과했던 문제&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://markruler.github.io/posts/db/oracle-dbms-session-diagnosis/&#34;&gt;Oracle Session 히스토리&lt;/a&gt;를 남겨서 확인했을 때&#xA;DB에 부하를 일으키면서 반복적으로 보이는 느린 쿼리가 없었습니다.&#xA;DB 문제는 아니었습니다.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://markruler.github.io/images/web/apm-network-device-troubleshooting-mistakes/oracle-session.webp&#34; alt=&#34;Oracle Session 히스토리&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>서버 to 서버 요청 시 발생한 DNS 레이턴시</title>
      <link>https://markruler.github.io/posts/network/server-to-server-dns/</link>
      <pubDate>Thu, 13 Jun 2024 17:40:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/network/server-to-server-dns/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EB%B0%B0%EA%B2%BD&#34;&gt;배경&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EB%B6%84%EC%84%9D-dig-%EC%9C%BC%EB%A1%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8&#34;&gt;분석: dig 으로 테스트&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#nameserver-8888-%EB%A1%9C-%EC%A7%80%EC%A0%95&#34;&gt;nameserver 8.8.8.8 로 지정&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#nameserver%EB%8A%94-resolvconf-%EC%84%A4%EC%A0%95%EC%9D%84-%EB%94%B0%EB%A5%B8%EB%8B%A4&#34;&gt;nameserver는 &lt;code&gt;resolv.conf&lt;/code&gt; 설정을 따른다&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EB%B9%84%EA%B5%90&#34;&gt;비교&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%ED%95%B4%EA%B2%B0-%ED%98%B8%EC%8A%A4%ED%8A%B8-%ED%8C%8C%EC%9D%BC-%EC%88%98%EC%A0%95&#34;&gt;해결: 호스트 파일 수정&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;배경&#34;&gt;배경&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;약 200ms 응답 속도가 예상되는 API가 불규칙적으로 2s까지 스파이크가 발생했습니다.&#xA;&lt;ul&gt;&#xA;&lt;li&gt;해당 API에는 서버 to 서버로 요청하는 기능이 여러 개 포함되어 있습니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;환경: On-Premise(IDC) 환경에 애플리케이션 서버는 컨테이너가 아닌 스탠드얼론 호스트로 실행됩니다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;분석-dig-으로-테스트&#34;&gt;분석: dig 으로 테스트&lt;/h1&gt;&#xA;&lt;h2 id=&#34;nameserver-8888-로-지정&#34;&gt;nameserver 8.8.8.8 로 지정&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dig @8.8.8.8 api.example.com&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;첫번째 요청 292 msec&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;;; Query time: &lt;span style=&#34;color:#f60&#34;&gt;292&lt;/span&gt; msec&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;;; SERVER: 8.8.8.8#53(8.8.8.8) (UDP)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;;; WHEN: Tue Jun &lt;span style=&#34;color:#f60&#34;&gt;11&lt;/span&gt; 11:00:54 KST &lt;span style=&#34;color:#f60&#34;&gt;2024&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;;; MSG SIZE  rcvd: &lt;span style=&#34;color:#f60&#34;&gt;154&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2번째 요청 36 msec&lt;/p&gt;</description>
    </item>
    <item>
      <title>Too many open files</title>
      <link>https://markruler.github.io/posts/java/too-many-open-files/</link>
      <pubDate>Mon, 20 Mar 2023 21:58:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/java/too-many-open-files/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;커버 이미지 출처: &lt;a href=&#34;https://stablediffusionweb.com/&#34;&gt;Stable diffusion&lt;/a&gt; &amp;ldquo;swimming pool lane pattern&amp;rdquo;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;증상&#34;&gt;증상&lt;/h1&gt;&#xA;&lt;p&gt;Spring framework로 만든 웹 애플리케이션에서 비동기로 HTTP 요청하는 기능을 개발하고 있었습니다.&#xA;요구 사항을 위해 동시에 1,000개 이상의 요청을 보낼 때가 있는데, &lt;code&gt;Too many open files&lt;/code&gt; 에러가 발생했습니다.&#xA;작업 PC(Ubuntu 22.04)에서 문제 없이 동작하던 프로그램이&#xA;IDC에 위치한 서버(CentOS 7)에서는 &lt;code&gt;OutOfMemoryError&lt;/code&gt;가 발생하면서 동작하지 않았습니다.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;java.lang.OutOfMemoryError: unable to create new native thread&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;java.util.concurrent.ExecutionException: com.markruler.RuntimeException: request error&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Caused by: java.net.SocketException: Too many open files&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;SocketException&lt;/code&gt;인데 &lt;code&gt;Too many open files&lt;/code&gt;? &lt;strong&gt;이게 OOM&lt;/strong&gt;?&#xA;이해되지 않았습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>엘라스틱서치(Elasticsearch)와 데이터 인덱싱 전략</title>
      <link>https://markruler.github.io/posts/search/elasticsearch-indexing-strategy/</link>
      <pubDate>Wed, 21 Dec 2022 22:20:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/search/elasticsearch-indexing-strategy/</guid>
      <description>&lt;p&gt;엘라스틱서치(Elasticsearch)는 문서 기반 검색 엔진으로 빠른 키워드 검색 속도를 제공합니다.&#xA;엘라스틱서치가 빠른 이유는 문서의 단어(term)들을 역색인(inverted index)하기 때문입니다.&#xA;책에서 특정 단어를 찾는 걸 상상해 보죠.&#xA;&lt;strong&gt;관계형 데이터베이스(RDB, Relational Database)는&lt;/strong&gt; &lt;code&gt;LIKE&lt;/code&gt; 검색을 통해 검색 키워드가 포함된 &lt;strong&gt;모든 페이지를 찾아야 합니다&lt;/strong&gt;.&#xA;&lt;strong&gt;엘라스틱서치는&lt;/strong&gt; 책 뒷부분에 있는 색인(index)을 보고 &lt;strong&gt;필요한 페이지만 찾으면 됩니다&lt;/strong&gt;.&#xA;이 글에서는 e커머스 서비스에서 검색 성능을 개선하기 위해 도입한 엘라스틱서치와 인덱싱 전략에 대해 소개합니다.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98-%EB%8F%84%EC%9E%85-%EB%B0%B0%EA%B2%BD&#34;&gt;엘라스틱서치 도입 배경&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#rdb-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9D%B8%EB%8D%B1%EC%8B%B1%ED%95%98%EB%8A%94-%EC%A0%84%EB%9E%B5&#34;&gt;RDB 데이터를 인덱싱하는 전략&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#1-%EA%B0%80%EC%9E%A5-%EC%89%AC%EC%9A%B4-%EB%B0%A9%EB%B2%95-batch&#34;&gt;1. 가장 쉬운 방법 Batch&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#2-update-%EB%8D%B0%EC%9D%B4%ED%84%B0&#34;&gt;2. UPDATE 데이터&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#3-hard-delete-%EB%8D%B0%EC%9D%B4%ED%84%B0&#34;&gt;3. HARD DELETE 데이터&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EB%8D%94-%EA%B0%9C%EC%84%A0%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%B6%80%EB%B6%84&#34;&gt;더 개선할 수 있는 부분&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EC%9D%B4-%EA%B3%A0%EB%AF%BC%EC%9D%84-%EC%A0%80%EB%A7%8C-%ED%96%88%EB%8D%98-%EA%B2%8C-%EC%95%84%EB%8B%88%EC%97%88%EC%8A%B5%EB%8B%88%EB%8B%A4&#34;&gt;이 고민을 저만 했던 게 아니었습니다&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;엘라스틱서치-도입-배경&#34;&gt;엘라스틱서치 도입 배경&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;매일 새벽에 장애가 발생하기 시작했습니다&lt;/strong&gt;.&#xA;유저 트래픽이 주로 새벽에 몰리는데, 이때 DB 레이턴시가 높아져서 모든 서버에 장애가 발생했습니다.&#xA;왜 DB 레이턴시가 높았을까요?&#xA;현재 서비스에서 트래픽이 가장 많이 발생하는 페이지가 메인, 상품 검색, 상품 상세 페이지입니다.&#xA;이 중 검색 페이지에서 쿼리 대기 시간이 길어지고 있었습니다.&#xA;원인은 크게 다음과 같습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Jenkins Workspace 동시성 문제</title>
      <link>https://markruler.github.io/posts/ci/jenkins-workspace-concurrency/</link>
      <pubDate>Mon, 14 Nov 2022 00:38:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/ci/jenkins-workspace-concurrency/</guid>
      <description>&lt;h1 id=&#34;개요&#34;&gt;개요&lt;/h1&gt;&#xA;&lt;p&gt;Jenkins Pipeline을 사용해서 잡 스케줄러를 실행하기 위해&#xA;&lt;a href=&#34;https://www.jenkins.io/doc/book/pipeline/syntax/#triggers&#34;&gt;triggers&lt;/a&gt; directive를 사용했습니다.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;display:grid;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pipeline {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    agent any&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    triggers {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cron(&lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#34;* * * * *&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#0f0&#34;&gt;// HERE&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&lt;/span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    stages {...}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    post {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        always {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            cleanWs(cleanWhenNotBuilt: &lt;span style=&#34;color:#f00&#34;&gt;false&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    deleteDirs: &lt;span style=&#34;color:#f00&#34;&gt;true&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    disableDeferredWipeout: &lt;span style=&#34;color:#f00&#34;&gt;true&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    notFailBuild: &lt;span style=&#34;color:#f00&#34;&gt;true&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    patterns: [&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        [pattern: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#39;.git/**&amp;#39;&lt;/span&gt;, type: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#39;EXCLUDE&amp;#39;&lt;/span&gt;],&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        [pattern: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#39;.gitignore&amp;#39;&lt;/span&gt;, type: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#39;EXCLUDE&amp;#39;&lt;/span&gt;],&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        [pattern: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#39;.meta/**&amp;#39;&lt;/span&gt;, type: &lt;span style=&#34;color:#87ceeb&#34;&gt;&amp;#39;EXCLUDE&amp;#39;&lt;/span&gt;],&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    ]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            )&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;해당 Job은 빌드 간 메타데이터(&lt;code&gt;.meta/&lt;/code&gt;)를 공유해야 했기 때문에&#xA;&lt;a href=&#34;https://plugins.jenkins.io/ws-cleanup/&#34;&gt;cleanWs&lt;/a&gt; 플러그인에서도&#xA;&lt;code&gt;.git&lt;/code&gt; 디렉토리와 함께 삭제되지 않도록 설정했습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Load Balancer를 활용해서 배포 프로세스를 개선해보자</title>
      <link>https://markruler.github.io/posts/ci/ci-with-lb/</link>
      <pubDate>Wed, 17 Aug 2022 03:44:00 +0900</pubDate><author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/ci/ci-with-lb/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EA%B0%9C%EC%9A%94&#34;&gt;개요&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EA%B8%B0%EC%A1%B4-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4&#34;&gt;기존 프로세스&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EA%B0%9C%EC%84%A0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-continuous-delivery&#34;&gt;개선 프로세스 (Continuous Delivery)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EB%8F%84%EC%9E%85-%EA%B3%BC%EC%A0%95%EC%97%90%EC%84%9C-%EB%B0%9C%EC%83%9D%ED%95%9C-%EB%AC%B8%EC%A0%9C%EB%93%A4&#34;&gt;도입 과정에서 발생한 문제들&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#active-health-check%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%98%EB%8B%A4&#34;&gt;Active Health Check가 필요하다&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#iptables-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EB%8B%A4%EC%8B%9C-%EC%8B%9C%EC%9E%91%ED%95%B4%EC%95%BC-%ED%95%A0-%EB%95%8C&#34;&gt;iptables 서비스를 다시 시작해야 할 때&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#httpd%EB%A5%BC-%EB%8B%A4%EC%8B%9C-%EC%8B%A4%ED%96%89%ED%95%B4%EC%95%BC-%ED%95%A0-%EB%95%8C&#34;&gt;httpd를 다시 실행해야 할 때&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EA%B0%9C%EC%84%A0%EC%9D%98-%EC%97%AC%EC%A7%80%EA%B0%80-%EC%9E%88%EB%8B%A4&#34;&gt;개선의 여지가 있다&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#sessionrepositoryfilter-%EC%97%90%EB%9F%AC-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%9D%91%EB%8B%B5&#34;&gt;&lt;code&gt;SessionRepositoryFilter&lt;/code&gt; 에러 페이지 응답&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#proxy&#34;&gt;Proxy&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#akamai-%EC%97%90%EB%9F%AC-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%9D%91%EB%8B%B5&#34;&gt;Akamai 에러 페이지 응답&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#haproxy-%EC%A0%84%ED%99%98&#34;&gt;HAProxy 전환&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EC%84%A0%EC%96%B8%ED%98%95-%EB%B0%B0%ED%8F%AC-gitops&#34;&gt;선언형 배포 (GitOps?)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EB%8D%94-%EC%9D%BD%EC%9D%84-%EA%B1%B0%EB%A6%AC&#34;&gt;더 읽을 거리&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%EA%B0%81%EC%A3%BC&#34;&gt;각주&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;개요&#34;&gt;개요&lt;/h1&gt;&#xA;&lt;p&gt;현재 팀에서 빌드-배포 도구로 Bamboo를 사용하고 있다.&#xA;놀랍게도 개발자가 커밋한 소스 코드를 운영 환경에 반영하기까지 14단계의 수동 작업이 필요했다.&#xA;그래서 개발팀 모두가 배포 작업에 많은 부담을 갖고 있었다.&#xA;한번 빌드하고 배포하는데 최소 30분에서 길면 1시간까지 걸리는 이 불필요한 시간을 줄이고 싶었다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
