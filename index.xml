<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>임창수 블로그</title>
    <link>https://markruler.github.io/</link>
    <description>What, Why, How.</description>
    <generator>Hugo -- gohugo.io</generator>
    
      <language>ko-kr</language>
    
    
      <copyright>Im Changsu 2020 - 2023</copyright>
    
    
      <lastBuildDate>Sun, 30 Apr 2023 23:58:00 +0900</lastBuildDate>
    
    
    
      <atom:link href="https://markruler.github.io/index.xml" rel="self" type="application/rss+xml" />
      
    
    
    
    <item>
      <title>오라클 DBMS 세션 모니터링</title>
      <link>https://markruler.github.io/posts/db/oracle-dbms-session-monitoring/</link>
      <pubDate>Sun, 30 Apr 2023 23:58:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/db/oracle-dbms-session-monitoring/</guid>
      <description>
        개요 현재 팀에서 구독중인 Oracle DBMS의 라이센스는 Standard Edition 2의 Processor 라이센스(이하 SE2)다. 이 라이센스는 프로세서 최대 2개, CPU Threads 최대 16개1까지 사용 가능하다. 만약 트래픽이 많지 않다면 이 정도 사양으로도 충분하겠지만, 트래픽이 많아지거나 DB를 비효율적으로 사용하게 되면 성능 저하가 발생할 수 있다. 하지만 우리는 성능 저하가 발생했을 때 이를 진단할 방법이 없었다. SE2의 경우 AWR(Automatic Workload Repository), ASH(Active Session History)와 같은 Oracle Diagnostics Pack2을 사용할 수 없다.
DB 진단 도구가 필요하다 연산이 오래 걸리는 쿼리의 경우 SQL을 튜닝해서 해결했다.
      </description>
    </item>
    
    
    
    <item>
      <title>Too many open files</title>
      <link>https://markruler.github.io/posts/java/too-many-open-files/</link>
      <pubDate>Mon, 20 Mar 2023 21:58:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/java/too-many-open-files/</guid>
      <description>
        커버 이미지 출처: Stable diffusion &amp;ldquo;swimming pool lane pattern&amp;rdquo;
 증상 Spring framework로 만든 웹 애플리케이션에서 비동기로 HTTP 요청하는 기능을 개발하고 있었다. 요구 사항을 위해 동시에 1,000개 이상의 요청을 보낼 때가 있는데, Too many open files 에러가 발생했다. 작업 PC(Ubuntu 22.04)에서 문제 없이 동작하던 프로그램이 IDC에 위치한 서버(CentOS 7)에서는 OutOfMemoryError가 발생하면서 동작하지 않았다.
java.lang.OutOfMemoryError: unable to create new native thread ... java.util.concurrent.ExecutionException: com.markruler.RuntimeException: request error ... Caused by: java.net.SocketException: Too many open files SocketException인데 Too many open files?
      </description>
    </item>
    
    
    
    <item>
      <title>Jenkins Workspace 동시성 문제</title>
      <link>https://markruler.github.io/posts/ci/jenkins-workspace-concurrency/</link>
      <pubDate>Mon, 14 Nov 2022 00:38:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/ci/jenkins-workspace-concurrency/</guid>
      <description>
        개요 Jenkins Pipeline을 사용해서 잡 스케줄러를 실행하기 위해 triggers directive를 사용했다.
pipeline { agent any triggers { cron(&amp;#34;* * * * *&amp;#34;) // HERE  } stages {...} post { always { cleanWs(cleanWhenNotBuilt: false, deleteDirs: true, disableDeferredWipeout: true, notFailBuild: true, patterns: [ [pattern: &amp;#39;.git/**&amp;#39;, type: &amp;#39;EXCLUDE&amp;#39;], [pattern: &amp;#39;.gitignore&amp;#39;, type: &amp;#39;EXCLUDE&amp;#39;], [pattern: &amp;#39;.meta/**&amp;#39;, type: &amp;#39;EXCLUDE&amp;#39;], ] ) } } } 해당 Job은 빌드 간 메타데이터(.meta/)를 공유해야 했기 때문에 cleanWs 플러그인에서도 .git 디렉토리와 함께 삭제되지 않도록 설정했다.
      </description>
    </item>
    
    
    
    <item>
      <title>Tomcat 이해하기</title>
      <link>https://markruler.github.io/posts/java/tomcat/</link>
      <pubDate>Tue, 23 Aug 2022 02:45:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/java/tomcat/</guid>
      <description>
        Architecture 출처 - Datadog
&amp;lt;?xml version=&amp;#39;1.0&amp;#39; encoding=&amp;#39;utf-8&amp;#39;?&amp;gt; &amp;lt;Server port=&amp;#34;8005&amp;#34; shutdown=&amp;#34;SHUTDOWN&amp;#34;&amp;gt; &amp;lt;Listener className=&amp;#34;org.apache.catalina.core.AprLifecycleListener&amp;#34; SSLEngine=&amp;#34;on&amp;#34; /&amp;gt; &amp;lt;Listener className=&amp;#34;org.apache.catalina.core.JasperListener&amp;#34; /&amp;gt; &amp;lt;Listener className=&amp;#34;org.apache.catalina.core.JreMemoryLeakPreventionListener&amp;#34; /&amp;gt; &amp;lt;Listener className=&amp;#34;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&amp;#34; /&amp;gt; &amp;lt;Listener className=&amp;#34;org.apache.catalina.core.ThreadLocalLeakPreventionListener&amp;#34; /&amp;gt; &amp;lt;GlobalNamingResources&amp;gt; &amp;lt;Resource name=&amp;#34;UserDatabase&amp;#34; auth=&amp;#34;Container&amp;#34; type=&amp;#34;org.apache.catalina.UserDatabase&amp;#34; description=&amp;#34;User database that can be updated and saved&amp;#34; factory=&amp;#34;org.apache.catalina.users.MemoryUserDatabaseFactory&amp;#34; pathname=&amp;#34;conf/tomcat-users.xml&amp;#34; /&amp;gt; &amp;lt;/GlobalNamingResources&amp;gt; &amp;lt;Service name=&amp;#34;Catalina&amp;#34;&amp;gt; &amp;lt;Connector port=&amp;#34;8080&amp;#34; protocol=&amp;#34;HTTP/1.1&amp;#34; redirectPort=&amp;#34;8443&amp;#34; connectionTimeout=&amp;#34;20000&amp;#34; /&amp;gt; &amp;lt;Connector port=&amp;#34;8009&amp;#34; protocol=&amp;#34;AJP/1.3&amp;#34; redirectPort=&amp;#34;8443&amp;#34; /&amp;gt; &amp;lt;Engine name=&amp;#34;Catalina&amp;#34; defaultHost=&amp;#34;localhost&amp;#34;&amp;gt; &amp;lt;Realm className=&amp;#34;org.apache.catalina.realm.LockOutRealm&amp;#34;&amp;gt; &amp;lt;Realm className=&amp;#34;org.apache.catalina.realm.UserDatabaseRealm&amp;#34; resourceName=&amp;#34;UserDatabase&amp;#34;/&amp;gt; &amp;lt;/Realm&amp;gt; &amp;lt;Host name=&amp;#34;localhost&amp;#34; appBase=&amp;#34;webapps&amp;#34; unpackWARs=&amp;#34;true&amp;#34; autoDeploy=&amp;#34;true&amp;#34;&amp;gt; &amp;lt;Valve className=&amp;#34;org.
      </description>
    </item>
    
    
    
    <item>
      <title>X-based desktop</title>
      <link>https://markruler.github.io/posts/gui/x-based-desktop/</link>
      <pubDate>Sun, 21 Aug 2022 23:04:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/gui/x-based-desktop/</guid>
      <description>
        XDG: X Development Group XDG는 FreeDesktop.org 의 옛 이름이다.
 freedesktop.org hosts the development of free and open source software, focused on interoperability and shared technology for open-source graphical and desktop systems.
 관련 소프트웨어 XDG user directories  xdg-user-dirs is a tool to handle well known directories in the users homedir. XDG user directories - archilinux  &amp;gt; echo $XDG_ $XDG_DATA_DIRS $XDG_RUNTIME_DIR &amp;gt; man xdg-user-dirs-update # xdg-user-dirs-update - Update XDG user dir configuration &amp;gt; man xdg-user-dir # xdg-user-dir - Find an XDG user dir &amp;gt; xdg-user-dir DESKTOP &amp;gt; cat /etc/xdg/user-dirs.
      </description>
    </item>
    
    
    
    <item>
      <title>Load Balancer를 활용해서 배포 프로세스를 개선해보자</title>
      <link>https://markruler.github.io/posts/ci/ci-with-lb/</link>
      <pubDate>Wed, 17 Aug 2022 03:44:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/ci/ci-with-lb/</guid>
      <description>
        개요 현재 팀에서 빌드-배포 도구로 Bamboo를 사용하고 있다. 놀랍게도 개발자가 커밋한 소스 코드를 운영 환경에 반영하기까지 14단계의 수동 작업이 필요했다. 그래서 개발팀 모두가 배포 작업에 많은 부담을 갖고 있었다. 한번 빌드하고 배포하는데 최소 30분에서 길면 1시간까지 걸리는 이 불필요한 시간을 줄이고 싶었다.
화살표 방향은 단순히 요청의 흐름을 나타낸다.
단일 서버의 처리량(Capacity)을 초과한 대량 요청 트래픽은 속도 저하나 서비스 지연 또는 장애를 유발한다. 이 상황을 대비해 부하(Load)를 여러 서버로 분산(Balancing)하는 것을 서버 로드 밸런싱(SLB: Server Load Balancing)이라고 한다.
      </description>
    </item>
    
    
    
    <item>
      <title>JVM 모니터링</title>
      <link>https://markruler.github.io/posts/java/jvm-monitoring/</link>
      <pubDate>Mon, 23 May 2022 00:09:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/java/jvm-monitoring/</guid>
      <description>
        모니터링과 타임아웃의 중요성은 아무리 강조해도 지나치지 않는다. 최근 회사에서 아주 느린 API(약 15초)를 발견했는데 분명 매일 트래픽이 발생하는데도 2년동안 방치되고 있었다. 이런 레거시는 유지 보수할 일이 없다면 개발팀에서도 확인하기 어렵다. 사용자가 리포팅해주길 기대하는 것보다 모니터링 도구를 통해 파악하는 것이 좋다. 심지어 굉장히 간단한 문제여서 파악하고 수정하는 데에 1시간도 안걸렸지만 약 15초 걸리던 API를 100ms까지 줄였다.
 먼저 알아두면 좋은 명령어가 있다. jps는 JVM Process Status를 출력하는 명령어로 현재 머신에서 실행중인 JVM의 PID나 실행 옵션을 확인할 때 유용하다.
      </description>
    </item>
    
    
    
    <item>
      <title>모니터링과 타임아웃의 중요성</title>
      <link>https://markruler.github.io/posts/java/java-timeout-monitoring/</link>
      <pubDate>Wed, 11 May 2022 02:19:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/java/java-timeout-monitoring/</guid>
      <description>
        Observability 용어 정리
 상황  현재팀에서 만들고 있는 애플리케이션은 Spring Framework로 작성하고 있다. 계속 특정 애플리케이션과 함께 여러 애플리케이션에서 후속 장애가 발생했다. 장애가 발생할 때마다 특정 API의 커넥션이 끊기지 않고 오랜 시간 유지되고 있었다.  RedisSystemException은 해당 서버를 죽이면서 Redis와 커넥션이 끊어졌기 때문에 발생한 예외다. 만약 서버를 죽이지 않았다면 끝까지 물고 있었을 것이다.
분석 시간만 보고도 Timeout이 설정되어 있지 않다는 것을 확인할 수 있다. 설정하지 않으면 default 값은 -1 로 타임아웃이 발생하지 않는다.
      </description>
    </item>
    
    
    
    <item>
      <title>CLI 환경에서 소스 코드 관리하기</title>
      <link>https://markruler.github.io/posts/shell/git-commands/</link>
      <pubDate>Wed, 01 Dec 2021 23:28:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/shell/git-commands/</guid>
      <description>
        Git Internal  차이가 아니라 스냅샷 데이터의 무결성 Git 프로젝트의 세 가지 단계   Git directory  HEAD refs info objects  tree blob (binary large object) commit tag   index Hash Function config   SCM: Source Code Management 포셀린(Porcelain) 명령어  init clone submodule subtree branch  xargs   tag switch  upstream   status add fetch commit merge pull rebase  squash와 fixup   cherry-pick stash  How git stash works   reset restore revert Git으로 버그 찾기  blame bisect   show log  Triple Dot(&amp;hellip;)   reflog: Reference logs diff push   플러밍(Plumbing) 명령어  rev-parse hash-object ls-tree ls-files cat-file write-tree commit-tree read-tree update-index   Advanced  Git Hooks Garbage Collection  Packfiles gc   prune   Git Server  Fork Branch protection rules   참고   Git의 모든 기능을 지원하는 것은 CLI 뿐이다.
      </description>
    </item>
    
    
    
    <item>
      <title>Go 언어로 컨테이너 이미지 빌드하기</title>
      <link>https://markruler.github.io/posts/container/building-container-images-in-go/</link>
      <pubDate>Sun, 28 Feb 2021 12:49:00 +0900</pubDate>
      <author>imcxsu@gmail.com (Im Changsu)</author>
      <guid>https://markruler.github.io/posts/container/building-container-images-in-go/</guid>
      <description>
        Ahmet Alp Balkan의 Building container images in Go를 번역한 글입니다. 저자의 허락을 받고 번역했습니다.   이 글에서는 도커(Docker)를 사용하지 않고 어떻게 OCI 컨테이너 이미지를 만드는지 설명합니다. 이를 위해 go-containerregistry 모듈을 이용해 프로그래밍해서 레이어 및 이미지 매니페스트를 빌드합니다. 예를 들어 nginx 이미지 위에 정적 웹 사이트 콘텐츠를 추가하여 컨테이너 이미지를 빌드하고 Go 프로그램을 사용하는 gcr.io 같은 레지스트리에 푸시하겠습니다.
순서는 다음과 같습니다.
 도커 허브에서 nginx 이미지를 가져 옵니다(pull). 기존 /usr/share/nginx/html 디렉터리를 삭제하는 새 레이어를 만듭니다.
      </description>
    </item>
    
    
  </channel>
</rss>
